diff --unified --recursive --text a/snmpb-1.0/libsmi/lib/Makefile.am b/snmpb-1.0/libsmi/lib/Makefile.am
--- snmpb-1.0/libsmi/lib/Makefile.am	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/lib/Makefile.am	2021-01-31 17:27:22.000000000 +0100
@@ -8,7 +8,7 @@
 # See the file "COPYING" for information on usage and redistribution
 # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 #
-# @(#) $Id$
+# @(#) $Id: Makefile.am 1817 2014-10-13 13:20:45Z schoenw $
 #
 
 EXTRA_DIST		= parser-yang.y parser-sming.y parser-smi.y \
@@ -45,13 +45,13 @@
 		  	  parser-yang.c scanner-yang.c
 libsmi_la_LDFLAGS	= -version-info @VERSION_LIBTOOL@
 
-parser-smi.c parser-smi.tab.h: parser-smi.y scanner-smi.h parser-smi.h error.h
+parser-smi.tab.h: parser-smi.y scanner-smi.h parser-smi.h error.h
 	$(BISON) --defines=parser-smi.tab.h -t -psmi -o parser-smi.c parser-smi.y
 
-parser-sming.c: parser-sming.y scanner-sming.h parser-sming.h error.h
+parser-sming.tab.h: parser-sming.y scanner-sming.h parser-sming.h error.h
 	$(BISON) --defines=parser-sming.tab.h -t -psming -o parser-sming.c parser-sming.y
 
-parser-yang.c: parser-yang.y scanner-yang.h parser-yang.h error.h
+parser-yang.tab.h: parser-yang.y scanner-yang.h parser-yang.h error.h
 	$(BISON) --defines=parser-yang.tab.h -t -pyang -o parser-yang.c parser-yang.y
 
 scanner-smi.c: scanner-smi.l scanner-smi.h parser-smi.tab.h
@@ -65,6 +65,10 @@
 
 common.c smi.c smi-data.c yang.c yang-data.c: common.h
 
+parser-smi.c: parser-smi.tab.h
+parser-sming.c: parser-sming.tab.h
+parser-yang.c: parser-yang.tab.h
+
 common.h: util.h error.h
 
 error.h: errormacros.h
diff --unified --recursive --text a/snmpb-1.0/libsmi/lib/parser-smi.y b/snmpb-1.0/libsmi/lib/parser-smi.y
--- snmpb-1.0/libsmi/lib/parser-smi.y	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/lib/parser-smi.y	2021-01-31 17:27:22.000000000 +0100
@@ -8,7 +8,7 @@
  * See the file "COPYING" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  *
- * @(#) $Id$
+ * @(#) $Id: parser-smi.y 1812 2014-10-11 16:08:24Z schoenw $
  */
 
 %parse-param { struct Parser *parserPtr }
@@ -347,6 +347,11 @@
 		    smiPrintErrorAtLine(parserPtr, ERR_ROW_PARENT_TYPE,
 					objectPtr->line, objectPtr->export.name);
 		}
+
+		/* Example: crashing in JETDIRECT3-MIB where name is NULL */
+		if (objectPtr->typePtr && !objectPtr->typePtr->export.name)
+			return;
+
 		if (parentPtr->typePtr && parentPtr->typePtr->parentPtr &&
 		    strcmp(parentPtr->typePtr->parentPtr->export.name,
 			   objectPtr->typePtr->export.name)) {
@@ -1094,6 +1099,11 @@
 	    p = nextPtr;
 	}
     } else if (valuePtr->basetype == SMI_BASETYPE_ENUM) {
+
+	/* Example: defval=false on an Unsigned32 type object: would crash */
+	if (typePtr->export.basetype != valuePtr->basetype)
+		return;
+
 	/* a len of -1 indicates an unresolved enum label in ptr */
 	if (valuePtr->len == -1) {
 	    for (listPtr = typePtr->listPtr; listPtr;
diff --unified --recursive --text a/snmpb-1.0/libsmi/lib/smi.c b/snmpb-1.0/libsmi/lib/smi.c
--- snmpb-1.0/libsmi/lib/smi.c	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/lib/smi.c	2021-01-31 17:27:22.000000000 +0100
@@ -8,7 +8,7 @@
  * See the file "COPYING" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  *
- * @(#) $Id$
+ * @(#) $Id: smi.c 1798 2013-06-06 09:14:13Z schoenw $
  */
 
 #include <config.h>
@@ -831,13 +831,13 @@
 int smiReadConfig(const char *filename, const char *tag)
 {
     FILE *file;
-    char buf[201];
+    char buf[10001];
     char *cmd, *arg, *s;
     
     file = fopen(filename, "r");
     if (file) {
 	while (!feof(file)) {
-	    if (!fgets(buf, 200, file)) continue;
+	    if (!fgets(buf, 10000, file)) continue;
 	    if ((!strlen(buf)) || (buf[0] == '#')) continue;
 	    cmd = strtok(buf, " \t\n\r");
 	    if (!cmd) continue;
@@ -848,7 +848,7 @@
 		if (strcmp(cmd, tag)) continue;
 		cmd = strtok(NULL, " \t\n\r");
 	    }
-	    arg = strtok(NULL, " \t\n\r");
+	    arg = strtok(NULL, "\t\n\r");
 	    if (!strcmp(cmd, "load")) {
 		smiLoadModule(arg);
 	    } else if (!strcmp(cmd, "path")) {
@@ -2428,7 +2428,7 @@
     int xlen;
     SmiNamedNumber *nn;
     char *s = NULL, *ss;
-    char f[10];
+    char f[20];
     SmiUnsigned32 v32;
     SmiUnsigned64 v64;
     
@@ -2646,14 +2646,15 @@
 	    (!smiTypePtr->format &&
 	     (smiTypePtr->name && strcmp( smiTypePtr->name, "IpAddress")) ) ) {
 	    for (i = 0; i < smiValuePtr->len; i++) {
-		if (!isprint((int)smiValuePtr->value.ptr[i])) break;
+        int val = smiValuePtr->value.ptr[i];
+        if (!(isprint(val) || ((val >= 0x9) && (val <= 0xd)))) break; /* HTAB,VTAB,LF,FF,CR */
 	    }
 	    if ((i < smiValuePtr->len) ||
 		!(flags & SMI_RENDER_PRINTABLE)) {
 		smiAsprintf(&s, "");
 		for (i=0; i < smiValuePtr->len; i++) {
 		    ss = s;
-		    smiAsprintf(&s, "%s%02x", ss, smiValuePtr->value.ptr[i]);
+            smiAsprintf(&s, "%s%02X ", ss, (smiValuePtr->value.ptr[i]&0xFF));
 		    smiFree(ss);
 		}
 	    } else {
diff --unified --recursive --text a/snmpb-1.0/libsmi/lib/snprintf.c b/snmpb-1.0/libsmi/lib/snprintf.c
--- snmpb-1.0/libsmi/lib/snprintf.c	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/lib/snprintf.c	2021-01-31 17:27:22.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995-1999 Kungliga Tekniska Högskolan
+ * Copyright (c) 1995-2003 Kungliga Tekniska Hï¿½skolan
  * (Royal Institute of Technology, Stockholm, Sweden).
  * All rights reserved.
  * 
@@ -30,9 +30,6 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-
-/* $Id: snprintf.c,v 1.1 2002/07/23 11:48:14 strauss Exp $ */
-
 #include <config.h>
 
 #include <stdio.h>
@@ -42,15 +39,14 @@
 #include <ctype.h>
 #include <sys/types.h>
 
-#ifdef HAVE_DMALLOC_H
-#include <dmalloc.h>
-#endif
-
 #include "snprintf.h"
 
-#ifndef MIN
-#define MIN(a, b)       ((a) < (b) ? (a) : (b))
-#define MAX(a, b)       ((a) < (b) ? (b) : (a))
+#ifndef max
+#define max(a,b) (((a)>(b))?(a):(b))
+#endif
+
+#ifndef min
+#define min(a,b) (((a)<(b))?(a):(b))
 #endif
 
 
@@ -67,213 +63,279 @@
  * Common state
  */
 
-struct state {
-  unsigned char *str;
-  unsigned char *s;
-  unsigned char *theend;
-  size_t sz;
-  size_t max_sz;
-  int (*append_char)(struct state *, unsigned char);
-  int (*reserve)(struct state *, size_t);
-  /* XXX - methods */
+struct snprintf_state {
+    unsigned char *str;
+    unsigned char *s;
+    unsigned char *theend;
+    size_t sz;
+    size_t max_sz;
+    void (*append_char)(struct snprintf_state *, unsigned char);
+    /* XXX - methods */
 };
 
-#ifndef HAVE_VSNPRINTF
+#if !defined(HAVE_VSNPRINTF)
 static int
-sn_reserve (struct state *state, size_t n)
+sn_reserve (struct snprintf_state *state, size_t n)
 {
-  return state->s + n > state->theend;
+    return state->s + n > state->theend;
 }
 
+static void
+sn_append_char (struct snprintf_state *state, unsigned char c)
+{
+    if (!sn_reserve (state, 1))
+	*state->s++ = c;
+}
+#endif
+
 static int
-sn_append_char (struct state *state, unsigned char c)
+as_reserve (struct snprintf_state *state, size_t n)
 {
-  if (sn_reserve (state, 1)) {
-    return 1;
-  } else {
-    *state->s++ = c;
+    if (state->s + n > state->theend) {
+	int off = state->s - state->str;
+	unsigned char *tmp;
+
+	if (state->max_sz && state->sz >= state->max_sz)
+	    return 1;
+
+	state->sz = max(state->sz * 2, state->sz + n);
+	if (state->max_sz)
+	    state->sz = min(state->sz, state->max_sz);
+	tmp = realloc (state->str, state->sz);
+	if (tmp == NULL)
+	    return 1;
+	state->str = tmp;
+	state->s = state->str + off;
+	state->theend = state->str + state->sz - 1;
+    }
     return 0;
-  }
 }
+
+static void
+as_append_char (struct snprintf_state *state, unsigned char c)
+{
+    if(!as_reserve (state, 1))
+	*state->s++ = c;
+}
+
+/* longest integer types */
+
+#ifdef HAVE_LONG_LONG
+typedef unsigned long long u_longest;
+typedef long long longest;
+#else
+typedef unsigned long u_longest;
+typedef long longest;
 #endif
 
+
+
 static int
-as_reserve (struct state *state, size_t n)
+pad(struct snprintf_state *state, int width, char c)
 {
-  if (state->s + n > state->theend) {
-    int off = state->s - state->str;
-    unsigned char *tmp;
-
-    if (state->max_sz && state->sz >= state->max_sz)
-      return 1;
-
-    state->sz = MAX(state->sz * 2, state->sz + n);
-    if (state->max_sz)
-      state->sz = MIN(state->sz, state->max_sz);
-    tmp = realloc (state->str, state->sz);
-    if (tmp == NULL)
-      return 1;
-    state->str = tmp;
-    state->s = state->str + off;
-    state->theend = state->str + state->sz - 1;
-  }
-  return 0;
+    int len = 0;
+    while(width-- > 0){
+	(*state->append_char)(state,  c);
+	++len;
+    }
+    return len;
 }
 
+/* return true if we should use alternatve hex form */
 static int
-as_append_char (struct state *state, unsigned char c)
+use_alternative (int flags, u_longest num, unsigned base)
 {
-  if(as_reserve (state, 1))
-    return 1;
-  else {
-    *state->s++ = c;
-    return 0;
-  }
+    return (flags & alternate_flag) && base == 16 && num != 0;
 }
 
 static int
-append_number(struct state *state,
-	      unsigned long num, unsigned base, char *rep,
+append_number(struct snprintf_state *state,
+	      u_longest num, unsigned base, const char *rep,
 	      int width, int prec, int flags, int minusp)
 {
-  int len = 0;
-  int i;
-
-  /* given precision, ignore zero flag */
-  if(prec != -1)
-    flags &= ~zero_flag;
-  else
-    prec = 1;
-  /* zero value with zero precision -> "" */
-  if(prec == 0 && num == 0)
-    return 0;
-  do{
-    if((*state->append_char)(state, rep[num % base]))
-      return 1;
-    len++;
-    num /= base;
-  }while(num);
-  prec -= len;
-  /* pad with prec zeros */
-  while(prec-- > 0){
-    if((*state->append_char)(state, '0'))
-      return 1;
-    len++;
-  }
-  /* add length of alternate prefix (added later) to len */
-  if(flags & alternate_flag && (base == 16 || base == 8))
-    len += base / 8;
-  /* pad with zeros */
-  if(flags & zero_flag){
-    width -= len;
-    if(minusp || (flags & space_flag) || (flags & plus_flag))
-      width--;
-    while(width-- > 0){
-      if((*state->append_char)(state, '0'))
-	return 1;
-      len++;
-    }
-  }
-  /* add alternate prefix */
-  if(flags & alternate_flag && (base == 16 || base == 8)){
-    if(base == 16)
-      if((*state->append_char)(state, rep[10] + 23)) /* XXX */
-	return 1;
-    if((*state->append_char)(state, '0'))
-      return 1;
-  }
-  /* add sign */
-  if(minusp){
-    if((*state->append_char)(state, '-'))
-      return 1;
-    len++;
-  } else if(flags & plus_flag) {
-    if((*state->append_char)(state, '+'))
-      return 1;
-    len++;
-  } else if(flags & space_flag) {
-    if((*state->append_char)(state, ' '))
-      return 1;
-    len++;
-  }
-  if(flags & minus_flag)
-    /* swap before padding with spaces */
-    for(i = 0; i < len / 2; i++){
-      char c = state->s[-i-1];
-      state->s[-i-1] = state->s[-len+i];
-      state->s[-len+i] = c;
-    }
-  width -= len;
-  while(width-- > 0){
-    if((*state->append_char)(state,  ' '))
-      return 1;
-    len++;
-  }
-  if(!(flags & minus_flag))
-    /* swap after padding with spaces */
-    for(i = 0; i < len / 2; i++){
-      char c = state->s[-i-1];
-      state->s[-i-1] = state->s[-len+i];
-      state->s[-len+i] = c;
+    int len = 0;
+    u_longest n = num;
+    char nstr[64]; /* enough for <192 bit octal integers */
+    int nstart, nlen;
+    char signchar;
+
+    /* given precision, ignore zero flag */
+    if(prec != -1)
+	flags &= ~zero_flag;
+    else
+	prec = 1;
+
+    /* format number as string */
+    nstart = sizeof(nstr);
+    nlen = 0;
+    nstr[--nstart] = '\0';
+    do {
+	nstr[--nstart] = rep[n % base];
+	++nlen;
+	n /= base;
+    } while(n);
+
+    /* zero value with zero precision should produce no digits */
+    if(prec == 0 && num == 0) {
+	nlen--;
+	nstart++;
     }
+
+    /* figure out what char to use for sign */
+    if(minusp)
+	signchar = '-';
+    else if((flags & plus_flag))
+	signchar = '+';
+    else if((flags & space_flag))
+	signchar = ' ';
+    else
+	signchar = '\0';
     
-  return 0;
+    if((flags & alternate_flag) && base == 8) {
+	/* if necessary, increase the precision to 
+	   make first digit a zero */
+
+	/* XXX C99 claims (regarding # and %o) that "if the value and
+           precision are both 0, a single 0 is printed", but there is
+           no such wording for %x. This would mean that %#.o would
+           output "0", but %#.x "". This does not make sense, and is
+           also not what other printf implementations are doing. */
+	
+	if(prec <= nlen && nstr[nstart] != '0' && nstr[nstart] != '\0')
+	    prec = nlen + 1;
+    }
+
+    /* possible formats:
+       pad | sign | alt | zero | digits
+       sign | alt | zero | digits | pad   minus_flag
+       sign | alt | zero | digits zero_flag */
+
+    /* if not right justifying or padding with zeros, we need to
+       compute the length of the rest of the string, and then pad with
+       spaces */
+    if(!(flags & (minus_flag | zero_flag))) {
+	if(prec > nlen)
+	    width -= prec;
+	else
+	    width -= nlen;
+	
+	if(use_alternative(flags, num, base))
+	    width -= 2;
+	
+	if(signchar != '\0')
+	    width--;
+	
+	/* pad to width */
+	len += pad(state, width, ' ');
+    }
+    if(signchar != '\0') {
+	(*state->append_char)(state, signchar);
+	++len;
+    }
+    if(use_alternative(flags, num, base)) {
+	(*state->append_char)(state, '0');
+	(*state->append_char)(state, rep[10] + 23); /* XXX */
+	len += 2;
+    }
+    if(flags & zero_flag) {
+	/* pad to width with zeros */
+	if(prec - nlen > width - len - nlen)
+	    len += pad(state, prec - nlen, '0');
+	else
+	    len += pad(state, width - len - nlen, '0');
+    } else
+	/* pad to prec with zeros */
+	len += pad(state, prec - nlen, '0');
+	
+    while(nstr[nstart] != '\0') {
+	(*state->append_char)(state, nstr[nstart++]);
+	++len;
+    }
+	
+    if(flags & minus_flag)
+	len += pad(state, width - len, ' ');
+
+    return len;
 }
 
+/*
+ * return length
+ */
+
 static int
-append_string (struct state *state,
-	       unsigned char *arg,
+append_string (struct snprintf_state *state,
+	       const unsigned char *arg,
 	       int width,
 	       int prec,
 	       int flags)
 {
-  if(prec != -1)
-    width -= prec;
-  else
-    width -= strlen((char *)arg);
-  if(!(flags & minus_flag))
-    while(width-- > 0)
-      if((*state->append_char) (state, ' '))
-	return 1;
-  if (prec != -1) {
-    while (*arg && prec--)
-      if ((*state->append_char) (state, *arg++))
-	return 1;
-  } else {
-    while (*arg)
-      if ((*state->append_char) (state, *arg++))
-	return 1;
-  }
-  if(flags & minus_flag)
-    while(width-- > 0)
-      if((*state->append_char) (state, ' '))
-	return 1;
-  return 0;
+    int len = 0;
+
+    if(arg == NULL)
+	arg = (const unsigned char*)"(null)";
+
+    if(prec != -1)
+	width -= prec;
+    else
+	width -= strlen((const char *)arg);
+    if(!(flags & minus_flag))
+	len += pad(state, width, ' ');
+
+    if (prec != -1) {
+	while (*arg && prec--) {
+	    (*state->append_char) (state, *arg++);
+	    ++len;
+	}
+    } else {
+	while (*arg) {
+	    (*state->append_char) (state, *arg++);
+	    ++len;
+	}
+    }
+    if(flags & minus_flag)
+	len += pad(state, width, ' ');
+    return len;
 }
 
 static int
-append_char(struct state *state,
+append_char(struct snprintf_state *state,
 	    unsigned char arg,
 	    int width,
 	    int flags)
 {
-  while(!(flags & minus_flag) && --width > 0)
-    if((*state->append_char) (state, ' '))
-      return 1;
-    
-  if((*state->append_char) (state, arg))
-    return 1;
-  while((flags & minus_flag) && --width > 0)
-    if((*state->append_char) (state, ' '))
-      return 1;
-    
-  return 0;
+    int len = 0;
+
+    while(!(flags & minus_flag) && --width > 0) {
+	(*state->append_char) (state, ' ')    ;
+	++len;
+    }
+    (*state->append_char) (state, arg);
+    ++len;
+    while((flags & minus_flag) && --width > 0) {
+	(*state->append_char) (state, ' ');
+	++len;
+    }
+    return 0;
 }
 
 /*
  * This can't be made into a function...
  */
 
+#ifdef HAVE_LONG_LONG
+
+#define PARSE_INT_FORMAT(res, arg, unsig) \
+if (long_long_flag) \
+     res = (unsig long long)va_arg(arg, unsig long long); \
+else if (long_flag) \
+     res = (unsig long)va_arg(arg, unsig long); \
+else if (short_flag) \
+     res = (unsig short)va_arg(arg, unsig int); \
+else \
+     res = (unsig int)va_arg(arg, unsig int)
+
+#else
+
 #define PARSE_INT_FORMAT(res, arg, unsig) \
 if (long_flag) \
      res = (unsig long)va_arg(arg, unsig long); \
@@ -282,350 +344,356 @@
 else \
      res = (unsig int)va_arg(arg, unsig int)
 
+#endif
+
 /*
- * zyxprintf - return 0 or -1
+ * zyxprintf - return length, as snprintf
  */
 
 static int
-xyzprintf (struct state *state, const char *char_format, va_list ap)
+xyzprintf (struct snprintf_state *state, const char *char_format, va_list ap)
 {
-  const unsigned char *format = (const unsigned char *)char_format;
-  unsigned char c;
-
-  while((c = *format++)) {
-    if (c == '%') {
-      int flags      = 0;
-      int width      = 0;
-      int prec       = -1;
-      int long_flag  = 0;
-      int short_flag = 0;
-
-      /* flags */
-      while((c = *format++)){
-	if(c == '-')
-	  flags |= minus_flag;
-	else if(c == '+')
-	  flags |= plus_flag;
-	else if(c == ' ')
-	  flags |= space_flag;
-	else if(c == '#')
-	  flags |= alternate_flag;
-	else if(c == '0')
-	  flags |= zero_flag;
-	else
-	  break;
-      }
+    const unsigned char *format = (const unsigned char *)char_format;
+    unsigned char c;
+    int len = 0;
+
+    while((c = *format++)) {
+	if (c == '%') {
+	    int flags          = 0;
+	    int width          = 0;
+	    int prec           = -1;
+	    int long_long_flag = 0;
+	    int long_flag      = 0;
+	    int short_flag     = 0;
+
+	    /* flags */
+	    while((c = *format++)){
+		if(c == '-')
+		    flags |= minus_flag;
+		else if(c == '+')
+		    flags |= plus_flag;
+		else if(c == ' ')
+		    flags |= space_flag;
+		else if(c == '#')
+		    flags |= alternate_flag;
+		else if(c == '0')
+		    flags |= zero_flag;
+		else if(c == '\'')
+		    ; /* just ignore */
+		else
+		    break;
+	    }
       
-      if((flags & space_flag) && (flags & plus_flag))
-	flags ^= space_flag;
+	    if((flags & space_flag) && (flags & plus_flag))
+		flags ^= space_flag;
 
-      if((flags & minus_flag) && (flags & zero_flag))
-	flags ^= zero_flag;
+	    if((flags & minus_flag) && (flags & zero_flag))
+		flags ^= zero_flag;
 
-      /* width */
-      if (isdigit(c))
-	do {
-	  width = width * 10 + c - '0';
-	  c = *format++;
-	} while(isdigit(c));
-      else if(c == '*') {
-	width = va_arg(ap, int);
-	c = *format++;
-      }
-
-      /* precision */
-      if (c == '.') {
-	prec = 0;
-	c = *format++;
-	if (isdigit(c))
-	  do {
-	    prec = prec * 10 + c - '0';
-	    c = *format++;
-	  } while(isdigit(c));
-	else if (c == '*') {
-	  prec = va_arg(ap, int);
-	  c = *format++;
+	    /* width */
+	    if (isdigit(c))
+		do {
+		    width = width * 10 + c - '0';
+		    c = *format++;
+		} while(isdigit(c));
+	    else if(c == '*') {
+		width = va_arg(ap, int);
+		c = *format++;
+	    }
+
+	    /* precision */
+	    if (c == '.') {
+		prec = 0;
+		c = *format++;
+		if (isdigit(c))
+		    do {
+			prec = prec * 10 + c - '0';
+			c = *format++;
+		    } while(isdigit(c));
+		else if (c == '*') {
+		    prec = va_arg(ap, int);
+		    c = *format++;
+		}
+	    }
+
+	    /* size */
+
+	    if (c == 'h') {
+		short_flag = 1;
+		c = *format++;
+	    } else if (c == 'l') {
+		long_flag = 1;
+		c = *format++;
+		if (c == 'l') {
+		    long_long_flag = 1;
+		    c = *format++;
+		}
+	    }
+
+	    if(c != 'd' && c != 'i')
+		flags &= ~(plus_flag | space_flag);
+
+	    switch (c) {
+	    case 'c' :
+		append_char(state, va_arg(ap, int), width, flags);
+		++len;
+		break;
+	    case 's' :
+		len += append_string(state,
+				     va_arg(ap, unsigned char*),
+				     width,
+				     prec, 
+				     flags);
+		break;
+	    case 'd' :
+	    case 'i' : {
+		longest arg;
+		u_longest num;
+		int minusp = 0;
+
+		PARSE_INT_FORMAT(arg, ap, signed);
+
+		if (arg < 0) {
+		    minusp = 1;
+		    num = -arg;
+		} else
+		    num = arg;
+
+		len += append_number (state, num, 10, "0123456789",
+				      width, prec, flags, minusp);
+		break;
+	    }
+	    case 'u' : {
+		u_longest arg;
+
+		PARSE_INT_FORMAT(arg, ap, unsigned);
+
+		len += append_number (state, arg, 10, "0123456789",
+				      width, prec, flags, 0);
+		break;
+	    }
+	    case 'o' : {
+		u_longest arg;
+
+		PARSE_INT_FORMAT(arg, ap, unsigned);
+
+		len += append_number (state, arg, 010, "01234567",
+				      width, prec, flags, 0);
+		break;
+	    }
+	    case 'x' : {
+		u_longest arg;
+
+		PARSE_INT_FORMAT(arg, ap, unsigned);
+
+		len += append_number (state, arg, 0x10, "0123456789abcdef",
+				      width, prec, flags, 0);
+		break;
+	    }
+	    case 'X' :{
+		u_longest arg;
+
+		PARSE_INT_FORMAT(arg, ap, unsigned);
+
+		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
+				      width, prec, flags, 0);
+		break;
+	    }
+	    case 'p' : {
+		unsigned long arg = (unsigned long)va_arg(ap, void*);
+
+		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
+				      width, prec, flags, 0);
+		break;
+	    }
+	    case 'n' : {
+		int *arg = va_arg(ap, int*);
+		*arg = state->s - state->str;
+		break;
+	    }
+	    case '\0' :
+		--format;
+		/* FALLTHROUGH */
+	    case '%' :
+		(*state->append_char)(state, c);
+		++len;
+		break;
+	    default :
+		(*state->append_char)(state, '%');
+		(*state->append_char)(state, c);
+		len += 2;
+		break;
+	    }
+	} else {
+	    (*state->append_char) (state, c);
+	    ++len;
 	}
-      }
-
-      /* size */
-
-      if (c == 'h') {
-	short_flag = 1;
-	c = *format++;
-      } else if (c == 'l') {
-	long_flag = 1;
-	c = *format++;
-      }
-
-      switch (c) {
-      case 'c' :
-	if(append_char(state, va_arg(ap, int), width, flags))
-	  return -1;
-	break;
-      case 's' :
-	if (append_string(state,
-			  va_arg(ap, unsigned char*),
-			  width,
-			  prec, 
-			  flags))
-	  return -1;
-	break;
-      case 'd' :
-      case 'i' : {
-	long arg;
-	unsigned long num;
-	int minusp = 0;
-
-	PARSE_INT_FORMAT(arg, ap, signed);
-
-	if (arg < 0) {
-	  minusp = 1;
-	  num = -arg;
-	} else
-	  num = arg;
-
-	if (append_number (state, num, 10, "0123456789",
-			   width, prec, flags, minusp))
-	  return -1;
-	break;
-      }
-      case 'u' : {
-	unsigned long arg;
-
-	PARSE_INT_FORMAT(arg, ap, unsigned);
-
-	if (append_number (state, arg, 10, "0123456789",
-			   width, prec, flags, 0))
-	  return -1;
-	break;
-      }
-      case 'o' : {
-	unsigned long arg;
-
-	PARSE_INT_FORMAT(arg, ap, unsigned);
-
-	if (append_number (state, arg, 010, "01234567",
-			   width, prec, flags, 0))
-	  return -1;
-	break;
-      }
-      case 'x' : {
-	unsigned long arg;
-
-	PARSE_INT_FORMAT(arg, ap, unsigned);
-
-	if (append_number (state, arg, 0x10, "0123456789abcdef",
-			   width, prec, flags, 0))
-	  return -1;
-	break;
-      }
-      case 'X' :{
-	unsigned long arg;
-
-	PARSE_INT_FORMAT(arg, ap, unsigned);
-
-	if (append_number (state, arg, 0x10, "0123456789ABCDEF",
-			   width, prec, flags, 0))
-	  return -1;
-	break;
-      }
-      case 'p' : {
-	unsigned long arg = (unsigned long)va_arg(ap, void*);
-
-	if (append_number (state, arg, 0x10, "0123456789ABCDEF",
-			   width, prec, flags, 0))
-	  return -1;
-	break;
-      }
-      case 'n' : {
-	int *arg = va_arg(ap, int*);
-	*arg = state->s - state->str;
-	break;
-      }
-      case '\0' :
-	  --format;
-	  /* FALLTHROUGH */
-      case '%' :
-	if ((*state->append_char)(state, c))
-	  return -1;
-	break;
-      default :
-	if (   (*state->append_char)(state, '%')
-	    || (*state->append_char)(state, c))
-	  return -1;
-	break;
-      }
-    } else
-      if ((*state->append_char) (state, c))
-	return -1;
-  }
-  return 0;
+    }
+    return len;
 }
 
-#ifndef HAVE_SNPRINTF
-int
+#if !defined(HAVE_SNPRINTF)
+int 
 snprintf (char *str, size_t sz, const char *format, ...)
 {
-  va_list args;
-  int ret;
+    va_list args;
+    int ret;
 
-  va_start(args, format);
-  ret = vsnprintf (str, sz, format, args);
+    va_start(args, format);
+    ret = vsnprintf (str, sz, format, args);
+    va_end(args);
 
 #ifdef PARANOIA
-  {
-    int ret2;
-    char *tmp;
-
-    tmp = malloc (sz);
-    if (tmp == NULL)
-      abort ();
-
-    ret2 = vsprintf (tmp, format, args);
-    if (ret != ret2 || strcmp(str, tmp))
-      abort ();
-    free (tmp);
-  }
+    {
+	int ret2;
+	char *tmp;
+
+	tmp = malloc (sz);
+	if (tmp == NULL)
+	    abort ();
+
+	va_start(args, format);
+	ret2 = vsprintf (tmp, format, args);
+	va_end(args);
+	if (ret != ret2 || strcmp(str, tmp))
+	    abort ();
+	free (tmp);
+    }
 #endif
 
-  va_end(args);
-  return ret;
+    return ret;
 }
 #endif
 
-#ifndef HAVE_ASPRINTF
+#if !defined(HAVE_ASPRINTF)
 int
 asprintf (char **ret, const char *format, ...)
 {
-  va_list args;
-  int val;
+    va_list args;
+    int val;
 
-  va_start(args, format);
-  val = vasprintf (ret, format, args);
+    va_start(args, format);
+    val = vasprintf (ret, format, args);
+    va_end(args);
 
 #ifdef PARANOIA
-  {
-    int ret2;
-    char *tmp;
-    tmp = malloc (val + 1);
-    if (tmp == NULL)
-      abort ();
-
-    ret2 = vsprintf (tmp, format, args);
-    if (val != ret2 || strcmp(*ret, tmp))
-      abort ();
-    free (tmp);
-  }
+    {
+	int ret2;
+	char *tmp;
+	tmp = malloc (val + 1);
+	if (tmp == NULL)
+	    abort ();
+
+	va_start(args, format);
+	ret2 = vsprintf (tmp, format, args);
+	va_end(args);
+	if (val != ret2 || strcmp(*ret, tmp))
+	    abort ();
+	free (tmp);
+    }
 #endif
 
-  va_end(args);
-  return val;
+    return val;
 }
 #endif
 
-#ifndef HAVE_ASNPRINTF
+#if !defined(HAVE_ASNPRINTF)
 int
 asnprintf (char **ret, size_t max_sz, const char *format, ...)
 {
-  va_list args;
-  int val;
+    va_list args;
+    int val;
 
-  va_start(args, format);
-  val = vasnprintf (ret, max_sz, format, args);
+    va_start(args, format);
+    val = vasnprintf (ret, max_sz, format, args);
 
 #ifdef PARANOIA
-  {
-    int ret2;
-    char *tmp;
-    tmp = malloc (val + 1);
-    if (tmp == NULL)
-      abort ();
-
-    ret2 = vsprintf (tmp, format, args);
-    if (val != ret2 || strcmp(*ret, tmp))
-      abort ();
-    free (tmp);
-  }
+    {
+	int ret2;
+	char *tmp;
+	tmp = malloc (val + 1);
+	if (tmp == NULL)
+	    abort ();
+
+	ret2 = vsprintf (tmp, format, args);
+	if (val != ret2 || strcmp(*ret, tmp))
+	    abort ();
+	free (tmp);
+    }
 #endif
 
-  va_end(args);
-  return val;
+    va_end(args);
+    return val;
 }
 #endif
 
-#ifndef HAVE_VASPRINTF
+#if !defined(HAVE_VASPRINTF)
 int
 vasprintf (char **ret, const char *format, va_list args)
 {
-  return vasnprintf (ret, 0, format, args);
+    return vasnprintf (ret, 0, format, args);
 }
 #endif
 
 
-#ifndef HAVE_VASNPRINTF
+#if !defined(HAVE_VASNPRINTF)
 int
 vasnprintf (char **ret, size_t max_sz, const char *format, va_list args)
 {
-  int st;
-  size_t len;
-  struct state state;
-
-  state.max_sz = max_sz;
-  state.sz     = 1;
-  state.str    = malloc(state.sz);
-  if (state.str == NULL) {
-    *ret = NULL;
-    return -1;
-  }
-  state.s = state.str;
-  state.theend = state.s + state.sz - 1;
-  state.append_char = as_append_char;
-  state.reserve     = as_reserve;
-
-  st = xyzprintf (&state, format, args);
-  if (st) {
-    free (state.str);
-    *ret = NULL;
-    return -1;
-  } else {
-    char *tmp;
-
-    *state.s = '\0';
-    len = state.s - state.str;
-    tmp = realloc (state.str, len+1);
-    if (tmp == NULL) {
-      free (state.str);
-      *ret = NULL;
-      return -1;
+    int st;
+    struct snprintf_state state;
+
+    state.max_sz = max_sz;
+    state.sz     = 1;
+    state.str    = malloc(state.sz);
+    if (state.str == NULL) {
+	*ret = NULL;
+	return -1;
+    }
+    state.s = state.str;
+    state.theend = state.s + state.sz - 1;
+    state.append_char = as_append_char;
+
+    st = xyzprintf (&state, format, args);
+    if (st > (int)state.sz) {
+	free (state.str);
+	*ret = NULL;
+	return -1;
+    } else {
+	char *tmp;
+
+	*state.s = '\0';
+	tmp = realloc (state.str, st+1);
+	if (tmp == NULL) {
+	    free (state.str);
+	    *ret = NULL;
+	    return -1;
+	}
+	*ret = tmp;
+	return st;
     }
-    *ret = tmp;
-    return len;
-  }
 }
 #endif
 
-#ifndef HAVE_VSNPRINTF
+#if !defined(HAVE_VSNPRINTF)
 int
 vsnprintf (char *str, size_t sz, const char *format, va_list args)
 {
-  struct state state;
-  int ret;
-  unsigned char *ustr = (unsigned char *)str;
-
-  state.max_sz = 0;
-  state.sz     = sz;
-  state.str    = ustr;
-  state.s      = ustr;
-  state.theend = ustr + sz - 1;
-  state.append_char = sn_append_char;
-  state.reserve     = sn_reserve;
-
-  ret = xyzprintf (&state, format, args);
-  *state.s = '\0';
-  if (ret)
-    return sz;
-  else
-    return state.s - state.str;
+    struct snprintf_state state;
+    int ret;
+    unsigned char *ustr = (unsigned char *)str;
+
+    state.max_sz = 0;
+    state.sz     = sz;
+    state.str    = ustr;
+    state.s      = ustr;
+    state.theend = ustr + sz - (sz > 0);
+    state.append_char = sn_append_char;
+
+    ret = xyzprintf (&state, format, args);
+    if (state.s != NULL)
+	*state.s = '\0';
+    return ret;
 }
 #endif
+
diff --unified --recursive --text a/snmpb-1.0/libsmi/lib/util.c b/snmpb-1.0/libsmi/lib/util.c
--- snmpb-1.0/libsmi/lib/util.c	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/lib/util.c	2021-01-31 17:27:22.000000000 +0100
@@ -8,7 +8,7 @@
  * See the file "COPYING" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  *
- * @(#) $Id$
+ * @(#) $Id: util.c 1656 2009-12-28 17:56:12Z schoenw $
  */
 
 #include <config.h>
@@ -144,7 +144,7 @@
 
 int smiIsPath(const char *s)
 {
-    return (strchr(s, '.') || strchr(s, DIR_SEPARATOR));
+    return (/*strchr(s, '.') ||*/ strchr(s, DIR_SEPARATOR));
 }
 
 
diff --unified --recursive --text a/snmpb-1.0/libsmi/Makefile.am b/snmpb-1.0/libsmi/Makefile.am
--- snmpb-1.0/libsmi/Makefile.am	2023-04-12 01:51:59.961403712 +0200
+++ snmpb-1.0/libsmi/Makefile.am	2021-01-31 17:27:22.000000000 +0100
@@ -8,7 +8,7 @@
 # See the file "COPYING" for information on usage and redistribution
 # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 #
-# @(#) $Id$
+# @(#) $Id: Makefile.am 1820 2014-10-13 15:06:41Z schoenw $
 #
 
 AUTOMAKE_OPTIONS	= no-dependencies foreign
@@ -20,7 +20,7 @@
 			  win/Makefile.mingw win/README.mingw \
 			  smi.conf-example libsmi.m4 libsmi.pc
 
-SUBDIRS			= lib tools mibs pibs yang test doc
+SUBDIRS			= lib
 
 m4datadir		= $(datadir)/aclocal
 m4data_DATA		= libsmi.m4
diff --unified --recursive --text a/snmpb-1.0/libsmi/win/config.h b/snmpb-1.0/libsmi/win/config.h
--- snmpb-1.0/libsmi/win/config.h	2023-04-12 01:52:08.881420190 +0200
+++ snmpb-1.0/libsmi/win/config.h	2021-01-31 17:27:22.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * config.h.  Generated manually for windows / vc++ 6.0
  *
- * @(#) $Id$
+ * @(#) $Id: config.h.in 1736 2011-12-14 14:06:39Z schoenw $
  */
 
 /* Define if the SMIv1/v2 parser shall be active. */
@@ -11,7 +11,7 @@
 /* #define BACKEND_SMING */
 
 /* Define if the SMIng parser shall be active. */
-#define BACKEND_YANG
+/* #define BACKEND_YANG */
 
 /* The default error level at libsmi initialization. */
 #define DEFAULT_ERRORLEVEL 3
@@ -26,7 +26,7 @@
 #define DEFAULT_USERCONFIG ".smirc"
 
 /* The default search path to lookup SMI module files. */
-#define DEFAULT_SMIPATH "c:/smi/mibs/ietf;c:/smi/mibs/iana;c:/smi/mibs/irtf;c:/smi/mibs/site;c:/smi/mibs/tubs"
+#define DEFAULT_SMIPATH "mibs;pibs"
 
 /* The default path separator character. */
 #define PATH_SEPARATOR ';'
@@ -80,7 +80,10 @@
 #define HAVE_SNPRINTF 1
 
 /* Define if you have the vsnprintf function.  */
-#undef HAVE_VSNPRINTF
+#define HAVE_VSNPRINTF 1
+
+/* Supports long long 64 bits */
+#define HAVE_LONG_LONG 1
 
 /* Define if the win.h header file is present. */
 #define HAVE_WIN_H 1
diff --unified --recursive --text a/snmpb-1.0/libsmi/win/Makefile.mingw b/snmpb-1.0/libsmi/win/Makefile.mingw
--- snmpb-1.0/libsmi/win/Makefile.mingw	2023-04-12 01:51:59.998070446 +0200
+++ snmpb-1.0/libsmi/win/Makefile.mingw	2021-01-31 17:27:22.000000000 +0100
@@ -6,7 +6,7 @@
 # See the file "COPYING" for information on usage and redistribution
 # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 #
-# @(#) $Id$
+# @(#) $Id: Makefile.mingw 1736 2011-12-14 14:06:39Z schoenw $
 #
 
 ##
@@ -38,14 +38,19 @@
 # AR	= ar
 # MKDIR	= -mkdir
 
+# MART Disable implicit yacc rule
+%.c : %.y
+
 ##
 ## Debian Linux mingw cross-compiler version:
 ##
-CC	= i586-mingw32msvc-gcc
+CC	= gcc
 CP	= cp
 RM	= rm -f
-AR	= i586-mingw32msvc-ar
+AR	= ar
 MKDIR	= -mkdir
+FLEX = flex
+BISON = bison
 
 ##
 ## Definitions:
@@ -66,16 +71,17 @@
 	smi-check.o \
 	parser-smi.o \
 	scanner-smi.o \
-	parser-sming.o \
-	scanner-sming.o \
-	parser-yang.o \
-	scanner-yang.o \
-	yang.o \
-	yang-data.o \
-	yang-check.o \
-	yang-complex-types.o \
-	smi2yang.o \
 	snprintf.o
+#	parser-sming.o \
+#	scanner-sming.o \
+#	parser-yang.o \
+#	scanner-yang.o \
+#	yang.o \
+#	yang-data.o \
+#	yang-check.o \
+#	yang-complex-types.o \
+#	smi2yang.o \
+
 
 TOOLSOBJS = \
 	smiquery.o \
