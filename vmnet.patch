--- a/vmnet/Makefile
+++ b/vmnet/Makefile
@@ -43,7 +43,11 @@
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
@@ -137,7 +141,6 @@
 endif
 
 # Add Spectre options when available
-CC_OPTS += $(call vm_check_gcc,-mindirect-branch=thunk -mindirect-branch-register,)
 
 include $(SRCROOT)/Makefile.kernel
 
--- a/vmnet/bridge.c
+++ b/vmnet/bridge.c
@@ -26,6 +26,9 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 10)
+#include <net/gso.h>
+#endif
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/mm.h>
@@ -684,14 +684,11 @@
 	 }
          spin_unlock_irqrestore(&bridge->historyLock, flags);
 
-         /*
-          * We used to cli() before calling netif_rx() here. It was probably
-          * unneeded (as we never did it in netif.c, and the code worked). In
-          * any case, now that we are using netif_rx_ni(), we should certainly
-          * not do it, or netif_rx_ni() will deadlock on the cli() lock --hpreg
-          */
-
-	 netif_rx_ni(clone);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
+         netif_rx_ni(clone);
+#else
+         netif_rx(clone);
+#endif
 #	 if LOGLEVEL >= 4
 	 do_gettimeofday(&vnetTime);
 #	 endif
--- a/vmnet/driver.c
+++ b/vmnet/driver.c
@@ -279,7 +279,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * init_module --
+ * LinuxDriverInit --
  *
  *      linux module entry point. Called by /sbin/insmod command.
  *      Initializes module and Registers this driver for a
@@ -296,7 +296,7 @@
  */
 
 int
-init_module(void)
+LinuxDriverInit(void)
 {
    int retval;
 
@@ -358,7 +358,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * cleanup_module --
+ * LinuxDriverExit --
  *
  *      Called by /sbin/rmmod.  Unregisters this driver for a
  *      vnet major #, and deinitializes the modules.  The 64-bit
@@ -375,7 +375,7 @@
  */
 
 void
-cleanup_module(void)
+LinuxDriverExit(void)
 {
    unregister_chrdev(VNET_MAJOR_NUMBER, "vmnet");
    VNetProtoUnregister();
@@ -1701,3 +1701,5 @@
  * by default (i.e., neither mkinitrd nor modprobe will accept it).
  */
 MODULE_INFO(supported, "external");
+module_init(LinuxDriverInit);
+module_exit(LinuxDriverExit);
--- a/vmnet/netif.c
+++ b/vmnet/netif.c
@@ -253,7 +253,11 @@
 
    memset(&netIf->stats, 0, sizeof netIf->stats);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
    memcpy(dev->dev_addr, netIf->port.paddr, sizeof netIf->port.paddr);
+#else
+   eth_hw_addr_set(dev, netIf->port.paddr);
+#endif
 
    if (register_netdev(dev) != 0) {
       LOG(0, (KERN_NOTICE "%s: could not register network device\n",
@@ -345,7 +349,11 @@
    /* send to the host interface */
    skb->dev = netIf->dev;
    skb->protocol = eth_type_trans(skb, netIf->dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
    netif_rx_ni(skb);
+#else
+   netif_rx(skb);
+#endif
    netIf->stats.rx_packets++;
 
    return;
@@ -532,7 +540,11 @@
       return -EINVAL;
    }
    memcpy(netIf->port.paddr, addr->sa_data, dev->addr_len);
-   memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
+   memcpy(dev->dev_addr, netIf->port.paddr, dev->addr_len);
+#else
+   eth_hw_addr_set(dev, netIf->port.paddr);
+#endif
    return 0;
 }
 
--- a/vmnet/smac.c
+++ b/vmnet/smac.c
@@ -4116,7 +4116,7 @@
 
 void SMACINT
 SMAC_SetMac(SMACState *state,  // IN: state to update
-	    uint8 *mac)        // IN: pointer to host adapter's MAC
+	    const uint8 *mac)  // IN: pointer to host adapter's MAC
 {
    VNETKdPrintCall(("SMAC_SetMac"));
    ASSERT(state);
--- a/vmnet/smac.h
+++ b/vmnet/smac.h
@@ -72,7 +72,7 @@
 void SMACINT
 SMAC_InitState(struct SMACState **ptr);           // IN: state to alloc/init
 void SMACINT
-SMAC_SetMac(struct SMACState *state, uint8 *mac); // IN: state, and host MAC
+SMAC_SetMac(struct SMACState *state, const uint8 *mac); // IN: state, and host MAC
 void SMACINT
 SMAC_CleanupState(struct SMACState **ptr);        // IN: state to cleanup/dealloc
 
--- a/vmnet/userif.c
+++ b/vmnet/userif.c
@@ -520,6 +520,50 @@
 /*
  *----------------------------------------------------------------------
  *
+ * VNetCsumAndCopyToUser --
+ *
+ *      Checksum data and copy them to userspace.
+ *
+ * Results:
+ *      folded checksum (non-zero value) on success,
+ *      err set to 0 on success, negative errno on failure.
+ *
+ * Side effects:
+ *      Data copied to the buffer.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned int
+VNetCsumAndCopyToUser(const void *src,   // IN: Source
+                      void *dst,         // IN: Destination
+                      int len,           // IN: Bytes to copy
+                      int *err)          // OUT: Error code
+{
+   unsigned int csum;
+
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
+   csum = csum_and_copy_to_user(src, dst, len, 0, err);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 19, 0)
+   csum = csum_and_copy_to_user(src, dst, len);
+   *err = (csum == 0) ? -EFAULT : 0;
+#else
+   if (!user_access_begin(dst, len)) {
+      *err = -EFAULT;
+      csum = 0;
+   } else {
+      *err = 0;
+      csum = csum_partial_copy_nocheck(src, dst, len);
+      user_access_end();
+   }
+#endif
+   return csum;
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
  * VNetCsumCopyDatagram --
  *
  *      Copy part of datagram to userspace doing checksum at same time.
@@ -559,7 +559,7 @@
       return -EINVAL;
    }
 
-   csum = csum_and_copy_to_user(skb->data + offset, curr, len, 0, &err);
+   csum = VNetCsumAndCopyToUser(skb->data + offset, curr, len, &err);
    if (err) {
       return err;
    }
@@ -573,8 +578,8 @@
 	 const void *vaddr;
 
 	 vaddr = kmap(skb_frag_page(frag));
-	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
-					 curr, skb_frag_size(frag), 0, &err);
+         tmpCsum = VNetCsumAndCopyToUser(vaddr + skb_frag_off(frag),
+                                         curr, skb_frag_size(frag), &err);
 	 kunmap(skb_frag_page(frag));
 
 	 if (err) {
Fixing VMWare Player on Linux when using DHCP addresses: https://www.nikhef.nl/~janjust/vmnet/
@@ -985,6 +996,9 @@
    userIf = (VNetUserIF *)port->jack.private;
    hubJack = port->jack.peer;
 
+   /* never send link down events */
+   if (!linkUp) return 0;
+
    if (port->jack.state == FALSE || hubJack == NULL) {
       return -EINVAL;
    }
--- a/vmnet/vm_basic_defs.h
+++ b/vmnet/vm_basic_defs.h
@@ -50,7 +50,10 @@
  * References:
  *   C90 7.17, C99 7.19, C11 7.19
  */
-#if !defined(VMKERNEL)
+/* Use linux/stddef.h when building Linux kernel modules. */
+#ifdef KBUILD_MODNAME
+#  include <linux/stddef.h>
+#elif !defined(VMKERNEL)
 #  include <stddef.h>
 #else
    /*
--- a/vmnet/vnetEvent.c
+++ b/vmnet/vnetEvent.c
@@ -60,10 +60,12 @@
 
 struct VNetEvent_EventNode {
    VNetEvent_EventNode *nextEvent;
-   VNet_EventHeader event;
+   union {
+       VNet_EventHeader header;
+       VNet_LinkStateEvent lse;
+   } event;
 };
 
-#define EVENT_NODE_HEADER_SIZE offsetof(struct VNetEvent_EventNode, event)
 
 struct VNetEvent_Mechanism {
    VNetKernel_SpinLock lock;          /* mechanism lock */
@@ -369,6 +371,10 @@
       return VNetKernel_EINVAL;
    }
 
+   if (e->size > sizeof(p->event)) {
+      return VNetKernel_EINVAL;
+   }
+
    /* lock */
    VNetKernel_SpinLockAcquire(&m->lock);
    m->handlerTask = VNetKernel_ThreadCurrent();
@@ -378,22 +384,15 @@
    while (TRUE) {
        p = *q;
        if (p == NULL ||
-           (p->event.eventId == e->eventId && p->event.type == e->type)) {
+           (p->event.header.eventId == e->eventId && p->event.header.type == e->type)) {
                break;
            }
       q = &p->nextEvent;
    }
 
-   /* remove previously sent event */
-   if (p != NULL && p->event.size != e->size) {
-      *q = p->nextEvent;
-      VNetKernel_MemoryFree(p);
-      p = NULL;
-   }
-
    /* insert new event into event list*/
    if (p == NULL) {
-      p = VNetKernel_MemoryAllocate(EVENT_NODE_HEADER_SIZE + e->size);
+      p = VNetKernel_MemoryAllocate(sizeof(*p));
       if (p == NULL) {
          m->handlerTask = NULL;
          VNetKernel_SpinLockRelease(&m->lock);
@@ -485,8 +484,8 @@
    while (s != NULL) {
       e = s->firstEvent;
       while (e != NULL) {
-         if ((e->event.classSet & classMask) != 0) {
-            h(data, &e->event);
+         if ((e->event.header.classSet & classMask) != 0) {
+            h(data, &e->event.header);
          }
          e = e->nextEvent;
       }
--- a/vmnet/vnetUserListener.c
--- b/vmnet/vnetUserListener.c
@@ -42,10 +42,12 @@
 
 struct VNetUserListener_EventNode {
    VNetUserListener_EventNode *nextEvent;
-   VNet_EventHeader event;
+   union {
+       VNet_EventHeader header;
+       VNet_LinkStateEvent lse;
+   } event;
 };
 
-#define EVENT_NODE_HEADER_SIZE offsetof(struct VNetUserListener_EventNode, event)
 
 typedef struct VNetUserListener {
    VNetPort port;                          /* base port/jack */
@@ -220,7 +222,7 @@
    VNetUserListener_EventNode *t;
 
    /* allocate and initialize event node */
-   t = kmalloc(EVENT_NODE_HEADER_SIZE + e->size, GFP_ATOMIC);
+   t = kmalloc(sizeof *t, GFP_ATOMIC);
    if (t == NULL) {
       LOG(0, (KERN_DEBUG "VNetUserListenerEventHandler, out of memory\n"));
       return;
@@ -299,7 +301,7 @@
    spin_unlock(&userListener->lock);
 
    /* return data and free event */
-   n = t->event.size;
+   n = t->event.header.size;
    if (count < n) {
       n = count;
    }
From 2c6d66f3f1947384038b765c897b102ecdb18298 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 12 Jan 2024 08:30:33 +0100
Subject: [PATCH] modules: fix build with -Wmissing-prototypes

Mainline commit 0fcb70851fbf ("Makefile.extrawarn: turn on
missing-prototypes globally") in 6.8-rc1 enables -Wmissing-prototypes
globally, revealing a lot of unclean code and also some actual problems.
This is also the case in vmmon and vmnet modules.

Most of them are addressed by making functions used only within one file
static. The missing prototype of random_get_entropy_fallback() is handled
by including <linux/timex.h> rather than <asm/timex.h>.

Finally, there are four functions in vmnet module which are actually used
in multiple files but instead of proper declarations, their prototype is
duplicated in vmnet-only/driver.c, risking that the two copies won't match
(which actually happened in one case). The cleanest solution would be
creating separate header files for them (bridge.h, netif.h, userif.h and
vnetUserListener.h) and including them in the respective source file and
driver.c. As the developers already handle similar cases by simply putting
the declarations into vnetInt.h, let us do the same to keep things simple.
---
 vmmon-only/common/task.c  |  2 +-
 vmmon-only/common/vmx86.c |  6 +++---
 vmmon-only/linux/driver.c |  4 ++--
 vmmon-only/linux/hostif.c |  6 +++---
 vmnet-only/bridge.c       |  2 +-
 vmnet-only/driver.c       | 16 ++--------------
 vmnet-only/vnetInt.h      |  7 +++++++
 7 files changed, 19 insertions(+), 24 deletions(-)

diff --git a/vmnet-only/bridge.c b/vmnet-only/bridge.c
index b604a25d..4c139570 100644
--- a/vmnet-only/bridge.c
+++ b/vmnet-only/bridge.c
@@ -1405,7 +1405,7 @@ VNetBridgeComputeHeaderPos(struct sk_buff *skb) // IN: buffer to examine
  *----------------------------------------------------------------------
  */
 
-void
+static void
 VNetBridgeSendLargePacket(struct sk_buff *skb,        // IN: packet to split
                           VNetBridge *bridge)         // IN: bridge
 {
diff --git a/vmnet-only/driver.c b/vmnet-only/driver.c
index f314ff2e..fe5923d8 100644
--- a/vmnet-only/driver.c
+++ b/vmnet-only/driver.c
@@ -50,18 +50,6 @@
 
 #include "vmnetInt.h"
 
-/*
- * Initialization and creation routines from other files.
- * Putting them here reduces the need for so many header files.
- */
-
-extern int VNetUserIf_Create(VNetPort **ret);
-extern int VNetNetIf_Create(char *devName, VNetPort **ret, int hubNum);
-extern int VNetBridge_Create(char *devName, uint32 flags, VNetJack *hubJack,
-                             VNetPort **ret);
-extern int VNetUserListener_Create(uint32 classMask, VNetJack *hubJack, VNetPort **ret);
-
-
 /*
  *  Structure for cycle detection of host interfaces.  This
  *  struct is only used by VNetCycleDetectIf().
@@ -295,7 +283,7 @@ VNetRemovePortFromList(const VNetPort *port) // IN: port to remove from list
  *----------------------------------------------------------------------
  */
 
-int
+static int
 LinuxDriverInit(void)
 {
    int retval;
@@ -374,7 +362,7 @@ vmnet_init_module(void)
  *----------------------------------------------------------------------
  */
 
-void
+static void
 LinuxDriverExit(void)
 {
    unregister_chrdev(VNET_MAJOR_NUMBER, "vmnet");
diff --git a/vmnet-only/vnetInt.h b/vmnet-only/vnetInt.h
index f6a90a13..e76dcf5c 100644
--- a/vmnet-only/vnetInt.h
+++ b/vmnet-only/vnetInt.h
@@ -218,6 +218,13 @@ extern int VNetProc_Init(void);
 
 extern void VNetProc_Cleanup(void);
 
+int VNetNetIf_Create(char *devName, VNetPort **ret, int hubNum);
+int VNetUserIf_Create(VNetPort **ret);
+int VNetBridge_Create(const char *devName, uint32 flags, VNetJack *hubJack,
+		      VNetPort **ret);
+int VNetUserListener_Create(uint32 classMask, VNetJack *hubJack,
+			    VNetPort **port);
+
 
 /*
  *----------------------------------------------------------------------
