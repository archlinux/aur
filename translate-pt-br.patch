diff --git a/spectre-meltdown-checker.sh b/spectre-meltdown-checker.sh
index dc272f4..230bab7 100755
--- a/spectre-meltdown-checker.sh
+++ b/spectre-meltdown-checker.sh
@@ -15,7 +15,7 @@
 VERSION='0.46+'
 
 trap 'exit_cleanup' EXIT
-trap '_warn "interrupted, cleaning up..."; exit_cleanup; exit 1' INT
+trap '_warn "interrompido, limpando..."; exit_cleanup; exit 1' INT
 exit_cleanup()
 {
 	saved_ret=$?
@@ -45,70 +45,70 @@ show_usage()
 {
 	# shellcheck disable=SC2086
 	cat <<EOF
-	Usage:
-		Live mode (auto):   $(basename $0) [options]
-		Live mode (manual): $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]> --live
-		Offline mode:       $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]>
-
-	Modes:
-		Two modes are available.
-
-		First mode is the "live" mode (default), it does its best to find information about the currently running kernel.
-		To run under this mode, just start the script without any option (you can also use --live explicitly)
-
-		Second mode is the "offline" mode, where you can inspect a non-running kernel.
-		This mode is automatically enabled when you specify the location of the kernel file, config and System.map files:
-
-		--kernel kernel_file	specify a (possibly compressed) Linux or BSD kernel file
-		--config kernel_config	specify a kernel config file (Linux only)
-		--map kernel_map_file	specify a kernel System.map file (Linux only)
-
-		If you want to use live mode while specifying the location of the kernel, config or map file yourself,
-		you can add --live to the above options, to tell the script to run in live mode instead of the offline mode,
-		which is enabled by default when at least one file is specified on the command line.
-
-	Options:
-		--no-color		don't use color codes
-		--verbose, -v		increase verbosity level, possibly several times
-		--explain		produce an additional human-readable explanation of actions to take to mitigate a vulnerability
-		--paranoid		require IBPB to deem Variant 2 as mitigated
-					also require SMT disabled + unconditional L1D flush to deem Foreshadow-NG VMM as mitigated
-					also require SMT disabled to deem MDS vulnerabilities mitigated
-
-		--no-sysfs		don't use the /sys interface even if present [Linux]
-		--sysfs-only		only use the /sys interface, don't run our own checks [Linux]
-		--coreos		special mode for CoreOS (use an ephemeral toolbox to inspect kernel) [Linux]
-
-		--arch-prefix PREFIX	specify a prefix for cross-inspecting a kernel of a different arch, for example "aarch64-linux-gnu-",
-					so that invoked tools will be prefixed with this (i.e. aarch64-linux-gnu-objdump)
-		--batch text		produce machine readable output, this is the default if --batch is specified alone
-		--batch short		produce only one line with the vulnerabilities separated by spaces
-		--batch json		produce JSON output formatted for Puppet, Ansible, Chef...
-		--batch nrpe		produce machine readable output formatted for NRPE
-		--batch prometheus      produce output for consumption by prometheus-node-exporter
-
-		--variant VARIANT	specify which variant you'd like to check, by default all variants are checked.
-					can be used multiple times (e.g. --variant 3a --variant l1tf)
-					for a list of supported VARIANT parameters, use --variant help
-		--cve CVE		specify which CVE you'd like to check, by default all supported CVEs are checked
-					can be used multiple times (e.g. --cve CVE-2017-5753 --cve CVE-2020-0543)
-		--hw-only		only check for CPU information, don't check for any variant
-		--no-hw			skip CPU information and checks, if you're inspecting a kernel not to be run on this host
-		--vmm [auto,yes,no]	override the detection of the presence of a hypervisor, default: auto
-		--no-intel-db		don't use the builtin Intel DB of affected processors
-		--allow-msr-write	allow probing for write-only MSRs, this might produce kernel logs or be blocked by your system
-		--cpu [#,all]		interact with CPUID and MSR of CPU core number #, or all (default: CPU core 0)
-		--update-fwdb		update our local copy of the CPU microcodes versions database (using the awesome
-					MCExtractor project and the Intel firmwares GitHub repository)
-		--update-builtin-fwdb	same as --update-fwdb but update builtin DB inside the script itself
-		--dump-mock-data	used to mimick a CPU on an other system, mainly used to help debugging this script
-
-	Return codes:
-		0 (not vulnerable), 2 (vulnerable), 3 (unknown), 255 (error)
-
-	IMPORTANT:
-	A false sense of security is worse than no security at all.
-	Please use the --disclaimer option to understand exactly what this script does.
+	Uso:
+		Modo ao vivo (automático):   $(basename $0) [options]
+		Modo ao vivo (manual): $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]> --live
+		Modo offline:       $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]>
+
+	Modos:
+		Dois modos estão disponíveis.
+
+		O primeiro modo é o modo "ao vivo" (padrão); ele faz o possível para encontrar informações sobre o kernel atualmente em execução.
+		Para executar neste modo, basta iniciar o script sem nenhuma opção (você também pode usar --live explicitamente)
+
+		O segundo modo é o modo "offline", onde você pode inspecionar um kernel não executando.
+		Este modo é ativado automaticamente quando você especifica o local dos arquivos kernel, config e System.map:
+
+		--kernel kernel_file	especifique um arquivo de kernel Linux ou BSD (possivelmente compactado)
+		--config kernel_config	especifique um arquivo de configuração do kernel (somente Linux)
+		--map kernel_map_file	especifique um arquivo System.map do kernel (somente Linux)
+
+		Se você quiser usar o modo ao vivo enquanto especifica o local do kernel, configuração ou arquivo de mapeamento,
+		você pode adicionar --live às opções acima, para dizer ao script para executar no modo ao vivo, em vez do modo offline,
+		que é ativado por padrão quando pelo menos um arquivo é especificado na linha de comando.
+
+	Opções:
+		--no-color		não use códigos de cores
+		--verbose, -v		aumentar o nível de verbosidade, possivelmente várias vezes
+		--explain		produzir uma explicação legível adicional de ações a serem tomadas para mitigar a vulnerabilidade
+		--paranoid		exigir que o IBPB considere a variante 2 como atenuada
+					também exigem SMT desativado  liberação L1D incondicional para considerar o Foreshadow-NG VMM como atenuado
+					também exigem que o SMT desativado considere vulnerabilidades do MDS atenuadas
+
+		--no-sysfs		não use a interface /sys mesmo se presente [Linux]
+		--sysfs-only		use apenas a interface /sys, não execute nossas próprias verificações [Linux]
+		--coreos		modo especial para CoreOS (use uma caixa de ferramentas efêmera para inspecionar o kernel) [Linux]
+
+		--arch-prefix PREFIX	especifique um prefixo para a inspeção cruzada de um kernel de um arco diferente, por exemplo "aarch64-linux-gnu-",
+					para que ferramentas invocadas sejam prefixadas com este (i.e. aarch64-linux-gnu-objdump)
+		--batch text		produzir saída legível por máquina, esse é o padrão se --batch for especificado sozinho
+		--batch short		produzir apenas uma linha com as vulnerabilidades separadas por espaços
+		--batch json		produzir saída JSON formatada para Puppet, Ansible, Chef...
+		--batch nrpe		produzir saída legível por máquina formatada para NRPE
+		--batch prometheus		produzir saída para consumo por prometheus-node-exporter
+
+		--variant VARIANT	especifique qual variante você gostaria de verificar, por padrão, todas as variantes são verificadas.
+					pode ser usado várias vezes (por exemplo, --variant 3a --variant l1tf)
+					para obter uma lista de parâmetros VARIANT suportados, use --variant help
+		--cve CVE		especifique qual CVE você gostaria de verificar, por padrão, todos os CVEs suportados são verificados
+					pode ser usado várias vezes (por exemplo, --cve CVE-2017-5753 --cve CVE-2020-0543)
+		--hw-only		verifique apenas as informações da CPU, não verifique nenhuma variante
+		--no-hw			pule as informações e verificações da CPU, se você estiver inspecionando um kernel para não ser executado neste host
+		--vmm [auto,yes,no]	substituir a detecção da presença de um hypervisor, padrão: auto
+		--no-intel-db		não use o banco de dados Intel integrado dos processadores afetados
+		--allow-msr-write	permitir a sondagem de MSRs somente gravação, isso pode produzir logs do kernel ou ser bloqueado pelo seu sistema
+		--cpu [#,all]		interagir com CPUID e MSR do número do núcleo da CPU #, ou todos (padrão: núcleo da CPU 0)
+		--update-fwdb		atualize nossa cópia local do banco de dados de versões de microcódigos da CPU (usando o incrível
+					Projeto MCExtractor e o repositório GitHub dos firmwares Intel)
+		--update-builtin-fwdb	o mesmo que --update-fwdb, mas atualize o banco de dados interno dentro do próprio script
+		--dump-mock-data	usado para imitar uma CPU em outro sistema, usado principalmente para ajudar na depuração desse script
+
+	Códigos de retorno:
+		0 (não vulnerável), 2 (vulnerável), 3 (desconhecido), 255 (erro)
+
+	IMPORTANTE:
+	Uma falsa sensação de segurança é pior do que nenhuma segurança.
+	Por favor, use a opção --disclaimer para entender exatamente o que esse script faz.
 
 EOF
 }
@@ -116,32 +116,32 @@ EOF
 show_disclaimer()
 {
 	cat <<EOF
-Disclaimer:
+Isenção de responsabilidade:
 
-This tool does its best to determine whether your system is immune (or has proper mitigations in place) for the
-collectively named "transient execution" (aka "speculative execution") vulnerabilities that started to appear
-since early 2018 with the infamous Spectre & Meltdown.
+Esta ferramenta faz o possível para determinar se o seu sistema é imune (ou se possui mitigações adequadas) para o
+vulnerabilidades coletivamente chamadas de "execução transitória" (também conhecidas como "execução especulativa") que começaram a aparecer
+desde o início de 2018 com o famigerado Specter & Meltdown.
 
-This tool does NOT attempt to run any kind of exploit, and can't 100% guarantee that your system is secure,
-but rather helps you verifying whether your system has the known correct mitigations in place.
-However, some mitigations could also exist in your kernel that this script doesn't know (yet) how to detect, or it might
-falsely detect mitigations that in the end don't work as expected (for example, on backported or modified kernels).
+Esta ferramenta NÃO tenta executar qualquer tipo de exploração e não pode garantir 100% que seu sistema seja seguro,
+mas ajuda a verificar se o seu sistema possui as mitigações corretas conhecidas.
+No entanto, algumas mitigações também podem existir em seu kernel que este script não sabe (ainda) como detectar, ou pode
+detecta falsamente mitigações que, no final, não funcionam como esperado (por exemplo, em kernels modificados ou com backport).
 
-Your system affectability to a given vulnerability depends on your CPU model and CPU microcode version, whereas the
-mitigations in place depend on your CPU (model and microcode), your kernel version, and both the runtime configuration
-of your CPU (through bits set through the MSRs) and your kernel. The script attempts to explain everything for each
-vulnerability, so you know where your system stands. For a given vulnerability, detailed information is sometimes
-available using the \`--explain\` switch.
+A afetabilidade do sistema a uma determinada vulnerabilidade depende do modelo da CPU e da versão do microcódigo da CPU, enquanto o
+mitigações em vigor dependem de sua CPU (modelo e microcódigo), sua versão do kernel e a configuração de tempo de execução
+de sua CPU (através de bits definidos pelos MSRs) e seu kernel. O script tenta explicar tudo para cada
+vulnerabilidade, para que você saiba onde está o seu sistema. Para uma determinada vulnerabilidade, informações detalhadas às vezes são
+disponível usando a opção \`--explain\`.
 
-Please also note that for the Spectre-like vulnerabilities, all software can possibly be exploited, in which case
-this tool only verifies that the kernel (which is the core of the system) you're using has the proper protections
-in place. Verifying all the other software is out of the scope of this tool, as it can't be done in a simple way.
-As a general measure, ensure you always have the most up to date stable versions of all the software you use,
-especially for those who are exposed to the world, such as network daemons and browsers.
+Observe também que, para as vulnerabilidades do tipo Spectre, todos os softwares podem ser explorados, caso em que
+esta ferramenta apenas verifica se o kernel (que é o núcleo do sistema) que você está usando possui as proteções adequadas
+no lugar. A verificação de todos os outros softwares está fora do escopo desta ferramenta, pois não pode ser feita de maneira simples.
+Como medida geral, certifique-se de ter sempre as versões estáveis mais atualizadas de todos os softwares que você usa,
+especialmente para aqueles que estão expostos ao mundo, como daemons de rede e navegadores.
 
-For more information and answers to related questions, please refer to the FAQ.md file.
+Para obter mais informações e respostas a perguntas relacionadas, consulte o arquivo FAQ.md.
 
-This tool has been released in the hope that it'll be useful, but don't use it to jump to conclusions about your security.
+Esta ferramenta foi lançada na esperança de que seja útil, mas não a use para tirar conclusões precipitadas sobre sua segurança.
 
 EOF
 }
@@ -299,33 +299,33 @@ explain()
 {
 	if [ "$opt_explain" = 1 ] ; then
 		_info ''
-		_info "> \033[41m\033[30mHow to fix:\033[0m $*"
+		_info "> \033[41m\033[30mComo corrigir:\033[0m $*"
 	fi
 }
 
 cve2name()
 {
 	case "$1" in
-		CVE-2017-5753)	echo "Spectre Variant 1, bounds check bypass";;
-		CVE-2017-5715)	echo "Spectre Variant 2, branch target injection";;
-		CVE-2017-5754)	echo "Variant 3, Meltdown, rogue data cache load";;
-		CVE-2018-3640)	echo "Variant 3a, rogue system register read";;
-		CVE-2018-3639)	echo "Variant 4, speculative store bypass";;
-		CVE-2018-3615)	echo "Foreshadow (SGX), L1 terminal fault";;
-		CVE-2018-3620)	echo "Foreshadow-NG (OS), L1 terminal fault";;
-		CVE-2018-3646)	echo "Foreshadow-NG (VMM), L1 terminal fault";;
-		CVE-2018-12126) echo "Fallout, microarchitectural store buffer data sampling (MSBDS)";;
-		CVE-2018-12130) echo "ZombieLoad, microarchitectural fill buffer data sampling (MFBDS)";;
-		CVE-2018-12127) echo "RIDL, microarchitectural load port data sampling (MLPDS)";;
-		CVE-2019-11091) echo "RIDL, microarchitectural data sampling uncacheable memory (MDSUM)";;
-		CVE-2019-11135) echo "ZombieLoad V2, TSX Asynchronous Abort (TAA)";;
-		CVE-2018-12207) echo "No eXcuses, iTLB Multihit, machine check exception on page size changes (MCEPSC)";;
-		CVE-2020-0543) echo "Special Register Buffer Data Sampling (SRBDS)";;
-		CVE-2023-20593) echo "Zenbleed, cross-process information leak";;
-		CVE-2022-40982) echo "Downfall, gather data sampling (GDS)";;
-		CVE-2023-20569) echo "Inception, return address security (RAS)";;
-		CVE-2023-23583) echo "Reptar, redundant prefix issue";;
-		*) echo "$0: error: invalid CVE '$1' passed to cve2name()" >&2; exit 255;;
+		CVE-2017-5753)	echo "Spectre Variante 1, desvio de verificação de limites";;
+		CVE-2017-5715)	echo "Spectre Variante 2, injeção no alvo do ramo";;
+		CVE-2017-5754)	echo "Variante 3, Meltdown, carregamento de cache de dados não autorizado";;
+		CVE-2018-3640)	echo "Variante 3a, leitura de registro de sistema não autorizado";;
+		CVE-2018-3639)	echo "Variante 4, derivação especulativa de armazenamento";;
+		CVE-2018-3615)	echo "Foreshadow (SGX), falha no terminal L1";;
+		CVE-2018-3620)	echo "Foreshadow-NG (OS), falha do terminal L1";;
+		CVE-2018-3646)	echo "Foreshadow-NG (VMM), falha do terminal L1";;
+		CVE-2018-12126) echo "Fallout, amostragem de dados de buffer de microarquitetura arquitetônica (MSBDS)";;
+		CVE-2018-12130) echo "ZombieLoad, amostragem de dados de buffer de microarquitetura arquitetônica (MFBDS)";;
+		CVE-2018-12127) echo "RIDL, amostragem de dados de portas de carga microarquiteturais (MLPDS)";;
+		CVE-2019-11091) echo "RIDL, memória incachável de amostragem de dados da microarquitetura (MDSUM)";;
+		CVE-2019-11135) echo "ZombieLoad V2, TSX Abortamento assíncrono (TAA)";;
+		CVE-2018-12207) echo "Sem exceções de eXcuses, iTLB Multihit, verificação de máquina nas alterações de tamanho de página (MCEPSC)";;
+		CVE-2020-0543) echo "Amostragem de dados de buffer de registro especial (SRBDS)";;
+		CVE-2023-20593) echo "Zenbleed, vazamento de informações entre processos";;
+		CVE-2022-40982) echo "Downfall, coleta de amostragem de dados (GDS)";;
+		CVE-2023-20569) echo "Começo, segurança de endereço de retorno (RAS)";;
+		CVE-2023-23583) echo "Reptar, problema de prefixo redundante";;
+		*) echo "$0: erro: CVE inválido '$1' passado para cve2name()" >&2; exit 255;;
 	esac
 }
 
@@ -353,7 +353,7 @@ _is_cpu_affected_cached()
 		CVE-2022-40982) return $variant_downfall;;
 		CVE-2023-20569) return $variant_inception;;
 		CVE-2023-23583) return $variant_reptar;;
-		*) echo "$0: error: invalid variant '$1' passed to is_cpu_affected()" >&2; exit 255;;
+		*) echo "$0: erro: variante inválida '$1' passada para is_cpu_affected()" >&2; exit 255;;
 	esac
 }
 
@@ -369,17 +369,17 @@ is_cpu_affected()
 	if is_intel; then
 		cpuid_hex=$(printf "0x%08X" $(( cpu_cpuid )) )
 		if [ "${intel_line:-}" = "no" ]; then
-			_debug "is_cpu_affected: $cpuid_hex not in Intel database (cached)"
+			_debug "is_cpu_affected:$cpuid_hex não está no banco de dados Intel (em cache)"
 		elif [ -z "$intel_line" ]; then
 			intel_line=$(read_inteldb | grep -F "$cpuid_hex," | head -n1)
 			if [ -z "$intel_line" ]; then
 				intel_line=no
-				_debug "is_cpu_affected: $cpuid_hex not in Intel database"
+				_debug "is_cpu_affected: $cpuid_hex não está no banco de dados Intel"
 			fi
 		fi
 		if [ "$intel_line" != "no" ]; then
 			_result=$(echo "$intel_line" | grep -Eo ,"$(echo "$1" | cut -c5-)"'=[^,]+' | cut -d= -f2)
-			_debug "is_cpu_affected: inteldb for $1 says '$_result'"
+			_debug "is_cpu_affected: inteldb para $1 diz '$_result'"
 
 			# handle special case for Foreshadow SGX (CVE-2018-3615):
 			# even if we are affected to L1TF (CVE-2018-3620/CVE-2018-3646), if there's no SGX on our CPU,
@@ -432,17 +432,17 @@ is_cpu_affected()
 		[ -z "$variant_mfbds" ] && variant_mfbds=immune
 		[ -z "$variant_mlpds" ] && variant_mlpds=immune
 		[ -z "$variant_mdsum" ] && variant_mdsum=immune
-		_debug "is_cpu_affected: cpu not affected by Microarchitectural Data Sampling"
+		_debug "is_cpu_affected: CPU não afetada pela Amostragem de Dados Microarquiteturais"
 	fi
 
 	if is_cpu_taa_free; then
 		[ -z "$variant_taa" ] && variant_taa=immune
-		_debug "is_cpu_affected: cpu not affected by TSX Asynhronous Abort"
+		_debug "is_cpu_affected: CPU não afetada pelo TSX Asynhronous Abort"
 	fi
 
 	if is_cpu_srbds_free; then
 		[ -z "$variant_srbds" ] && variant_srbds=immune
-		_debug "is_cpu_affected: cpu not affected by Special Register Buffer Data Sampling"
+		_debug "is_cpu_affected: cpu não afetado pela Amostragem de dados de buffer de registro especial"
 	fi
 
 	if is_cpu_specex_free; then
@@ -474,23 +474,23 @@ is_cpu_affected()
 			# this var is set in check_cpu()
 			[ -z "$variant3" ]    && variant3=immune
 			[ -z "$variantl1tf" ] && variantl1tf=immune
-			_debug "is_cpu_affected: RDCL_NO is set so not vuln to meltdown nor l1tf"
+			_debug "is_cpu_affected: RDCL_NO está definido para que não seja vuln para meltdown nem l1tf"
 		fi
 		if [ "$capabilities_ssb_no" = 1 ]; then
 			# capability bit for future Intel processor that will explicitly state
 			# that they're not affected to Variant 4
 			# this var is set in check_cpu()
 			[ -z "$variant4" ] && variant4=immune
-			_debug "is_cpu_affected: SSB_NO is set so not vuln to variant4"
+			_debug "is_cpu_affected: SSB_NO está definido para não ser vuln para variant4"
 		fi
 		if is_cpu_ssb_free; then
 			[ -z "$variant4" ] && variant4=immune
-			_debug "is_cpu_affected: cpu not affected by speculative store bypass so not vuln to variant4"
+			_debug "is_cpu_affected: CPU não afetada pelo desvio de armazenamento especulativo, portanto, não está relacionada à variante4"
 		fi
 		# variant 3a
 		if [ "$cpu_family" = 6 ]; then
 			if [ "$cpu_model" = "$INTEL_FAM6_XEON_PHI_KNL" ] || [ "$cpu_model" = "$INTEL_FAM6_XEON_PHI_KNM" ]; then
-				_debug "is_cpu_affected: xeon phi immune to variant 3a"
+				_debug "is_cpu_affected: xeon phi imune à variante 3a"
 				[ -z "$variant3a" ] && variant3a=immune
 			elif [ "$cpu_model" = "$INTEL_FAM6_ATOM_SILVERMONT" ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_ATOM_SILVERMONT_MID" ] || \
@@ -499,7 +499,7 @@ is_cpu_affected()
 					# https://github.com/speed47/spectre-meltdown-checker/issues/310
 					# => silvermont CPUs (aka cherry lake for tablets and brawsell for mobile/desktop) don't seem to be affected
 					# => goldmont ARE affected
-					_debug "is_cpu_affected: silvermont immune to variant 3a"
+					_debug "is_cpu_affected: silvermont imune à variante 3a"
 					[ -z "$variant3a" ] && variant3a=immune
 			fi
 		fi
@@ -523,14 +523,14 @@ is_cpu_affected()
 				[ "$cpu_model" = "$INTEL_FAM6_XEON_PHI_KNL"     ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_XEON_PHI_KNM" ]; then
 
-				_debug "is_cpu_affected: intel family 6 but model known to be immune to l1tf"
+				_debug "is_cpu_affected: família intel 6, mas modelo conhecido por ser imune a l1tf"
 				[ -z "$variantl1tf" ] && variantl1tf=immune
 			else
-				_debug "is_cpu_affected: intel family 6 is vuln to l1tf"
+				_debug "is_cpu_affected: família intel 6 é vuln para l1tf"
 				variantl1tf=vuln
 			fi
 		elif [ "$cpu_family" -lt 6 ]; then
-			_debug "is_cpu_affected: intel family < 6 is immune to l1tf"
+			_debug "is_cpu_affected: família intel < 6 é imune a l1tf"
 			[ -z "$variantl1tf" ] && variantl1tf=immune
 		fi
 		# Downfall
@@ -538,7 +538,7 @@ is_cpu_affected()
 			# capability bit for future Intel processors that will explicitly state
 			# that they're unaffected by GDS. Also set by hypervisors on virtual CPUs
 			# so that the guest kernel doesn't try to mitigate GDS when it's already mitigated on the host
-			_debug "is_cpu_affected: downfall: not affected (GDS_NO)"
+			_debug "is_cpu_affected: downfall: não afetado (GDS_NO)"
 		elif [ "$cpu_family" = 6 ]; then
 			# list from https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64094e7e3118aff4b0be8ff713c242303e139834
 			set -u
@@ -553,14 +553,14 @@ is_cpu_affected()
 				[ "$cpu_model" = "$INTEL_FAM6_TIGERLAKE_L" ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_TIGERLAKE" ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_ROCKETLAKE" ]; then
-				_debug "is_cpu_affected: downfall: affected"
+				_debug "is_cpu_affected: downfall: afetado"
 				variant_downfall=vuln
 			elif [ "$has_avx2" = 0 ] && [ "$has_avx512" = 0 ]; then
-				_debug "is_cpu_affected: downfall: no avx; immune"
+				_debug "is_cpu_affected: downfall: sem avx; imune"
 			else
 				# old Intel CPU (not in their DB), not listed as being affected by the Linux kernel,
 				# but with AVX2 or AVX512: unclear for now
-				_debug "is_cpu_affected: downfall: unclear, defaulting to non-affected for now"
+				_debug "is_cpu_affected: downfall: obscuro, padrão para não afetado por enquanto"
 			fi
 			set +u
 		fi
@@ -630,7 +630,7 @@ is_cpu_affected()
 		[ -z "$variant3a" ] && variant3a=immune
 		if is_cpu_ssb_free; then
 			[ -z "$variant4" ] && variant4=immune
-			_debug "is_cpu_affected: cpu not affected by speculative store bypass so not vuln to variant4"
+			_debug "is_cpu_affected: CPU não afetada pelo desvio de armazenamento especulativo, portanto, não está relacionada à variante4"
 		fi
 		variantl1tf=immune
 
@@ -664,7 +664,7 @@ is_cpu_affected()
 			# do NOT quote $cpu_arch_list below
 			# shellcheck disable=SC2086
 			cpuarch=$(echo $cpu_arch_list | awk '{ print $'$i' }')
-			_debug "checking cpu$i: <$cpupart> <$cpuarch>"
+			_debug "checando a cpu$i: <$cpupart> <$cpuarch>"
 			# some kernels report AArch64 instead of 8
 			[ "$cpuarch" = "AArch64" ] && cpuarch=8
 			if [ -n "$cpupart" ] && [ -n "$cpuarch" ]; then
@@ -687,66 +687,66 @@ is_cpu_affected()
 					[ -z "$variant3" ] && variant3=immune
 					[ -z "$variant3a" ] && variant3a=immune
 					[ -z "$variant4" ] && variant4=immune
-					_debug "checking cpu$i: armv7 A8/A9/A12/A17 non affected to variants 3, 3a & 4"
+					_debug "checando a cpu$i: armv7 A8/A9/A12/A17 não afetado às variantes 3, 3a e 4"
 				elif [ "$cpuarch" = 7 ] && echo "$cpupart" | grep -q -w -e 0xc0f; then
 					variant1=vuln
 					variant2=vuln
 					[ -z "$variant3" ] && variant3=immune
 					variant3a=vuln
 					[ -z "$variant4" ] && variant4=immune
-					_debug "checking cpu$i: armv7 A15 non affected to variants 3 & 4"
+					_debug "checando a cpu$i: armv7 A15 não afetado às variantes 3 e 4"
 				elif [ "$cpuarch" = 8 ] && echo "$cpupart" | grep -q -w -e 0xd07 -e 0xd08; then
 					variant1=vuln
 					variant2=vuln
 					[ -z "$variant3" ] && variant3=immune
 					variant3a=vuln
 					variant4=vuln
-					_debug "checking cpu$i: armv8 A57/A72 non affected to variants 3"
+					_debug "checando a cpu$i: armv8 A57/A72 não afetado a variantes 3"
 				elif [ "$cpuarch" = 8 ] && echo "$cpupart" | grep -q -w -e 0xd09; then
 					variant1=vuln
 					variant2=vuln
 					[ -z "$variant3" ] && variant3=immune
 					[ -z "$variant3a" ] && variant3a=immune
 					variant4=vuln
-					_debug "checking cpu$i: armv8 A73 non affected to variants 3 & 3a"
+					_debug "checando a cpu$i: armv8 A73 não afetado às variantes 3 e 3a"
 				elif [ "$cpuarch" = 8 ] && echo "$cpupart" | grep -q -w -e 0xd0a; then
 					variant1=vuln
 					variant2=vuln
 					variant3=vuln
 					[ -z "$variant3a" ] && variant3a=immune
 					variant4=vuln
-					_debug "checking cpu$i: armv8 A75 non affected to variant 3a"
+					_debug "checando a cpu$i: armv8 A75 não afetado à variante 3a"
 				elif [ "$cpuarch" = 8 ] && echo "$cpupart" | grep -q -w -e 0xd0b -e 0xd0c -e 0xd0d; then
 					variant1=vuln
 					[ -z "$variant2" ] && variant2=immune
 					[ -z "$variant3" ] && variant3=immune
 					[ -z "$variant3a" ] && variant3a=immune
 					variant4=vuln
-					_debug "checking cpu$i: armv8 A76/A77/NeoverseN1 non affected to variant 2, 3 & 3a"
+					_debug "checando a cpu$i: armv8 A76/A77/NeoverseN1 não afetado às variantes 2, 3 e 3a"
 				elif [ "$cpuarch" = 8 ] && echo "$cpupart" | grep -q -w -e 0xd40 -e 0xd49 -e 0xd4f; then
 					variant1=vuln
 					[ -z "$variant2" ] && variant2=immune
 					[ -z "$variant3" ] && variant3=immune
 					[ -z "$variant3a" ] && variant3a=immune
 					[ -z "$variant4" ] && variant4=immune
-					_debug "checking cpu$i: armv8 NeoverseN2/V1/V2 non affected to variant 2, 3, 3a & 4"
+					_debug "checando cpu$i: armv8 NeoverseN2/V1/V2 não afetado pela variante 2, 3, 3a e 4"
 				elif [ "$cpuarch" -le 7 ] || { [ "$cpuarch" = 8 ] && [ $(( cpupart )) -lt $(( 0xd07 )) ]; } ; then
 					[ -z "$variant1" ] && variant1=immune
 					[ -z "$variant2" ] && variant2=immune
 					[ -z "$variant3" ] && variant3=immune
 					[ -z "$variant3a" ] && variant3a=immune
 					[ -z "$variant4" ] && variant4=immune
-					_debug "checking cpu$i: arm arch$cpuarch, all immune (v7 or v8 and model < 0xd07)"
+					_debug "checando a cpu$i: arm arch$cpuarch, todos imunes (v7 ou v8 e modelo < 0xd07)"
 				else
 					variant1=vuln
 					variant2=vuln
 					variant3=vuln
 					variant3a=vuln
 					variant4=vuln
-					_debug "checking cpu$i: arm unknown arch$cpuarch part$cpupart, considering vuln"
+					_debug "checando a cpu$i: arm desconhecido arch$cpuarch part$cpupart, considerando vuln"
 				fi
 			fi
-			_debug "is_cpu_affected: for cpu$i and so far, we have <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4>"
+			_debug "is_cpu_affected: para cpu$i e até agora, temos <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4>"
 		done
 		variantl1tf=immune
 	fi
@@ -770,22 +770,22 @@ is_cpu_affected()
 				[ "$cpu_model" = "$INTEL_FAM6_ATOM_GOLDMONT" ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_ATOM_GOLDMONT_D" ] || \
 				[ "$cpu_model" = "$INTEL_FAM6_ATOM_GOLDMONT_PLUS" ]; then
-				_debug "is_cpu_affected: intel family 6 but model known to be immune to itlbmh"
+				_debug "is_cpu_affected: família intel 6, mas modelo conhecido por ser imune a itlbmh"
 				[ -z "$variant_itlbmh" ] && variant_itlbmh=immune
 			else
-				_debug "is_cpu_affected: intel family 6 is vuln to itlbmh"
+				_debug "is_cpu_affected: família intel 6 é vulnerável a itlbmh"
 				variant_itlbmh=vuln
 			fi
 		elif [ "$cpu_family" -lt 6 ]; then
-			_debug "is_cpu_affected: intel family < 6 is immune to itlbmh"
+			_debug "is_cpu_affected: família intel < 6 é imune a itlbmh"
 			[ -z "$variant_itlbmh" ] && variant_itlbmh=immune
 		fi
 	else
-		_debug "is_cpu_affected: non-intel not affected to itlbmh"
+		_debug "is_cpu_affected: não-intel não afetado para itlbmh"
 		[ -z "$variant_itlbmh" ] && variant_itlbmh=immune
 	fi
 
-	_debug "is_cpu_affected: temp results are <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf>"
+	_debug "is_cpu_affected: resultados temporários são <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf>"
 	[ "$variant1"          = "immune" ] && variant1=1       || variant1=0
 	[ "$variant2"          = "immune" ] && variant2=1       || variant2=0
 	[ "$variant3"          = "immune" ] && variant3=1       || variant3=0
@@ -806,7 +806,7 @@ is_cpu_affected()
 	variantl1tf_sgx="$variantl1tf"
 	# even if we are affected to L1TF, if there's no SGX, we're not affected to the original foreshadow
 	[ "$cpuid_sgx" = 0 ] && variantl1tf_sgx=1
-	_debug "is_cpu_affected: final results are <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf> <$variantl1tf_sgx>"
+	_debug "is_cpu_affected: resultados finais são <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf> <$variantl1tf_sgx>"
 	is_cpu_affected_cached=1
 	_is_cpu_affected_cached "$1"
 	return $?
@@ -1021,7 +1021,7 @@ is_cpu_ssb_free()
 
 show_header()
 {
-	_info "Spectre and Meltdown mitigation detection tool v$VERSION"
+	_info "Ferramenta de detecção de mitigação Spectre e Meltdown v$VERSION"
 	_info
 }
 
@@ -1059,13 +1059,13 @@ download_file()
 	elif command -v fetch >/dev/null 2>&1; then
 		fetch -q "$_url" -o "$_file"; ret=$?
 	else
-		echo ERROR "please install one of \`wget\`, \`curl\` of \`fetch\` programs"
+		echo ERROR "instale um dos programas \`wget\`, \`curl\` de \`fetch\`"
 		unset _file _url
 		return 1
 	fi
 	unset _file _url
 	if [ "$ret" != 0 ]; then
-		echo ERROR "error $ret"
+		echo ERROR "erro $ret"
 		return $ret
 	fi
 	echo DONE
@@ -1086,25 +1086,25 @@ update_fwdb()
 	# first, download the MCE.db from the excellent platomav's MCExtractor project
 	mcedb_tmp="$(mktemp -t smc-mcedb-XXXXXX)"
 	mcedb_url='https://github.com/platomav/MCExtractor/raw/master/MCE.db'
-	_info_nol "Fetching MCE.db from the MCExtractor project... "
+	_info_nol "Obtendo MCE.db do projeto MCExtractor... "
 	download_file "$mcedb_url" "$mcedb_tmp" || return $?
 
 	# second, get the Intel firmwares from GitHub
 	intel_tmp="$(mktemp -d -t smc-intelfw-XXXXXX)"
 	intel_url="https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/archive/main.zip"
-	_info_nol "Fetching Intel firmwares... "
+	_info_nol "Buscando firmwares Intel... "
 	## https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files.git
 	download_file "$intel_url" "$intel_tmp/fw.zip" || return $?
 
 	# now extract MCEdb contents using sqlite
-	_info_nol "Extracting MCEdb data... "
+	_info_nol "Extraindo dados MCEdb... "
 	if ! command -v sqlite3 >/dev/null 2>&1; then
-		echo ERROR "please install the \`sqlite3\` program"
+		echo ERROR "instale o programa \`sqlite3\`"
 		return 1
 	fi
 	mcedb_revision=$(sqlite3 "$mcedb_tmp" "SELECT \"revision\" from \"MCE\"")
 	if [ -z "$mcedb_revision" ]; then
-		echo ERROR "downloaded file seems invalid"
+		echo ERROR "arquivo baixado parece inválido"
 		return 1
 	fi
 	sqlite3 "$mcedb_tmp" "ALTER TABLE \"Intel\" ADD COLUMN \"origin\" TEXT"
@@ -1116,23 +1116,23 @@ update_fwdb()
 	sqlite3 "$mcedb_tmp" "UPDATE \"AMD\" SET \"origin\"='mce'"
 	sqlite3 "$mcedb_tmp" "UPDATE \"AMD\" SET \"pfmask\"='FF'"
 
-	echo OK "MCExtractor database revision $mcedb_revision"
+	echo OK "Revisão do banco de dados MCExtractor $mcedb_revision"
 
 	# parse Intel firmwares to get their versions
-	_info_nol "Integrating Intel firmwares data to db... "
+	_info_nol "Integrando dados de firmwares da Intel ao db... "
 	if ! command -v unzip >/dev/null 2>&1; then
-		echo ERROR "please install the \`unzip\` program"
+		echo ERROR "por favor, instale o programa \`unzip\`"
 		return 1
 	fi
 	( cd "$intel_tmp" && unzip fw.zip >/dev/null; )
 	if ! [ -d "$intel_tmp/Intel-Linux-Processor-Microcode-Data-Files-main/intel-ucode" ]; then
-		echo ERROR "expected the 'intel-ucode' folder in the downloaded zip file"
+		echo ERROR "esperava a pasta 'intel-ucode' no arquivo zip baixado"
 		return 1
 	fi
 
 	if ! command -v iucode_tool >/dev/null 2>&1; then
 		if ! command -v iucode-tool >/dev/null 2>&1; then
-			echo ERROR "please install the \`iucode-tool\` program"
+			echo ERROR "por favor, instale o programa \`iucode-tool\`"
 			return 1
 		else
 			iucode_tool="iucode-tool"
@@ -1164,21 +1164,21 @@ update_fwdb()
 		# use this date, it matches the last commit date
 		_intel_latest_date=$(date +%Y%m%d -d @"$_intel_timestamp")
 	else
-		echo "Falling back to the latest microcode date"
+		echo "Voltando para a última data do microcódigo"
 		_intel_latest_date=$(sqlite3 "$mcedb_tmp" "SELECT \"yyyymmdd\" FROM \"Intel\" WHERE \"origin\"='intel' ORDER BY \"yyyymmdd\" DESC LIMIT 1;")
 	fi
 	echo DONE "(version $_intel_latest_date)"
 
 	# now parse the most recent linux-firmware amd-ucode README file
-	_info_nol "Fetching latest amd-ucode README from linux-firmware project... "
+	_info_nol "Buscando o último README amd-ucode do projeto linux-firmware... "
 	linuxfw_url="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/amd-ucode/README"
 	linuxfw_tmp=$(mktemp -t smc-linuxfw-XXXXXX)
 	download_file "$linuxfw_url" "$linuxfw_tmp" || return $?
 
-	_info_nol "Parsing the README... "
+	_info_nol "Analisando o README... "
 	nbfound=0
 	for line in $(grep -E 'Family=0x[0-9a-f]+ Model=0x[0-9a-f]+ Stepping=0x[0-9a-f]+: Patch=0x[0-9a-f]+' "$linuxfw_tmp" | tr " " ","); do
-		_debug "Parsing line $line"
+		_debug "Analisando a linha $line"
 		_family=$(  echo "$line" | grep -Eoi 'Family=0x[0-9a-f]+'   | cut -d= -f2)
 		_model=$(   echo "$line" | grep -Eoi 'Model=0x[0-9a-f]+'    | cut -d= -f2)
 		_stepping=$(echo "$line" | grep -Eoi 'Stepping=0x[0-9a-f]+' | cut -d= -f2)
@@ -1187,13 +1187,13 @@ update_fwdb()
 		_cpuid=$(fms2cpuid "$_family" "$_model" "$_stepping")
 		_cpuid=$(printf "%08X" "$_cpuid")
 		_sqlstm="INSERT INTO \"AMD\" (\"origin\",\"cpuid\",\"pfmask\",\"version\",\"yyyymmdd\") VALUES ('linux-firmware','$_cpuid','FF','$_version','20000101')"
-		_debug "family $_family model $_model stepping $_stepping cpuid $_cpuid"
+		_debug "família $_family modelo $_model stepping $_stepping cpuid $_cpuid"
 		_debug "$_sqlstm"
 		sqlite3 "$mcedb_tmp" "$_sqlstm"
 		nbfound=$((nbfound + 1))
 		unset _family _model _stepping _version _cpuid _date _sqlstm
 	done
-	echo "found $nbfound microcodes"
+	echo "encontrados microcódigos $nbfound"
 	unset nbfound
 
 	dbversion="$mcedb_revision+i$_intel_latest_date"
@@ -1203,19 +1203,19 @@ update_fwdb()
 	fi
 
 	if [ "$1" != builtin ] && [ -n "$previous_dbversion" ] && [ "$previous_dbversion" = "v$dbversion" ]; then
-		echo "We already have this version locally, no update needed"
+		echo "Já temos esta versão localmente, nenhuma atualização necessária"
 		return 0
 	fi
 
-	_info_nol "Building local database... "
+	_info_nol "Criando banco de dados local... "
 	{
-		echo "# Spectre & Meltdown Checker";
+		echo "# Spectre e Meltdown Checker";
 		echo "# %%% MCEDB v$dbversion";
 		# we'll use the more recent fw for Intel and AMD
 		sqlite3 "$mcedb_tmp" "SELECT '# I,0x'||\"t1\".\"cpuid\"||',0x'||\"t1\".\"pfmask\"||',0x'||MAX(\"t1\".\"version\")||','||\"t1\".\"yyyymmdd\" FROM \"Intel\" AS \"t1\" LEFT OUTER JOIN \"Intel\" AS \"t2\" ON \"t2\".\"cpuid\"=\"t1\".\"cpuid\" AND \"t2\".\"pfmask\"=\"t1\".\"pfmask\" AND \"t2\".\"yyyymmdd\" > \"t1\".\"yyyymmdd\" WHERE \"t2\".\"yyyymmdd\" IS NULL GROUP BY \"t1\".\"cpuid\",\"t1\".\"pfmask\" ORDER BY \"t1\".\"cpuid\",\"t1\".\"pfmask\" ASC;" | grep -v '^# .,0x00000000,';
 		sqlite3 "$mcedb_tmp" "SELECT '# A,0x'||\"t1\".\"cpuid\"||',0x'||\"t1\".\"pfmask\"||',0x'||MAX(\"t1\".\"version\")||','||\"t1\".\"yyyymmdd\" FROM \"AMD\"   AS \"t1\" LEFT OUTER JOIN \"AMD\"   AS \"t2\" ON \"t2\".\"cpuid\"=\"t1\".\"cpuid\" AND \"t2\".\"pfmask\"=\"t1\".\"pfmask\" AND \"t2\".\"yyyymmdd\" > \"t1\".\"yyyymmdd\" WHERE \"t2\".\"yyyymmdd\" IS NULL GROUP BY \"t1\".\"cpuid\",\"t1\".\"pfmask\" ORDER BY \"t1\".\"cpuid\",\"t1\".\"pfmask\" ASC;" | grep -v '^# .,0x00000000,';
 	} > "$mcedb_cache"
-	echo DONE "(version $dbversion)"
+	echo DONE "(versão $dbversion)"
 
 	if [ "$1" = builtin ]; then
 		newfile=$(mktemp -t smc-builtin-XXXXXX)
@@ -1234,19 +1234,19 @@ parse_opt_file()
 	if [ -z "$option_value" ]; then
 		show_header
 		show_usage
-		echo "$0: error: --$option_name expects one parameter (a file)" >&2
+		echo "$0: erro: --$option_name espera um parâmetro (um arquivo)" >&2
 		exit 1
 	elif [ ! -e "$option_value" ]; then
 		show_header
-		echo "$0: error: couldn't find file $option_value" >&2
+		echo "$0: erro: não foi possível encontrar o arquivo $option_value" >&2
 		exit 1
 	elif [ ! -f "$option_value" ]; then
 		show_header
-		echo "$0: error: $option_value is not a file" >&2
+		echo "$0: erro: $option_value não é um arquivo" >&2
 		exit 1
 	elif [ ! -r "$option_value" ]; then
 		show_header
-		echo "$0: error: couldn't read $option_value (are you root?)" >&2
+		echo "$0: erro: não foi possível ler $option_value (você é root?)" >&2
 		exit 1
 	fi
 	echo "$option_value"
@@ -1309,7 +1309,7 @@ while [ -n "${1:-}" ]; do
 			if echo "$opt_cpu" | grep -Eq '^[0-9]+'; then
 				opt_cpu=$(( opt_cpu ))
 			else
-				echo "$0: error: --cpu should be an integer or 'all', got '$opt_cpu'" >&2
+				echo "$0: erro: --cpu deve ser um número inteiro ou 'todos', obteve '$opt_cpu'" >&2
 				exit 255
 			fi
 		fi
@@ -1340,8 +1340,8 @@ while [ -n "${1:-}" ]; do
 			--*) ;;    # allow subsequent flags
 			'') ;;     # allow nothing at all
 			*)
-				echo "$0: error: unknown batch format '$1'" >&2
-				echo "$0: error: --batch expects a format from: text, nrpe, json" >&2
+				echo "$0: erro: formato de lote desconhecido '$1'" >&2
+				echo "$0: erro: --batch espera um formato de: text, nrpe, json" >&2
 				exit 255
 				;;
 		esac
@@ -1351,7 +1351,7 @@ while [ -n "${1:-}" ]; do
 		shift
 	elif [ "$1" = "--cve" ]; then
 		if [ -z "$2" ]; then
-			echo "$0: error: option --cve expects a parameter, supported CVEs are: $supported_cve_list" >&2
+			echo "$0: erro: option --cve espera um parâmetro, CVEs suportados são: $supported_cve_list" >&2
 			exit 255
 		fi
 		selected_cve=$(echo "$supported_cve_list" | grep -iwo "$2")
@@ -1359,29 +1359,29 @@ while [ -n "${1:-}" ]; do
 			opt_cve_list="$opt_cve_list $selected_cve"
 			opt_cve_all=0
 		else
-			echo "$0: error: unsupported CVE specified ('$2'), supported CVEs are: $supported_cve_list" >&2
+			echo "$0: erro: CVE não suportado especificado ('$2'), os CVEs suportados são: $supported_cve_list" >&2
 			exit 255
 		fi
 		shift 2
 	elif [ "$1" = "--vmm" ]; then
 		if [ -z "$2" ]; then
-			echo "$0: error: option --vmm (auto, yes, no)" >&2
+			echo "$0: erro: opção --vmm (auto, yes, no)" >&2
 			exit 255
 		fi
 		case "$2" in
 			auto) opt_vmm=-1;;
 			yes)  opt_vmm=1;;
 			no)   opt_vmm=0;;
-			*)    echo "$0: error: expected one of (auto, yes, no) to option --vmm instead of '$2'" >&2; exit 255;;
+			*)    echo "$0: erro: esperado um de (auto, yes, no) para a opção --vmm em vez de '$2'" >&2; exit 255;;
 		esac
 		shift 2
 	elif [ "$1" = "--variant" ]; then
 		if [ -z "$2" ]; then
-			echo "$0: error: option --variant expects a parameter (see --variant help)" >&2
+			echo "$0: erro: a opção --variant espera um parâmetro (consulte a ajuda de --variant)" >&2
 			exit 255
 		fi
 		case "$2" in
-			help)	echo "The following parameters are supported for --variant (can be used multiple times):";
+			help)	echo "Os seguintes parâmetros são compatíveis com --variant (podem ser usados várias vezes):";
 					echo "1, 2, 3, 3a, 4, msbds, mfbds, mlpds, mdsum, l1tf, taa, mcepsc, srbds, zenbleed, downfall, inception";
 					exit 0;;
 			1)			opt_cve_list="$opt_cve_list CVE-2017-5753"; opt_cve_all=0;;
@@ -1402,7 +1402,7 @@ while [ -n "${1:-}" ]; do
 			inception)  opt_cve_list="$opt_cve_list CVE-2023-20569"; opt_cve_all=0;;
 			reptar)     opt_cve_list="$opt_cve_list CVE-2023-23583"; opt_cve_all=0;;
 			*)
-				echo "$0: error: invalid parameter '$2' for --variant, see --variant help for a list" >&2;
+				echo "$0: erro: parâmetro inválido '$2' para --variant, consulte a ajuda de --variant para obter uma lista" >&2;
 				exit 255
 				;;
 		esac
@@ -1422,7 +1422,7 @@ while [ -n "${1:-}" ]; do
 	else
 		show_header
 		show_usage
-		echo "$0: error: unknown option '$1'"
+		echo "$0: erro: opção desconhecida '$1'"
 		exit 255
 	fi
 done
@@ -1430,12 +1430,12 @@ done
 show_header
 
 if [ "$opt_no_sysfs" = 1 ] && [ "$opt_sysfs_only" = 1 ]; then
-	_warn "Incompatible options specified (--no-sysfs and --sysfs-only), aborting"
+	_warn "Opções incompatíveis especificadas (--no-sysfs e --sysfs-only), cancelando"
 	exit 255
 fi
 
 if [ "$opt_no_hw" = 1 ] && [ "$opt_hw_only" = 1 ]; then
-	_warn "Incompatible options specified (--no-hw and --hw-only), aborting"
+	_warn "Opções incompatíveis especificadas (--no-hw e --hw-only), cancelando"
 	exit 255
 fi
 
@@ -1478,11 +1478,11 @@ pvulnstatus()
 	pvulnstatus_last_cve="$1"
 	if [ "$opt_batch" = 1 ]; then
 		case "$1" in
-			CVE-2017-5753) aka="SPECTRE VARIANT 1";;
-			CVE-2017-5715) aka="SPECTRE VARIANT 2";;
+			CVE-2017-5753) aka="SPECTRE VARIANTE 1";;
+			CVE-2017-5715) aka="SPECTRE VARIANTE 2";;
 			CVE-2017-5754) aka="MELTDOWN";;
-			CVE-2018-3640) aka="VARIANT 3A";;
-			CVE-2018-3639) aka="VARIANT 4";;
+			CVE-2018-3640) aka="VARIANTE 3A";;
+			CVE-2018-3639) aka="VARIANTE 4";;
 			CVE-2018-3615) aka="L1TF SGX";;
 			CVE-2018-3620) aka="L1TF OS";;
 			CVE-2018-3646) aka="L1TF VMM";;
@@ -1497,7 +1497,7 @@ pvulnstatus()
 			CVE-2022-40982) aka="DOWNFALL";;
 			CVE-2023-20569) aka="INCEPTION";;
 			CVE-2023-23583) aka="REPTAR";;
-			*) echo "$0: error: invalid CVE '$1' passed to pvulnstatus()" >&2; exit 255;;
+			*) echo "$0: erro: CVE inválido '$1' passado para pvulnstatus()" >&2; exit 255;;
 		esac
 
 		case "$opt_batch_format" in
@@ -1505,41 +1505,41 @@ pvulnstatus()
 			short) short_output="${short_output}$1 ";;
 			json)
 				case "$2" in
-					UNK)  is_vuln="null";;
+					DES)  is_vuln="null";;
 					VULN) is_vuln="true";;
 					OK)   is_vuln="false";;
-					*)    echo "$0: error: unknown status '$2' passed to pvulnstatus()" >&2; exit 255;;
+					*)    echo "$0: erro: status desconhecido '$2' passado para pvulnstatus()" >&2; exit 255;;
 				esac
 				[ -z "$json_output" ] && json_output='['
-				json_output="${json_output}{\"NAME\":\"$aka\",\"CVE\":\"$1\",\"VULNERABLE\":$is_vuln,\"INFOS\":\"$3\"},"
+				json_output="${json_output}{\"NOME\":\"$aka\",\"CVE\":\"$1\",\"VULNERÁVEL\":$is_vuln,\"INFOS\":\"$3\"},"
 				;;
 
 			nrpe)	[ "$2" = VULN ] && nrpe_vuln="$nrpe_vuln $1";;
 			prometheus)
 				prometheus_output="${prometheus_output:+$prometheus_output\n}specex_vuln_status{name=\"$aka\",cve=\"$1\",status=\"$2\",info=\"$3\"} 1"
 				;;
-			*) echo "$0: error: invalid batch format '$opt_batch_format' specified" >&2; exit 255;;
+			*) echo "$0: erro: formato de lote inválido '$opt_batch_format' especificado" >&2; exit 255;;
 		esac
 	fi
 
 	# always fill global_* vars because we use that do decide the program exit code
 	case "$2" in
-		UNK)  global_unknown="1";;
+		DES)  global_unknown="1";;
 		VULN) global_critical="1";;
 		OK)   ;;
-		*)    echo "$0: error: unknown status '$2' passed to pvulnstatus()" >&2; exit 255;;
+		*)    echo "$0: erro: status desconhecido '$2' passado para pvulnstatus()" >&2; exit 255;;
 	esac
 
 	# display info if we're not in quiet/batch mode
 	vulnstatus="$2"
 	shift 2
-	_info_nol "> \033[46m\033[30mSTATUS:\033[0m "
+	_info_nol "> \033[46m\033[30mESTADO:\033[0m "
 	: "${final_summary:=}"
 	case "$vulnstatus" in
-		UNK)  pstatus yellow 'UNKNOWN'        "$@"; final_summary="$final_summary \033[43m\033[30m$pvulnstatus_last_cve:??\033[0m";;
-		VULN) pstatus red    'VULNERABLE'     "$@"; final_summary="$final_summary \033[41m\033[30m$pvulnstatus_last_cve:KO\033[0m";;
-		OK)   pstatus green  'NOT VULNERABLE' "$@"; final_summary="$final_summary \033[42m\033[30m$pvulnstatus_last_cve:OK\033[0m";;
-		*)    echo "$0: error: unknown status '$vulnstatus' passed to pvulnstatus()" >&2; exit 255;;
+		DES)  pstatus yellow 'DESCONHECIDO'        "$@"; final_summary="$final_summary \033[43m\033[30m$pvulnstatus_last_cve:??\033[0m";;
+		VULN) pstatus red    'VULNERÁVEL'     "$@"; final_summary="$final_summary \033[41m\033[30m$pvulnstatus_last_cve:KO\033[0m";;
+		OK)   pstatus green  'NÃO VULNERÁVEL' "$@"; final_summary="$final_summary \033[42m\033[30m$pvulnstatus_last_cve:OK\033[0m";;
+		*)    echo "$0: erro: status desconhecido '$vulnstatus' passado para pvulnstatus()" >&2; exit 255;;
 	esac
 }
 
@@ -1576,28 +1576,28 @@ check_kernel()
 	_debug "check_kernel: ret=$? size=$_kernel_size sections=$_readelf_sections warnings=$_readelf_warnings"
 	if [ "$_mode" = desperate ]; then
 		if "${opt_arch_prefix}strings" "$_file" | grep -Eq '^Linux version '; then
-			_debug "check_kernel (desperate): ... matched!"
+			_debug "check_kernel (desesperado): ... coincide!"
 			if [ "$_readelf_sections" = 0 ] && grep -qF -e armv6 -e armv7 "$_file"; then
-				_debug "check_kernel (desperate): raw arm binary found, adjusting objdump options"
+				_debug "check_kernel (desesperado): binário raw arm encontrado, ajustando opções objdump"
 				objdump_options="-D -b binary -marm"
 			else
 				objdump_options="-d"
 			fi
 			return 0
 		else
-			_debug "check_kernel (desperate): ... invalid"
+			_debug "check_kernel (desesperado): ... invalido"
 		fi
 	else
 		if [ $ret -eq 0 ] && [ -z "$_readelf_warnings" ] && [ "$_readelf_sections" -gt 0 ]; then
 			if [ "$_kernel_size" -ge 100000 ]; then
-				_debug "check_kernel: ... file is valid"
+				_debug "check_kernel: ... arquivo é válido"
 				objdump_options="-d"
 				return 0
 			else
-				_debug "check_kernel: ... file seems valid but is too small, ignoring"
+				_debug "check_kernel: ... o arquivo parece válido, mas é muito pequeno, ignorando"
 			fi
 		else
-			_debug "check_kernel: ... file is invalid"
+			_debug "check_kernel: ... arquivo é inválido"
 		fi
 	fi
 	return 1
@@ -1609,19 +1609,19 @@ try_decompress()
 	# "grep" that report the byte offset of the line instead of the pattern.
 
 	# Try to find the header ($1) and decompress from here
-	_debug "try_decompress: looking for $3 magic in $6"
+	_debug "try_decompress: procurando $3 mágicos em $6"
 	for     pos in $(tr "$1\n$2" "\n$2=" < "$6" | grep -abo "^$2")
 	do
-		_debug "try_decompress: magic for $3 found at offset $pos"
+		_debug "try_decompress: mágica por US $3 encontrada no deslocamento $pos"
 		if ! command -v "$3" >/dev/null 2>&1; then
 			if [ "$8" = 1 ]; then
 				# pass1: if the tool is not installed, just bail out silently
 				# and hope that the next decompression tool will be, and that
 				# it'll happen to be the proper one for this kernel
-				_debug "try_decompress: the '$3' tool is not installed (pass 1), try the next algo"
+				_debug "try_decompress: a ferramenta '$3' não está instalada (passe 1), tente o próximo algo"
 			else
 				# pass2: if the tool is not installed, populate kernel_err this time
-				kernel_err="missing '$3' tool, please install it, usually it's in the '$5' package"
+				kernel_err="faltando a ferramenta '$3', instale-a, geralmente está no pacote '$5'"
 				_debug "try_decompress: $kernel_err"
 			fi
 			return 1
@@ -1632,18 +1632,18 @@ try_decompress()
 		if [ ! -s "$kerneltmp" ]; then
 			# don't rely on $ret, sometimes it's != 0 but worked
 			# (e.g. gunzip ret=2 just means there was trailing garbage)
-			_debug "try_decompress: decompression with $3 failed (err=$ret)"
+			_debug "try_decompress: descompressão com $3 falhou (err=$ret)"
 		elif check_kernel "$kerneltmp" "$7"; then
 			kernel="$kerneltmp"
-			_debug "try_decompress: decompressed with $3 successfully!"
+			_debug "try_decompress: descompactado com $3 com sucesso!"
 			return 0
 		elif [ "$3" != "cat" ]; then
-			_debug "try_decompress: decompression with $3 worked but result is not a kernel, trying with an offset"
+			_debug "try_decompress: descompressão com $3 funcionou, mas o resultado não é um kernel, tentando com um deslocamento"
 			[ -z "$kerneltmp2" ] && kerneltmp2=$(mktemp -t smc-kernel-XXXXXX)
 			cat "$kerneltmp" > "$kerneltmp2"
 			try_decompress '\177ELF' xxy 'cat' '' cat "$kerneltmp2" && return 0
 		else
-			_debug "try_decompress: decompression with $3 worked but result is not a kernel"
+			_debug "try_decompress: descompressão com $3 funcionou, mas o resultado não é um kernel"
 		fi
 	done
 	return 1
@@ -1657,7 +1657,7 @@ extract_kernel()
 
 	# Initial attempt for uncompressed images or objects:
 	if check_kernel "$1"; then
-		_debug "extract_kernel: found kernel is valid, no decompression needed"
+		_debug "extract_kernel: kernel encontrado é válido, nenhuma descompressão necessária"
 		cat "$1" > "$kerneltmp"
 		kernel=$kerneltmp
 		return 0
@@ -1679,9 +1679,9 @@ extract_kernel()
 	done
 	# kernel_err might already have been populated by try_decompress() if we're missing one of the tools
 	if [ -z "$kernel_err" ]; then
-		kernel_err="kernel compression format is unknown or image is invalid"
+		kernel_err="o formato de compressão do kernel é desconhecido ou a imagem é inválida"
 	fi
-	_verbose "Couldn't extract the kernel image ($kernel_err), accuracy might be reduced"
+	_verbose "Não foi possível extrair a imagem do kernel ($kernel_err), a precisão pode ser reduzida"
 	return 1
 }
 
@@ -1704,16 +1704,16 @@ load_msr()
 	if [ "$os" = Linux ]; then
 		if ! grep -qw msr "$procfs/modules" 2>/dev/null; then
 			modprobe msr 2>/dev/null && insmod_msr=1
-			_debug "attempted to load module msr, insmod_msr=$insmod_msr"
+			_debug "tentou carregar o módulo msr, insmod_msr=$insmod_msr"
 		else
-			_debug "msr module already loaded"
+			_debug "módulo msr já carregado"
 		fi	
 	else
 		if ! kldstat -q -m cpuctl; then
 			kldload cpuctl 2>/dev/null && kldload_cpuctl=1
-			_debug "attempted to load module cpuctl, kldload_cpuctl=$kldload_cpuctl"
+			_debug "tentou carregar o módulo cpuctl, kldload_cpuctl=$kldload_cpuctl"
 		else
-			_debug "cpuctl module already loaded"
+			_debug "módulo cpuctl já carregado"
 		fi
 	fi
 }
@@ -1727,16 +1727,16 @@ load_cpuid()
 	if [ "$os" = Linux ]; then
 		if ! grep -qw cpuid "$procfs/modules" 2>/dev/null; then
 			modprobe cpuid 2>/dev/null && insmod_cpuid=1
-			_debug "attempted to load module cpuid, insmod_cpuid=$insmod_cpuid"
+			_debug "tentou carregar o módulo cpuid, insmod_cpuid=$insmod_cpuid"
 		else
-			_debug "cpuid module already loaded"
+			_debug "módulo cpuid já carregado"
 		fi	
 	else
 		if ! kldstat -q -m cpuctl; then
 			kldload cpuctl 2>/dev/null && kldload_cpuctl=1
-			_debug "attempted to load module cpuctl, kldload_cpuctl=$kldload_cpuctl"
+			_debug "tentou carregar o módulo cpuctl, kldload_cpuctl=$kldload_cpuctl"
 		else
-			_debug "cpuctl module already loaded"
+			_debug "módulo cpuctl já carregado"
 		fi
 	fi
 }
@@ -1764,7 +1764,7 @@ read_cpuid()
 		else
 			# compare first core with the other ones
 			if [ $_first_core_ret != $ret ] || [ "$_first_core_value" != "$read_cpuid_value" ]; then
-				read_cpuid_msg="result is not homogeneous between all cores, at least core 0 and $_core differ!"
+				read_cpuid_msg="resultado não é homogêneo entre todos os núcleos, pelo menos núcleo 0 e $_core diferem!"
 				return $READ_CPUID_RET_ERR
 			fi
 		fi
@@ -1791,18 +1791,18 @@ read_cpuid_one_core()
 	_wanted="${7:-}"
 	# in any case, the read value is globally available in $read_cpuid_value
 	read_cpuid_value=''
-	read_cpuid_msg='unknown error'
+	read_cpuid_msg='erro desconhecido'
 
 	if [ $# -lt 6 ]; then
-		read_cpuid_msg="read_cpuid: missing arguments, got only $#, expected at least 6: $*"
+		read_cpuid_msg="read_cpuid: argumentos ausentes, obteve apenas $#, esperava pelo menos 6: $*"
 		return $READ_CPUID_RET_ERR
 	fi
 	if [ "$_register" -gt 4 ]; then
-		read_cpuid_msg="read_cpuid: register must be 0-4, got $_register"
+		read_cpuid_msg="read_cpuid: register deve ser 0-4, tem $_register"
 		return $READ_CPUID_RET_ERR
 	fi
 	if [ "$_shift" -gt 32 ]; then
-		read_cpuid_msg="read_cpuid: shift must be 0-31, got $_shift"
+		read_cpuid_msg="read_cpuid: turno deve ser 0-31, tem $_shift"
 		return $READ_CPUID_RET_ERR
 	fi
 
@@ -1814,7 +1814,7 @@ read_cpuid_one_core()
 	if [ -e /dev/cpu/0/cpuid ]; then
 		# Linux
 		if [ ! -r /dev/cpu/0/cpuid ]; then
-			read_cpuid_msg="Couldn't load cpuid module"
+			read_cpuid_msg="Não foi possível carregar o módulo cpuid"
 			return $READ_CPUID_RET_ERR
 		fi
 		# on some kernel versions, /dev/cpu/0/cpuid doesn't imply that the cpuid module is loaded, in that case dd returns an error,
@@ -1834,13 +1834,13 @@ read_cpuid_one_core()
 	elif [ -e /dev/cpuctl0 ]; then
 		# BSD
 		if [ ! -r /dev/cpuctl0 ]; then
-			read_cpuid_msg="Couldn't read cpuid info from cpuctl"
+			read_cpuid_msg="Não foi possível ler as informações do cpuid do cpuctl"
 			return $READ_CPUID_RET_ERR
 		fi
 		_cpuid=$(cpucontrol -i "$_leaf","$_subleaf" "/dev/cpuctl$_core" 2>/dev/null | cut -d: -f2-)
 		# cpuid level 0x4, level_type 0x2: 0x1c004143 0x01c0003f 0x000001ff 0x00000000
 	else
-		read_cpuid_msg="Found no way to read cpuid info"
+		read_cpuid_msg="Não encontrou nenhuma maneira de ler as informações do cpuid"
 		return $READ_CPUID_RET_ERR
 	fi
 
@@ -1849,13 +1849,13 @@ read_cpuid_one_core()
 	# shellcheck disable=SC1083
 	if [ -n "$(eval echo \${$_mockvarname:-})" ]; then
 		_cpuid="$(eval echo \$$_mockvarname)"
-		_debug "read_cpuid: MOCKING enabled for leaf $_leaf subleaf $_subleaf, will return $_cpuid"
+		_debug "read_cpuid: MOCKING ativado para a folha $_leaf subfolha $_subleaf, retornará $_cpuid"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPUID_${_leaf}_${_subleaf}='$_cpuid'")
 	fi
 	if [ -z "$_cpuid" ]; then
-		read_cpuid_msg="Failed to get cpuid data"
+		read_cpuid_msg="Falha ao obter dados cpuid"
 		return $READ_CPUID_RET_ERR
 	fi
 
@@ -1864,15 +1864,15 @@ read_cpuid_one_core()
 	# Linux returns it as decimal, BSD as hex, normalize to decimal
 	_reg=$(( _reg ))
 	# shellcheck disable=SC2046
-	_debug "cpuid: wanted register ($_register) has value $_reg aka "$(printf "%08x" "$_reg")
+	_debug "cpuid: registro desejado ($_register) tem valor $_reg também conhecido como "$(printf "%08x" "$_reg")
 	_reg_shifted=$(( _reg >> _shift ))
 	# shellcheck disable=SC2046
-	_debug "cpuid: shifted value by $_shift is $_reg_shifted aka "$(printf "%x" "$_reg_shifted")
+	_debug "cpuid: valor deslocado por $_shift é $_reg_shifted também conhecido como "$(printf "%x" "$_reg_shifted")
 	read_cpuid_value=$(( _reg_shifted & _mask ))
 	# shellcheck disable=SC2046
-	_debug "cpuid: after AND $_mask, final value is $read_cpuid_value aka "$(printf "%x" "$read_cpuid_value")
+	_debug "cpuid: depois de AND $_mask, o valor final é $read_cpuid_value, também conhecido como "$(printf "%x" "$read_cpuid_value")
 	if [ -n "$_wanted" ]; then
-		_debug "cpuid: wanted $_wanted and got $read_cpuid_value"
+		_debug "cpuid: queria $_queria e recebi $read_cpuid_value"
 		if [ "$read_cpuid_value" = "$_wanted" ]; then
 			return $READ_CPUID_RET_OK
 		else
@@ -1930,7 +1930,7 @@ write_msr()
 		else
 			# compare first core with the other ones
 			if [ $_first_core_ret != $ret ]; then
-				write_msr_msg="result is not homogeneous between all cores, at least core 0 and $_core differ!"
+				write_msr_msg="resultado não é homogêneo entre todos os núcleos, pelo menos o núcleo 0 e $_core diferem!"
 				return $WRITE_MSR_RET_ERR
 			fi
 		fi
@@ -1947,13 +1947,13 @@ write_msr_one_core()
 	_value_dec=$(( $3 ))
 	_value=$(printf "0x%x" "$_value_dec")
 
-	write_msr_msg='unknown error'
+	write_msr_msg='erro desconhecido'
 	: "${msr_locked_down:=0}"
 
 	_mockvarname="SMC_MOCK_WRMSR_${_msr}_RET"
 	# shellcheck disable=SC2086,SC1083
 	if [ -n "$(eval echo \${$_mockvarname:-})" ]; then
-		_debug "write_msr: MOCKING enabled for msr $_msr func returns $(eval echo \$$_mockvarname)"
+		_debug "write_msr: MOCKING ativado para retornos de msr $_msr func $(eval echo \$$_mockvarname)"
 		mocked=1
 		[ "$(eval echo \$$_mockvarname)" = $WRITE_MSR_RET_LOCKDOWN ] && msr_locked_down=1
 		return "$(eval echo \$$_mockvarname)"
@@ -1964,7 +1964,7 @@ write_msr_one_core()
 		load_msr
 	fi
 	if [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then
-		read_msr_msg="is msr kernel module available?"
+		read_msr_msg="o módulo do kernel msr está disponível?"
 		return $WRITE_MSR_RET_ERR
 	fi
 
@@ -1975,17 +1975,17 @@ write_msr_one_core()
 		# for Linux
 		# convert to decimal
 		if [ ! -w /dev/cpu/"$_core"/msr ]; then
-			write_msr_msg="No write permission on /dev/cpu/$_core/msr"
+			write_msr_msg="Sem permissão de gravação em /dev/cpu/$_core/msr"
 			return $WRITE_MSR_RET_ERR
 		# if wrmsr is available, use it
 		elif command -v wrmsr >/dev/null 2>&1 && [ "${SMC_NO_WRMSR:-}" != 1 ]; then
-			_debug "write_msr: using wrmsr"
+			_debug "write_msr: usando wrmsr"
 			wrmsr $_msr_dec $_value_dec 2>/dev/null; ret=$?
 			# ret=4: msr doesn't exist, ret=127: msr.allow_writes=off
 			[ "$ret" = 127 ] && _write_denied=1
 		# or fallback to dd if it supports seek_bytes, we prefer it over perl because we can tell the difference between EPERM and EIO
 		elif dd if=/dev/null of=/dev/null bs=8 count=1 seek="$_msr_dec" oflag=seek_bytes 2>/dev/null && [ "${SMC_NO_DD:-}" != 1 ]; then
-			_debug "write_msr: using dd"
+			_debug "write_msr: usando dd"
 			awk "BEGIN{printf \"%c\", $_value_dec}" | dd of=/dev/cpu/"$_core"/msr bs=8 count=1 seek="$_msr_dec" oflag=seek_bytes 2>/dev/null; ret=$?
 			# if it failed, inspect stderrto look for EPERM
 			if [ "$ret" != 0 ]; then
@@ -1995,13 +1995,13 @@ write_msr_one_core()
 			fi
 		# or if we have perl, use it, any 5.x version will work
 		elif command -v perl >/dev/null 2>&1 && [ "${SMC_NO_PERL:-}" != 1 ]; then
-			_debug "write_msr: using perl"
+			_debug "write_msr: usando perl"
 			ret=1
 			perl -e "open(M,'>','/dev/cpu/$_core/msr') and seek(M,$_msr_dec,0) and exit(syswrite(M,pack(v4,$_value_dec)))"; [ $? -eq 8 ] && ret=0
 		else
-			_debug "write_msr: got no wrmsr, perl or recent enough dd!"
+			_debug "write_msr: não tenho wrmsr, perl ou dd recente o suficiente!"
 			mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_ERR")
-			write_msr_msg="missing tool, install either msr-tools or perl"
+			write_msr_msg="ferramenta ausente, instale msr-tools ou perl"
 			return $WRITE_MSR_RET_ERR
 		fi
 		if [ "$ret" != 0 ]; then
@@ -2014,22 +2014,22 @@ write_msr_one_core()
 			# yet more recent versions of the msr module can be set to msr.allow_writes=off, in which case no dmesg message is printed,
 			# but the write fails
 			if [ "$_write_denied" = 1 ]; then
-				_debug "write_msr: writing to msr has been denied"
+				_debug "write_msr: escrita para msr foi negado"
 				mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN")
 				msr_locked_down=1
-				write_msr_msg="your kernel is configured to deny writes to MSRs from user space"
+				write_msr_msg="seu kernel está configurado para negar gravações em MSRs do espaço do usuário"
 				return $WRITE_MSR_RET_LOCKDOWN
 			elif dmesg | grep -qF "msr: Direct access to MSR"; then
-				_debug "write_msr: locked down kernel detected (Red Hat / Fedora)"
+				_debug "write_msr: kernel bloqueado detectado (Red Hat/Fedora)"
 				mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN")
 				msr_locked_down=1
-				write_msr_msg="your kernel is locked down (Fedora/Red Hat), please reboot without secure boot and retry"
+				write_msr_msg="seu kernel está bloqueado (Fedora/Red Hat), reinicie sem inicialização segura e tente novamente"
 				return $WRITE_MSR_RET_LOCKDOWN
 			elif dmesg | grep -qF "raw MSR access is restricted"; then
-				_debug "write_msr: locked down kernel detected (vanilla)"
+				_debug "write_msr: kernel bloqueado detectado (vanilla)"
 				mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN")
 				msr_locked_down=1
-				write_msr_msg="your kernel is locked down, please reboot with lockdown=none in the kernel cmdline and retry"
+				write_msr_msg="seu kernel está bloqueado, reinicie com lockdown=none no cmdline do kernel e tente novamente"
 				return $WRITE_MSR_RET_LOCKDOWN
 			fi
 			unset _write_denied
@@ -2042,7 +2042,7 @@ write_msr_one_core()
 	else
 		ret=$WRITE_MSR_RET_KO
 	fi
-	_debug "write_msr: for cpu $_core on msr $_msr, value=$_value, ret=$ret"
+	_debug "write_msr: para cpu $_core no msr $_msr, value=$_value, ret=$ret"
 	mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_WRMSR_${_msr}_RET=$ret")
 	return $ret
 }
@@ -2072,7 +2072,7 @@ read_msr()
 		else
 			# compare first core with the other ones
 			if [ $_first_core_ret != $ret ] || [ "$_first_core_value" != "$read_msr_value" ]; then
-				read_msr_msg="result is not homogeneous between all cores, at least core 0 and $_core differ!"
+				read_msr_msg="resultado não é homogêneo entre todos os núcleos, pelo menos o núcleo 0 e $_core diferem!"
 				return $READ_MSR_RET_ERR
 			fi
 		fi
@@ -2088,13 +2088,13 @@ read_msr_one_core()
 	_msr=$(printf "0x%x" "$_msr_dec")
 
 	read_msr_value=''
-	read_msr_msg='unknown error'
+	read_msr_msg='erro desconhecido'
 
 	_mockvarname="SMC_MOCK_RDMSR_${_msr}"
 	# shellcheck disable=SC2086,SC1083
 	if [ -n "$(eval echo \${$_mockvarname:-})" ]; then
 		read_msr_value="$(eval echo \$$_mockvarname)"
-		_debug "read_msr: MOCKING enabled for msr $_msr, returning $read_msr_value"
+		_debug "read_msr: MOCKING ativado para msr $_msr, retornando $read_msr_value"
 		mocked=1
 		return $READ_MSR_RET_OK
 	fi
@@ -2102,7 +2102,7 @@ read_msr_one_core()
 	_mockvarname="SMC_MOCK_RDMSR_${_msr}_RET"
 	# shellcheck disable=SC2086,SC1083
 	if [ -n "$(eval echo \${$_mockvarname:-})" ] && [ "$(eval echo \$$_mockvarname)" -ne 0 ]; then
-		_debug "read_msr: MOCKING enabled for msr $_msr func returns $(eval echo \$$_mockvarname)"
+		_debug "read_msr: MOCKING ativado para retornos de msr $_msr func $(eval echo \$$_mockvarname)"
 		mocked=1
 		return "$(eval echo \$$_mockvarname)"
 	fi
@@ -2112,7 +2112,7 @@ read_msr_one_core()
 		load_msr
 	fi
 	if [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then
-		read_msr_msg="is msr kernel module available?"
+		read_msr_msg="o módulo do kernel msr está disponível?"
 		return $READ_MSR_RET_ERR
 	fi
 
@@ -2131,24 +2131,24 @@ read_msr_one_core()
 		# for Linux
 		if [ ! -r /dev/cpu/"$_core"/msr ]; then
 			mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_ERR")
-			read_msr_msg="No read permission for /dev/cpu/$_core/msr"
+			read_msr_msg="Sem permissão de leitura para /dev/cpu/$_core/msr"
 			return $READ_MSR_RET_ERR
 		# if rdmsr is available, use it
 		elif command -v rdmsr >/dev/null 2>&1 && [ "${SMC_NO_RDMSR:-}" != 1 ]; then
-			_debug "read_msr: using rdmsr on $_msr"
+			_debug "read_msr: usando rdmsr em $_msr"
 			read_msr_value=$(rdmsr -r $_msr_dec 2>/dev/null | od -t u8 -A n)
 		# or if we have perl, use it, any 5.x version will work
 		elif command -v perl >/dev/null 2>&1 && [ "${SMC_NO_PERL:-}" != 1 ]; then
-			_debug "read_msr: using perl on $_msr"
+			_debug "read_msr: usando perl em $_msr"
 			read_msr_value=$(perl -e "open(M,'<','/dev/cpu/$_core/msr') and seek(M,$_msr_dec,0) and read(M,\$_,8) and print" | od -t u8 -A n)
 		# fallback to dd if it supports skip_bytes
 		elif dd if=/dev/null of=/dev/null bs=8 count=1 skip="$_msr_dec" iflag=skip_bytes 2>/dev/null; then
-			_debug "read_msr: using dd on $_msr"
+			_debug "read_msr: usando dd em $_msr"
 			read_msr_value=$(dd if=/dev/cpu/"$_core"/msr bs=8 count=1 skip="$_msr_dec" iflag=skip_bytes 2>/dev/null | od -t u8 -A n)
 		else
-			_debug "read_msr: got no rdmsr, perl or recent enough dd!"
+			_debug "read_msr: não tenho rdmsr, perl ou dd recente o suficiente!"
 			mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_ERR")
-			read_msr_msg='missing tool, install either msr-tools or perl'
+			read_msr_msg='ferramenta ausente, instale msr-tools ou perl'
 			return $READ_MSR_RET_ERR
 		fi
 		if [ -z "$read_msr_value" ]; then
@@ -2160,7 +2160,7 @@ read_msr_one_core()
 		read_msr_value=$(( read_msr_value ))
 	fi
 	mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_RDMSR_${_msr}='$read_msr_value'")
-	_debug "read_msr: MSR=$_msr value is $read_msr_value"
+	_debug "read_msr: MSR=$_msr o valor é $read_msr_value"
 	return $READ_MSR_RET_OK
 }
 
@@ -2238,35 +2238,35 @@ parse_cpu_details()
 
 	if [ -n "${SMC_MOCK_CPU_FRIENDLY_NAME:-}" ]; then
 		cpu_friendly_name="$SMC_MOCK_CPU_FRIENDLY_NAME"
-		_debug "parse_cpu_details: MOCKING cpu friendly name to $cpu_friendly_name"
+		_debug "parse_cpu_details: MOCKING nome amigável da cpu para $ cpu_friendly_name"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_FRIENDLY_NAME='$cpu_friendly_name'")
 	fi
 	if [ -n "${SMC_MOCK_CPU_VENDOR:-}" ]; then
 		cpu_vendor="$SMC_MOCK_CPU_VENDOR"
-		_debug "parse_cpu_details: MOCKING cpu vendor to $cpu_vendor"
+		_debug "parse_cpu_details: MOCKING fornecedor de cpu para $cpu_vendor"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_VENDOR='$cpu_vendor'")
 	fi
 	if [ -n "${SMC_MOCK_CPU_FAMILY:-}" ]; then
 		cpu_family="$SMC_MOCK_CPU_FAMILY"
-		_debug "parse_cpu_details: MOCKING cpu family to $cpu_family"
+		_debug "parse_cpu_details: MOCKING família de cpu para $cpu_family"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_FAMILY='$cpu_family'")
 	fi
 	if [ -n "${SMC_MOCK_CPU_MODEL:-}" ]; then
 		cpu_model="$SMC_MOCK_CPU_MODEL"
-		_debug "parse_cpu_details: MOCKING cpu model to $cpu_model"
+		_debug "parse_cpu_details: MOCKING modelo de CPU para $cpu_model"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_MODEL='$cpu_model'")
 	fi
 	if [ -n "${SMC_MOCK_CPU_STEPPING:-}" ]; then
 		cpu_stepping="$SMC_MOCK_CPU_STEPPING"
-		_debug "parse_cpu_details: MOCKING cpu stepping to $cpu_stepping"
+		_debug "parse_cpu_details: MOCKING cpu passo a passo para $cpu_stepping"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_STEPPING='$cpu_stepping'")
@@ -2284,7 +2284,7 @@ parse_cpu_details()
 		cpu_cpuid="$read_cpuid_value"
 	else
 		# try to build it by ourselves
-		_debug "parse_cpu_details: build the CPUID by ourselves"
+		_debug "parse_cpu_details: construa o CPUID por conta própria"
 		cpu_cpuid=$(fms2cpuid "$cpu_family" "$cpu_model" "$cpu_stepping")
 	fi
 
@@ -2310,14 +2310,14 @@ parse_cpu_details()
 
 	if [ -n "${SMC_MOCK_CPU_UCODE:-}" ]; then
 		cpu_ucode="$SMC_MOCK_CPU_UCODE"
-		_debug "parse_cpu_details: MOCKING cpu ucode to $cpu_ucode"
+		_debug "parse_cpu_details: MOCKING cpu ucode para $cpu_ucode"
 		mocked=1
 	else
 		mockme=$(printf "%b\n%b" "$mockme" "SMC_MOCK_CPU_UCODE='$cpu_ucode'")
 	fi
 
 	echo "$cpu_ucode" | grep -q ^0x && cpu_ucode=$(( cpu_ucode ))
-	ucode_found=$(printf "family 0x%x model 0x%x stepping 0x%x ucode 0x%x cpuid 0x%x pfid 0x%x" \
+	ucode_found=$(printf "familia 0x%x modelo 0x%x stepping 0x%x ucode 0x%x cpuid 0x%x pfid 0x%x" \
 		"$cpu_family" "$cpu_model" "$cpu_stepping" "$cpu_ucode" "$cpu_cpuid" "$cpu_platformid")
 
 	# also define those that we will need in other funcs
@@ -2471,7 +2471,7 @@ is_ucode_blacklisted()
 		if [ "$cpu_model" = "$model" ] && [ "$cpu_stepping" = "$stepping" ]; then
 			ucode=$(( $(echo "$tuple" | cut -d, -f3) ))
 			if [ "$cpu_ucode" = "$ucode" ]; then
-				_debug "is_ucode_blacklisted: we have a match! ($cpu_model/$cpu_stepping/$cpu_ucode)"
+				_debug "is_ucode_blacklisted: temos uma partida! ($cpu_model/$cpu_stepping/$cpu_ucode)"
 				return 0
 			fi
 		fi
@@ -2487,12 +2487,12 @@ is_ucode_blacklisted()
 		cpuid=$(( $(echo "$tuple" | cut -d, -f1) ))
 		ucode=$(( $(echo "$tuple" | cut -d, -f2) ))
 		if [ "$cpu_cpuid" = "$cpuid" ] && [ "$cpu_ucode" = "$ucode" ]; then
-			_debug "is_ucode_blacklisted: we have a match! ($cpuid/$ucode)"
+			_debug "is_ucode_blacklisted: temos uma partida! ($cpuid/$ucode)"
 			return 0
 		fi
 	done
 
-	_debug "is_ucode_blacklisted: no ($cpu_model/$cpu_stepping/$cpu_ucode)"
+	_debug "is_ucode_blacklisted: não ($cpu_model/$cpu_stepping/$cpu_ucode)"
 	return 1
 }
 
@@ -2525,7 +2525,7 @@ is_skylake_cpu()
 is_vulnerable_to_empty_rsb()
 {
 	if is_intel && [ -z "$capabilities_rsba" ]; then
-		_warn "is_vulnerable_to_empty_rsb() called before ARCH CAPABILITIES MSR was read"
+		_warn "is_vulnerable_to_empty_rsb() chamado antes de ARCH CAPABILITIES MSR ser lido"
 	fi
 	if is_skylake_cpu || [ "$capabilities_rsba" = 1 ]; then
 		return 0
@@ -2619,9 +2619,9 @@ is_xen() {
 	fi
 
 	# XXX do we have a better way that relying on dmesg?
-	dmesg_grep 'Booting paravirtualized kernel on Xen$'; ret=$?
+	dmesg_grep 'Inicializando o kernel paravirtualizado no Xen$'; ret=$?
 	if [ $ret -eq 2 ]; then
-		_warn "dmesg truncated, Xen detection will be unreliable. Please reboot and relaunch this script"
+		_warn "dmesg truncado, a detecção do Xen não será confiável. Reinicie e reinicie este script"
 		return 1
 	elif [ $ret -eq 0 ]; then
 		return 0
@@ -2650,7 +2650,7 @@ is_xen_domU()
 	fi
 
 	# PVHVM guests also print 'Booting paravirtualized kernel', so we need this check.
-	dmesg_grep 'Xen HVM callback vector for event delivery is enabled$'; ret=$?
+	dmesg_grep 'O vetor de retorno de chamada Xen HVM para entrega de eventos está ativado$'; ret=$?
 	if [ $ret -eq 0 ]; then
 		return 1
 	fi
@@ -2670,13 +2670,13 @@ if [ -r "$mcedb_cache" ]; then
 	older_dbversion=$(printf "%b\n%b" "$local_dbversion" "$builtin_dbversion" | sort -V | head -n1)
 	if [ "$older_dbversion" = "$builtin_dbversion" ]; then
 		mcedb_source="$mcedb_cache"
-		mcedb_info="local firmwares DB $local_dbversion"
+		mcedb_info="BD de firmwares locais $local_dbversion"
 	fi
 fi
 # if mcedb_source is not set, either we don't have a local cached db, or it is older than the builtin db
 if [ -z "${mcedb_source:-}" ]; then
 	mcedb_source="$0"
-	mcedb_info="builtin firmwares DB $builtin_dbversion"
+	mcedb_info="firmwares embutidos DB $builtin_dbversion"
 fi
 read_mcedb()
 {
@@ -2696,10 +2696,10 @@ is_latest_known_ucode()
 	# 0: yes, 1: no, 2: unknown
 	parse_cpu_details
 	if [ "$cpu_cpuid" = 0 ]; then
-		ucode_latest="couldn't get your cpuid"
+		ucode_latest="não consegui seu cpuid"
 		return 2
 	fi
-	ucode_latest="latest microcode version for your CPU model is unknown"
+	ucode_latest="A versão mais recente do microcódigo para o seu modelo de CPU é desconhecida"
 	if is_intel; then
 		cpu_brand_prefix=I
 	elif is_amd; then
@@ -2716,15 +2716,15 @@ is_latest_known_ucode()
 		fi
 		ucode=$((  $(echo "$tuple" | cut -d, -f4) ))
 		ucode_date=$(echo "$tuple" | cut -d, -f5 | sed -r 's=(....)(..)(..)=\1/\2/\3=')
-		_debug "is_latest_known_ucode: with cpuid $cpu_cpuid has ucode $cpu_ucode, last known is $ucode from $ucode_date"
-		ucode_latest=$(printf "latest version is 0x%x dated $ucode_date according to $mcedb_info" "$ucode")
+		_debug "is_latest_known_ucode: com cpuid $cpu_cpuid possui ucode $cpu_ucode, o último conhecido é $ucode de $ucode_date"
+		ucode_latest=$(printf "versão mais recente é 0x%x data $ucode_date de acordo com $mcedb_info" "$ucode")
 		if [ "$cpu_ucode" -ge "$ucode" ]; then
 			return 0
 		else
 			return 1
 		fi
 	done
-	_debug "is_latest_known_ucode: this cpuid is not referenced ($cpu_cpuid)"
+	_debug "is_latest_known_ucode: este cpuid não é referenciado ($cpu_cpuid)"
 	return 2
 }
 
@@ -2736,7 +2736,7 @@ get_cmdline()
 
 	if [ -n "${SMC_MOCK_CMDLINE:-}" ]; then
 		mocked=1
-		_debug "get_cmdline: using mocked cmdline '$SMC_MOCK_CMDLINE'"
+		_debug "get_cmdline: usando cmdline zombado '$SMC_MOCK_CMDLINE'"
 		kernel_cmdline="$SMC_MOCK_CMDLINE"
 		return
 	else
@@ -2749,17 +2749,17 @@ get_cmdline()
 
 # we can't do anything useful under WSL
 if uname -a | grep -qE -- '-Microsoft #[0-9]+-Microsoft '; then
-	_warn "This script doesn't work under Windows Subsystem for Linux"
-	_warn "You should use the official Microsoft tool instead."
-	_warn "It can be found under https://aka.ms/SpeculationControlPS"
+	_warn "Este script não funciona no Windows Subsystem for Linux"
+	_warn "Você deve usar a ferramenta oficial da Microsoft."
+	_warn "Pode ser encontrado em https://aka.ms/SpeculationControlPS"
 	exit 1
 fi
 
 # or other UNIX-ish OSes non-Linux non-supported-BSDs
 if [ "$os" = Darwin ] || [ "$os" = VMkernel ]; then
-	_warn "You're running under the $os OS, but this script"
-	_warn "only works under Linux and some BSD systems, sorry."
-	_warn "Please read the README and FAQ for more information."
+	_warn "Você está executando no SO $os, mas este script"
+	_warn "só funciona no Linux e alguns sistemas BSD, desculpe."
+	_warn "Por favor, leia o README e FAQ para mais informações."
 	exit 1
 fi
 
@@ -2767,7 +2767,7 @@ fi
 if [ "$opt_hw_only" = 1 ]; then
 	if [ "$opt_cve_all" = 0 ]; then
 		show_usage
-		echo "$0: error: incompatible modes specified, --hw-only vs --variant" >&2
+		echo "$0: erro: modos incompatíveis especificados, --hw-only vs --variant" >&2
 		exit 255
 	else
 		opt_cve_all=0
@@ -2778,10 +2778,10 @@ fi
 # coreos mode
 if [ "$opt_coreos" = 1 ]; then
 	if ! is_coreos; then
-		_warn "CoreOS mode asked, but we're not under CoreOS!"
+		_warn "Perguntou o modo CoreOS, mas não estamos sob o CoreOS!"
 		exit 255
 	fi
-	_warn "CoreOS mode, starting an ephemeral toolbox to launch the script"
+	_warn "Modo CoreOS, iniciando uma caixa de ferramentas efêmera para iniciar o script"
 	load_msr
 	load_cpuid
 	mount_debugfs
@@ -2790,7 +2790,7 @@ if [ "$opt_coreos" = 1 ]; then
 	exit $exitcode
 else
 	if is_coreos; then
-		_warn "You seem to be running CoreOS, you might want to use the --coreos option for better results"
+		_warn "Você parece estar executando o CoreOS, talvez queira usar a opção --coreos para obter melhores resultados"
 		_warn
 	fi
 fi
@@ -2798,21 +2798,21 @@ fi
 # if we're under a BSD, try to mount linprocfs for "$procfs/cpuinfo"
 procfs=/proc
 if echo "$os" | grep -q BSD; then
-	_debug "We're under BSD, check if we have procfs"
+	_debug "Estamos sob BSD, verifique se temos procfs"
 	procfs=$(mount | awk '/^linprocfs/ { print $3; exit; }')
 	if [ -z "$procfs" ]; then
-		_debug "we don't, try to mount it"
+		_debug "nós não, tente montar"
 		procfs=/proc
 		[ -d /compat/linux/proc ] && procfs=/compat/linux/proc
 		test -d $procfs || mkdir $procfs
 		if mount -t linprocfs linprocfs $procfs 2>/dev/null; then
 			mounted_procfs=1
-			_debug "procfs just mounted at $procfs"
+			_debug "procfs apenas montado em $procfs"
 		else
 			procfs=''
 		fi
 	else
-		_debug "We do: $procfs"
+		_debug "Nós fazemos: $procfs"
 	fi
 fi
 
@@ -2831,14 +2831,14 @@ parse_cpu_details
 get_cmdline
 
 if [ "$opt_cpu" != all ] && [ "$opt_cpu" -gt "$max_core_id" ]; then
-	echo "$0: error: --cpu can't be higher than $max_core_id, got $opt_cpu" >&2
+	echo "$0: erro: --cpu não pode ser maior que $max_core_id, tem $opt_cpu" >&2
 	exit 255
 fi
 
 if [ "$opt_live" = 1 ]; then
-	_info "Checking for vulnerabilities on current system"
-	_info "Kernel is \033[35m$os $(uname -r) $(uname -v) $(uname -m)\033[0m"
-	_info "CPU is \033[35m$cpu_friendly_name\033[0m"
+	_info "Verificando vulnerabilidades no sistema atual"
+	_info "Kernel é \033[35m$os $(uname -r) $(uname -v) $(uname -m)\033[0m"
+	_info "CPU é \033[35m$cpu_friendly_name\033[0m"
 
 	# try to find the image of the current running kernel
 	if [ -n "$opt_kernel" ]; then
@@ -2847,7 +2847,7 @@ if [ "$opt_live" = 1 ]; then
 	# first, look for the BOOT_IMAGE hint in the kernel cmdline
 	elif echo "$kernel_cmdline" | grep -q 'BOOT_IMAGE='; then
 		opt_kernel=$(echo "$kernel_cmdline" | grep -Eo 'BOOT_IMAGE=[^ ]+' | cut -d= -f2)
-		_debug "found opt_kernel=$opt_kernel in $procfs/cmdline"
+		_debug "encontrado opt_kernel=$opt_kernel em $procfs/cmdline"
 		# if the boot partition is within a btrfs subvolume, strip the subvolume name
 		# if /boot is a separate subvolume, the remainder of the code in this section should handle it
 		if echo "$opt_kernel" | grep -q "^/@"; then opt_kernel=$(echo "$opt_kernel" | sed "s:/@[^/]*::"); fi
@@ -2856,7 +2856,7 @@ if [ "$opt_live" = 1 ]; then
 		[ -e "/boot/$opt_kernel" ] && opt_kernel="/boot/$opt_kernel"
 		# special case for CoreOS if we're inside the toolbox
 		[ -e "/media/root/boot/$opt_kernel" ] && opt_kernel="/media/root/boot/$opt_kernel"
-		_debug "opt_kernel is now $opt_kernel"
+		_debug "opt_kernel é agora $opt_kernel"
 		# else, the full path is already there (most probably /boot/something)
 	fi
 	# if we didn't find a kernel, default to guessing
@@ -2934,60 +2934,60 @@ if [ "$opt_live" = 1 ]; then
 		opt_config="/lib/kernel/config-$(uname -r)"
 	fi
 else
-	_info "Checking for vulnerabilities against specified kernel"
-	_info "CPU is \033[35m$cpu_friendly_name\033[0m"
+	_info "Verificando vulnerabilidades em relação ao kernel especificado"
+	_info "CPU é \033[35m$cpu_friendly_name\033[0m"
 fi
 
 if [ -n "$opt_kernel" ]; then
-	_verbose "Will use kernel image \033[35m$opt_kernel\033[0m"
+	_verbose "Usará imagem do kernel \033[35m$opt_kernel\033[0m"
 else
-	_verbose "Will use no kernel image (accuracy might be reduced)"
+	_verbose "Não usará imagem do kernel (a precisão pode ser reduzida)"
 	bad_accuracy=1
 fi
 
 if [ "$os" = Linux ]; then
 	if [ -n "$opt_config" ] && ! grep -q '^CONFIG_' "$opt_config"; then
 		# given file is invalid!
-		_warn "The kernel config file seems invalid, was expecting a plain-text file, ignoring it!"
+		_warn "O arquivo de configuração do kernel parece inválido, esperava um arquivo de texto sem formatação, ignorando-o!"
 		opt_config=''
 	fi
 
 	if [ -n "${dumped_config:-}" ] && [ -n "$opt_config" ]; then
-		_verbose "Will use kconfig \033[35m$procfs/config.gz (decompressed)\033[0m"
+		_verbose "Usará o kconfig \033[35m$procfs/config.gz (descomprimido)\033[0m"
 	elif [ -n "$opt_config" ]; then
-		_verbose "Will use kconfig \033[35m$opt_config\033[0m"
+		_verbose "Usará o kconfig \033[35m$opt_config\033[0m"
 	else
-		_verbose "Will use no kconfig (accuracy might be reduced)"
+		_verbose "Não usará o kconfig (a precisão pode ser reduzida)"
 		bad_accuracy=1
 	fi
 
 	if [ -n "$opt_map" ]; then
-		_verbose "Will use System.map file \033[35m$opt_map\033[0m"
+		_verbose "Usará o arquivo System.map \033[35m$opt_map\033[0m"
 	else
-		_verbose "Will use no System.map file (accuracy might be reduced)"
+		_verbose "Não usará nenhum arquivo System.map (a precisão pode ser reduzida)"
 		bad_accuracy=1
 	fi
 
 	if [ "${bad_accuracy:=0}" = 1 ]; then
-		_warn "We're missing some kernel info (see -v), accuracy might be reduced"
+		_warn "Faltam algumas informações do kernel (consulte -v), a precisão pode ser reduzida"
 	fi
 fi
 
 if [ -e "$opt_kernel" ]; then
 	if ! command -v "${opt_arch_prefix}readelf" >/dev/null 2>&1; then
-		_debug "readelf not found"
-		kernel_err="missing '${opt_arch_prefix}readelf' tool, please install it, usually it's in the 'binutils' package"
+		_debug "readelf não encontrado"
+		kernel_err="faltando a ferramenta '${opt_arch_prefix}readelf', instale-a, geralmente está no pacote 'binutils'"
 	elif [ "$opt_sysfs_only" = 1 ] || [ "$opt_hw_only" = 1 ]; then
-		kernel_err='kernel image decompression skipped'
+		kernel_err='descompressão de imagem do kernel ignorada'
 	else
 		extract_kernel "$opt_kernel"
 	fi
 else
-	_debug "no opt_kernel defined"
-	kernel_err="couldn't find your kernel image in /boot, if you used netboot, this is normal"
+	_debug "nenhum opt_kernel definido"
+	kernel_err="não foi possível encontrar sua imagem do kernel em /boot, se você usou o netboot, isso é normal"
 fi
 if [ -z "$kernel" ] || [ ! -r "$kernel" ]; then
-	[ -z "$kernel_err" ] && kernel_err="couldn't extract your kernel from $opt_kernel"
+	[ -z "$kernel_err" ] && kernel_err="não foi possível extrair seu kernel de $opt_kernel"
 else
 	# vanilla kernels have with ^Linux version
 	# also try harder with some kernels (such as Red Hat) that don't have ^Linux version before their version string
@@ -3003,15 +3003,15 @@ else
 	if [ -n "$kernel_version" ]; then
 		# in live mode, check if the img we found is the correct one
 		if [ "$opt_live" = 1 ]; then
-			_verbose "Kernel image is \033[35m$kernel_version"
+			_verbose "A imagem do kernel é \033[35m$kernel_version"
 			if ! echo "$kernel_version" | grep -qF "$(uname -r)"; then
-				_warn "Possible discrepancy between your running kernel '$(uname -r)' and the image '$kernel_version' we found ($opt_kernel), results might be incorrect"
+				_warn "Possível discrepância entre o kernel em execução '$(uname -r)' e a imagem '$kernel_version' que encontramos ($opt_kernel), os resultados podem estar incorretos"
 			fi
 		else
-			_info "Kernel image is \033[35m$kernel_version"
+			_info "A imagem do kernel é \033[35m$kernel_version"
 		fi
 	else
-		_verbose "Kernel image version is unknown"
+		_verbose "A versão da imagem do kernel é desconhecida"
 	fi
 fi
 
@@ -3040,7 +3040,7 @@ sys_interface_check()
 	_mockvarname="SMC_MOCK_SYSFS_$(basename "$file")_RET"
 	# shellcheck disable=SC2086,SC1083
 	if [ -n "$(eval echo \${$_mockvarname:-})" ]; then
-		_debug "sysfs: MOCKING enabled for $file func returns $(eval echo \$$_mockvarname)"
+		_debug "sysfs: MOCKING ativado para $file func retorna $(eval echo \$$_mockvarname)"
 		mocked=1
 		return "$(eval echo \$$_mockvarname)"
 	fi
@@ -3051,7 +3051,7 @@ sys_interface_check()
 	if [ -n "$(eval echo \${$_mockvarname:-})" ]; then
 		fullmsg="$(eval echo \$$_mockvarname)"
 		msg=$(echo "$fullmsg" | grep -Eo "$regex")
-		_debug "sysfs: MOCKING enabled for $file, will return $fullmsg"
+		_debug "sysfs: MOCKING ativado para $file, retornará $fullmsg"
 		mocked=1
 	else
 		fullmsg=$(cat "$file")
@@ -3061,25 +3061,25 @@ sys_interface_check()
 	if [ "$mode" = silent ]; then
 		return 0
 	elif [ "$mode" = quiet ]; then
-		_info "* Information from the /sys interface: $fullmsg"
+		_info "* Informações da interface /sys: $fullmsg"
 		return 0
 	fi
-	_info_nol "* Mitigated according to the /sys interface: "
+	_info_nol "* Mitigado de acordo com a interface /sys: "
 	if echo "$msg" | grep -qi '^not affected'; then
 		# Not affected
 		status=OK
-		pstatus green YES "$fullmsg"
+		pstatus green SIM "$fullmsg"
 	elif echo "$msg" | grep -qEi '^(kvm: )?mitigation'; then
 		# Mitigation: PTI
 		status=OK
-		pstatus green YES "$fullmsg"
+		pstatus green SIM "$fullmsg"
 	elif echo "$msg" | grep -qi '^vulnerable'; then
 		# Vulnerable
 		status=VULN
-		pstatus yellow NO "$fullmsg"
+		pstatus yellow NÃO "$fullmsg"
 	else
-		status=UNK
-		pstatus yellow UNKNOWN "$fullmsg"
+		status=DESC
+		pstatus yellow DESCONHECIDO "$fullmsg"
 	fi
 	_debug "sys_interface_check: $file=$msg (re=$regex)"
 	return 0
@@ -3087,29 +3087,29 @@ sys_interface_check()
 
 check_cpu()
 {
-	_info "\033[1;34mHardware check\033[0m"
+	_info "\033[1;34mVerificação de hardware\033[0m"
 
 	if ! uname -m | grep -qwE 'x86_64|i[3-6]86|amd64'; then
 		return
 	fi
 
-	_info     "* Hardware support (CPU microcode) for mitigation techniques"
-	_info     "  * Indirect Branch Restricted Speculation (IBRS)"
-	_info_nol "    * SPEC_CTRL MSR is available: "
+	_info     "* Suporte de hardware (microcódigo da CPU) para técnicas de mitigação"
+	_info     "  * Especulação Restrita à Filial Indireta (IBRS)"
+	_info_nol "    * SPEC_CTRL MSR está disponível: "
 	# the new MSR 'SPEC_CTRL' is at offset 0x48
 	read_msr 0x48; ret=$?
 	if [ $ret = $READ_MSR_RET_OK ]; then
 		spec_ctrl_msr=1
-		pstatus green YES
+		pstatus green SIM
 	elif [ $ret = $READ_MSR_RET_KO ]; then
 		spec_ctrl_msr=0
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
 		spec_ctrl_msr=-1
-		pstatus yellow UNKNOWN "$read_msr_msg"
+		pstatus yellow DESCONHECIDO "$read_msr_msg"
 	fi
 
-	_info_nol "    * CPU indicates IBRS capability: "
+	_info_nol "    * CPU indica capacidade do IBRS: "
 	# from kernel src: { X86_FEATURE_SPEC_CTRL,        CPUID_EDX,26, 0x00000007, 0 },
 	# amd: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf
 	# amd: 8000_0008 EBX[14]=1
@@ -3117,179 +3117,179 @@ check_cpu()
 	if is_intel; then
 		read_cpuid 0x7 0x0 $EDX 26 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES "SPEC_CTRL feature bit"
+			pstatus green SIM "Bit de recurso SPEC_CTRL"
 			cpuid_spec_ctrl=1
 			cpuid_ibrs='SPEC_CTRL'
 		fi
 	elif is_amd || is_hygon; then
 		read_cpuid 0x80000008 0x0 $EBX 14 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES "IBRS_SUPPORT feature bit"
+			pstatus green SIM "Bit de recurso IBRS_SUPPORT"
 			cpuid_ibrs='IBRS_SUPPORT'
 		fi
 	else
 		ret=invalid
-		pstatus yellow NO "unknown CPU"
+		pstatus yellow NÃO "CPU desconhecida"
 	fi
 	if [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	elif [ $ret = $READ_CPUID_RET_ERR ]; then
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		cpuid_spec_ctrl=-1
 	fi
 
 	if is_amd || is_hygon; then
-		_info_nol "    * CPU indicates preferring IBRS always-on: "
+		_info_nol "    * CPU indica que prefere o IBRS sempre ativo: "
 		# amd or hygon
 		read_cpuid 0x80000008 0x0 $EBX 16 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 
-		_info_nol "    * CPU indicates preferring IBRS over retpoline: "
+		_info_nol "    * CPU indica a preferência do IBRS sobre o retpoline: "
 		# amd or hygon
 		read_cpuid 0x80000008 0x0 $EBX 18 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 	fi
 
 	# IBPB
-	_info     "  * Indirect Branch Prediction Barrier (IBPB)"
+	_info     "  * Barreira de Previsão de Filial Indireta (IBPB)"
 
 	if [ "$opt_allow_msr_write" = 1 ]; then
-		_info_nol "    * PRED_CMD MSR is available: "
+		_info_nol "    * PRED_CMD MSR está disponível: "
 		# the new MSR 'PRED_CTRL' is at offset 0x49, write-only
 		write_msr 0x49; ret=$?
 		if [ $ret = $WRITE_MSR_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 		elif [ $ret = $WRITE_MSR_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "$write_msr_msg"
+			pstatus yellow DESCONHECIDO "$write_msr_msg"
 		fi
 	fi
 
-	_info_nol "    * CPU indicates IBPB capability: "
+	_info_nol "    * CPU indica capacidade IBPB: "
 	# CPUID EAX=0x80000008, ECX=0x00 return EBX[12] indicates support for just IBPB.
 	if [ "$cpuid_spec_ctrl" = 1 ]; then
 		# spec_ctrl implies ibpb
 		cpuid_ibpb='SPEC_CTRL'
-		pstatus green YES "SPEC_CTRL feature bit"
+		pstatus green SIM "Bit de recurso SPEC_CTRL"
 	elif is_intel; then
 		if [ "$cpuid_spec_ctrl" = -1 ]; then
-			pstatus yellow UNKNOWN "is cpuid kernel module available?"
+			pstatus yellow DESCONHECIDO "o módulo do kernel cpuid está disponível?"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 	elif is_amd || is_hygon; then
 		read_cpuid 0x80000008 0x0 $EBX 12 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
 			cpuid_ibpb='IBPB_SUPPORT'
-			pstatus green YES "IBPB_SUPPORT feature bit"
+			pstatus green SIM "Bit de recurso IBPB_SUPPORT"
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 	fi
 
 	# STIBP
-	_info     "  * Single Thread Indirect Branch Predictors (STIBP)"
-	_info_nol "    * SPEC_CTRL MSR is available: "
+	_info     "  * Preditores de ramo indireto de segmento único (STIBP)"
+	_info_nol "    * SPEC_CTRL MSR está disponível: "
 	if [ "$spec_ctrl_msr" = 1 ]; then
-		pstatus green YES
+		pstatus green SIM
 	elif [ "$spec_ctrl_msr" = 0 ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
-		pstatus yellow UNKNOWN "is msr kernel module available?"
+		pstatus yellow DESCONHECIDO "o módulo do kernel msr está disponível?"
 	fi
 
-	_info_nol "    * CPU indicates STIBP capability: "
+	_info_nol "    * CPU indica capacidade STIBP: "
 	# intel: A processor supports STIBP if it enumerates CPUID (EAX=7H,ECX=0):EDX[27] as 1
 	# amd: 8000_0008 EBX[15]=1
 	if is_intel; then
 		read_cpuid 0x7 0x0 $EDX 27 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES "Intel STIBP feature bit"
+			pstatus green SIM "Bit de recurso Intel STIBP"
 			#cpuid_stibp='Intel STIBP'
 		fi
 	elif is_amd; then
 		read_cpuid 0x80000008 0x0 $EBX 15 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES "AMD STIBP feature bit"
+			pstatus green SIM "Bit de recurso AMD STIBP"
 			#cpuid_stibp='AMD STIBP'
 		fi
 	elif is_hygon; then
 		read_cpuid 0x80000008 0x0 $EBX 15 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES "HYGON STIBP feature bit"
+			pstatus green SIM "Bit de recurso HYGON STIBP"
 			#cpuid_stibp='HYGON STIBP'
 		fi
 	else
 		ret=invalid
-		pstatus yellow UNKNOWN "unknown CPU"
+		pstatus yellow DESCONHECIDO "CPU desconhecida"
 	fi
 	if [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	elif [ $ret = $READ_CPUID_RET_ERR ]; then
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 	fi
 
 
 	if is_amd || is_hygon; then
-		_info_nol "    * CPU indicates preferring STIBP always-on: "
+		_info_nol "    * CPU indica a preferência de STIBP sempre ativo: "
 		read_cpuid 0x80000008 0x0 $EBX 17 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 	fi
 
 	# variant 4
 	if is_intel; then
-		_info     "  * Speculative Store Bypass Disable (SSBD)"
-		_info_nol "    * CPU indicates SSBD capability: "
+		_info     "  * Desvio de desvio de armazenamento especulativo (SSBD)"
+		_info_nol "    * CPU indica capacidade SSBD: "
 		read_cpuid 0x7 0x0 $EDX 31 1 1; ret24=$?; ret25=$ret24
 		if [ $ret24 = $READ_CPUID_RET_OK ]; then
 			cpuid_ssbd='Intel SSBD'
 		fi
 	elif is_amd; then
-		_info     "  * Speculative Store Bypass Disable (SSBD)"
-		_info_nol "    * CPU indicates SSBD capability: "
+		_info     "  * Desvio de desvio de armazenamento especulativo (SSBD)"
+		_info_nol "    * CPU indica capacidade SSBD: "
 		read_cpuid 0x80000008 0x0 $EBX 24 1 1; ret24=$?
 		read_cpuid 0x80000008 0x0 $EBX 25 1 1; ret25=$?
 		if [ $ret24 = $READ_CPUID_RET_OK ]; then
-			cpuid_ssbd='AMD SSBD in SPEC_CTRL'
+			cpuid_ssbd='AMD SSBD em SPEC_CTRL'
 			#cpuid_ssbd_spec_ctrl=1
 		elif [ $ret25 = $READ_CPUID_RET_OK ]; then
-			cpuid_ssbd='AMD SSBD in VIRT_SPEC_CTRL'
+			cpuid_ssbd='AMD SSBD em VIRT_SPEC_CTRL'
 			#cpuid_ssbd_virt_spec_ctrl=1
 		elif [ "$cpu_family" -ge 21 ] && [ "$cpu_family" -le 23 ]; then
 			cpuid_ssbd='AMD non-architectural MSR'
 		fi
 	elif is_hygon; then
-		_info     "  * Speculative Store Bypass Disable (SSBD)"
-		_info_nol "    * CPU indicates SSBD capability: "
+		_info     "  * Desvio de desvio de armazenamento especulativo (SSBD)"
+		_info_nol "    * CPU indica capacidade SSBD: "
 		read_cpuid 0x80000008 0x0 $EBX 24 1 1; ret24=$?
 		read_cpuid 0x80000008 0x0 $EBX 25 1 1; ret25=$?
 
 		if [ $ret24 = $READ_CPUID_RET_OK ]; then
-			cpuid_ssbd='HYGON SSBD in SPEC_CTRL'
+			cpuid_ssbd='HYGON SSBD em SPEC_CTRL'
 			#hygon cpuid_ssbd_spec_ctrl=1
 		elif [ $ret25 = $READ_CPUID_RET_OK ]; then
-			cpuid_ssbd='HYGON SSBD in VIRT_SPEC_CTRL'
+			cpuid_ssbd='HYGON SSBD em VIRT_SPEC_CTRL'
 			#hygon cpuid_ssbd_virt_spec_ctrl=1
 		elif [ "$cpu_family" -ge 24 ]; then
 			cpuid_ssbd='HYGON non-architectural MSR'
@@ -3297,11 +3297,11 @@ check_cpu()
 	fi
 
 	if [ -n "${cpuid_ssbd:=}" ]; then
-		pstatus green YES "$cpuid_ssbd"
+		pstatus green SIM "$cpuid_ssbd"
 	elif [ "$ret24" = $READ_CPUID_RET_ERR ] && [ "$ret25" = $READ_CPUID_RET_ERR ]; then
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
 	amd_ssb_no=0
@@ -3324,35 +3324,35 @@ check_cpu()
 		fi
 	fi
 
-	_info "  * L1 data cache invalidation"
+	_info "  * Invalidação de cache de dados L1"
 
 	if [ "$opt_allow_msr_write" = 1 ]; then
-		_info_nol "    * FLUSH_CMD MSR is available: "
+		_info_nol "    * FLUSH_CMD MSR está disponível: "
 		# the new MSR 'FLUSH_CMD' is at offset 0x10b, write-only
 		write_msr 0x10b; ret=$?
 		if [ $ret = $WRITE_MSR_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 			cpu_flush_cmd=1
 		elif [ $ret = $WRITE_MSR_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 			cpu_flush_cmd=0
 		else
-			pstatus yellow UNKNOWN "$write_msr_msg"
+			pstatus yellow DESCONHECIDO "$write_msr_msg"
 			cpu_flush_cmd=-1
 		fi
 	fi
 
 	# CPUID of L1D
-	_info_nol "    * CPU indicates L1D flush capability: "
+	_info_nol "    * CPU indica capacidade de descarga L1D: "
 	read_cpuid 0x7 0x0 $EDX 28 1 1; ret=$?
 	if [ $ret = $READ_CPUID_RET_OK ]; then
-		pstatus green YES "L1D flush feature bit"
+		pstatus green SIM "Bit de recurso de descarga L1D"
 		cpuid_l1df=1
 	elif [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 		cpuid_l1df=0
 	else
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		cpuid_l1df=-1
 	fi
 
@@ -3363,60 +3363,60 @@ check_cpu()
 	fi
 
 	if is_intel; then
-		_info     "  * Microarchitectural Data Sampling"
-		_info_nol "    * VERW instruction is available: "
+		_info     "  * Amostragem de dados microarquitetônicos"
+		_info_nol "    * A instrução VERW está disponível: "
 		read_cpuid 0x7 0x0 $EDX 10 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
 			cpuid_md_clear=1
-			pstatus green YES "MD_CLEAR feature bit"
+			pstatus green SIM "Bit de recurso MD_CLEAR"
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
 			cpuid_md_clear=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
 			cpuid_md_clear=-1
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 	fi
 
 	if is_intel; then
-		_info     "  * Indirect Branch Predictor Controls"
-		_info_nol "    * Indirect Predictor Disable feature is available: "
+		_info     "  * Controles de previsão de ramificação indireta"
+		_info_nol "    * O recurso Desativar Preditor Indireto está disponível: "
 		read_cpuid 0x7 0x2 $EDX 1 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
 			cpuid_ipred=1
-			pstatus green YES "IPRED_CTRL feature bit"
+			pstatus green SIM "Bit de recurso IPRED_CTRL"
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
 			cpuid_ipred=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
 			cpuid_ipred=-1
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 
-		_info_nol "    * Bottomless RSB Disable feature is available: "
+		_info_nol "    * O recurso Desativar RSB sem fundo está disponível: "
 		read_cpuid 0x7 0x2 $EDX 2 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
 			cpuid_rrsba=1
-			pstatus green YES "RRSBA_CTRL feature bit"
+			pstatus green SIM "Bit de recurso RRSBA_CTRL"
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
 			cpuid_rrsba=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
 			cpuid_rrsba=-1
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 
-		_info_nol "    * BHB-Focused Indirect Predictor Disable feature is available: "
+		_info_nol "    * O recurso de desativação do preditor indireto focado em BHB está disponível: "
 		read_cpuid 0x7 0x2 $EDX 2 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
 			cpuid_bhi=1
-			pstatus green YES "BHI_CTRL feature bit"
+			pstatus green SIM "Bit de recurso BHI_CTRL"
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
 			cpuid_bhi=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
 			cpuid_bhi=-1
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 
 		# make shellcheck happy while we're not yet using these new cpuid values in our checks
@@ -3424,22 +3424,22 @@ check_cpu()
 	fi
 
 	if is_intel; then
-		_info     "  * Enhanced IBRS (IBRS_ALL)"
-		_info_nol "    * CPU indicates ARCH_CAPABILITIES MSR availability: "
+		_info     "  * IBRS Aprimorado (IBRS_ALL)"
+		_info_nol "    * CPU indica disponibilidade de ARCH_CAPABILITIES MSR: "
 		cpuid_arch_capabilities=-1
 		# A processor supports the ARCH_CAPABILITIES MSR if it enumerates CPUID (EAX=7H,ECX=0):EDX[29] as 1
 		read_cpuid 0x7 0x0 $EDX 29 1 1; ret=$?
 		if [ $ret = $READ_CPUID_RET_OK ]; then
-			pstatus green YES
+			pstatus green SIM
 			cpuid_arch_capabilities=1
 		elif [ $ret = $READ_CPUID_RET_KO ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 			cpuid_arch_capabilities=0
 		else
-			pstatus yellow UNKNOWN "$read_cpuid_msg"
+			pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		fi
 
-		_info_nol "    * ARCH_CAPABILITIES MSR advertises IBRS_ALL capability: "
+		_info_nol "    * ARCH_CAPABILITIES MSR anuncia o recurso IBRS_ALL: "
 		capabilities_taa_no=-1
 		capabilities_mds_no=-1
 		capabilities_rdcl_no=-1
@@ -3452,7 +3452,7 @@ check_cpu()
 		capabilities_gds_ctrl=-1
 		capabilities_gds_no=-1
 		if [ "$cpuid_arch_capabilities" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$cpuid_arch_capabilities" != 1 ]; then
 			capabilities_rdcl_no=0
 			capabilities_taa_no=0
@@ -3465,7 +3465,7 @@ check_cpu()
 			capabilities_tsx_ctrl_msr=0
 			capabilities_gds_ctrl=0
 			capabilities_gds_no=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
 			# the new MSR 'ARCH_CAPABILITIES' is at offset 0x10a
 			read_msr 0x10a; ret=$?
@@ -3483,7 +3483,7 @@ check_cpu()
 			if [ $ret = $READ_MSR_RET_OK ]; then
 				capabilities=$read_msr_value
 				# https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/include/asm/msr-index.h#n82
-				_debug "capabilities MSR is $capabilities (decimal)"
+				_debug "capacidades MSR é $capabilities (decimal)"
 				[ $(( capabilities >>  0 & 1 )) -eq 1 ] && capabilities_rdcl_no=1
 				[ $(( capabilities >>  1 & 1 )) -eq 1 ] && capabilities_ibrs_all=1
 				[ $(( capabilities >>  2 & 1 )) -eq 1 ] && capabilities_rsba=1
@@ -3495,89 +3495,89 @@ check_cpu()
 				[ $(( capabilities >>  8 & 1 )) -eq 1 ] && capabilities_taa_no=1
 				[ $(( capabilities >> 25 & 1 )) -eq 1 ] && capabilities_gds_ctrl=1
 				[ $(( capabilities >> 26 & 1 )) -eq 1 ] && capabilities_gds_no=1
-				_debug "capabilities says rdcl_no=$capabilities_rdcl_no ibrs_all=$capabilities_ibrs_all rsba=$capabilities_rsba l1dflush_no=$capabilities_l1dflush_no ssb_no=$capabilities_ssb_no mds_no=$capabilities_mds_no taa_no=$capabilities_taa_no pschange_msc_no=$capabilities_pschange_msc_no"
+				_debug "capacidades diz rdcl_no=$capabilities_rdcl_no ibrs_all=$capabilities_ibrs_all rsba=$capabilities_rsba l1dflush_no=$capabilities_l1dflush_no ssb_no=$capabilities_ssb_no mds_no=$capabilities_mds_no taa_no=$capabilities_taa_no pschange_msc_no=$capabilities_pschange_msc_no"
 				if [ "$capabilities_ibrs_all" = 1 ]; then
-					pstatus green YES
+					pstatus green SIM
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 				fi
 			elif [ $ret = $READ_MSR_RET_KO ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 			else
-				pstatus yellow UNKNOWN "$read_msr_msg"
+				pstatus yellow DESCONHECIDO "$read_msr_msg"
 			fi
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by Meltdown/L1TF (RDCL_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada por Meltdown/L1TF (RDCL_NO): "
 		if [ "$capabilities_rdcl_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_rdcl_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by Variant 4 (SSB_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada pela Variante 4 (SSB_NO): "
 		if [ "$capabilities_ssb_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_ssb_no" = 1 ] || [ "$amd_ssb_no" = 1 ] || [ "$hygon_ssb_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * CPU/Hypervisor indicates L1D flushing is not necessary on this system: "
+		_info_nol "  * CPU/Hypervisor indica que a descarga L1D não é necessária neste sistema: "
 		if [ "$capabilities_l1dflush_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_l1dflush_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * Hypervisor indicates host CPU might be affected by RSB underflow (RSBA): "
+		_info_nol "  * O hipervisor indica que a CPU do host pode ser afetada pelo subfluxo de RSB (RSBA): "
 		if [ "$capabilities_rsba" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_rsba" = 1 ]; then
-			pstatus yellow YES
+			pstatus yellow SIM
 		else
-			pstatus blue NO
+			pstatus blue NÃO
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by Microarchitectural Data Sampling (MDS_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada pelo Amostragem de dados microarquiteturais (MDS_NO): "
 		if [ "$capabilities_mds_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_mds_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by TSX Asynchronous Abort (TAA_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada pelo TSX Asynchronous Abort (TAA_NO): "
 		if [ "$capabilities_taa_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_taa_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by iTLB Multihit (PSCHANGE_MSC_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada pelo iTLB Multihit (PSCHANGE_MSC_NO): "
 		if [ "$capabilities_pschange_msc_no" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_pschange_msc_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * CPU explicitly indicates having MSR for TSX control (TSX_CTRL_MSR): "
+		_info_nol "  * CPU indica explicitamente ter MSR para controle TSX (TSX_CTRL_MSR): "
 		if [ "$capabilities_tsx_ctrl_msr" = -1 ]; then
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		elif [ "$capabilities_tsx_ctrl_msr" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
 		if [ "$capabilities_tsx_ctrl_msr" = 1 ]; then
@@ -3588,32 +3588,32 @@ check_cpu()
 				tsx_ctrl_msr_cpuid_clear=$(( tsx_ctrl_msr >> 1 & 1 ))
 			fi
 
-			_info_nol "    * TSX_CTRL MSR indicates TSX RTM is disabled: "
+			_info_nol "    * TSX_CTRL MSR indica que TSX RTM está desabilitado: "
 			if [ "$tsx_ctrl_msr_rtm_disable" = 1 ]; then
-				pstatus blue YES
+				pstatus blue SIM
 			elif [ "$tsx_ctrl_msr_rtm_disable" = 0 ]; then
-				pstatus blue NO
+				pstatus blue NÃO
 			else
-				pstatus yellow UNKNOWN "couldn't read MSR"
+				pstatus yellow DESCONHECIDO "não consegui ler MSR"
 			fi
 
-			_info_nol "    * TSX_CTRL MSR indicates TSX CPUID bit is cleared: "
+			_info_nol "    * TSX_CTRL MSR indica que o bit TSX CPUID está limpo: "
 			if [ "$tsx_ctrl_msr_cpuid_clear" = 1 ]; then
-				pstatus blue YES
+				pstatus blue SIM
 			elif [ "$tsx_ctrl_msr_cpuid_clear" = 0 ]; then
-				pstatus blue NO
+				pstatus blue NÃO
 			else
-				pstatus yellow UNKNOWN "couldn't read MSR"
+				pstatus yellow DESCONHECIDO "não consegui ler MSR"
 			fi
 		fi
 
-		_info_nol "  * CPU explicitly indicates being affected by GDS and having mitigation control (GDS_CTRL): "
+		_info_nol "  * A CPU indica explicitamente ser afetada pelo GDS e ter controle de mitigação (GDS_CTRL): "
 		if [ "$capabilities_gds_ctrl" = -1 ]; then
-			pstatus yellow UNKNOWN "couldn't read MSR"
+			pstatus yellow DESCONHECIDO "não consegui ler MSR"
 		elif [ "$capabilities_gds_ctrl" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus blue NO
+			pstatus blue NÃO
 		fi
 
 		mcu_opt_ctrl_gds_mitg_dis=-1
@@ -3627,60 +3627,60 @@ check_cpu()
 				mcu_opt_ctrl_gds_mitg_lock=$(( mcu_opt_ctrl >> 5 & 1 ))
 			fi
 
-			_info_nol "    * GDS microcode mitigation is disabled (GDS_MITG_DIS): "
+			_info_nol "    * A mitigação do microcódigo GDS está desativada (GDS_MITG_DIS): "
 			if [ "$mcu_opt_ctrl_gds_mitg_dis" = -1 ]; then
-				pstatus yellow UNKNOWN "couldn't read MSR"
+				pstatus yellow DESCONHECIDO "não consegui ler MSR"
 			elif [ "$mcu_opt_ctrl_gds_mitg_dis" = 1 ]; then
-				pstatus yellow YES
+				pstatus yellow SIM
 			else
-				pstatus green NO
+				pstatus green NÃO
 			fi
 
-			_info_nol "    * GDS microcode mitigation is locked in enabled state (GDS_MITG_LOCK): "
+			_info_nol "    * A mitigação do microcódigo GDS está bloqueada no estado habilitado (GDS_MITG_LOCK): "
 			if [ "$mcu_opt_ctrl_gds_mitg_lock" = -1 ]; then
-				pstatus yellow UNKNOWN "couldn't read MSR"
+				pstatus yellow DESCONHECIDO "não consegui ler MSR"
 			elif [ "$mcu_opt_ctrl_gds_mitg_lock" = 1 ]; then
-				pstatus blue YES
+				pstatus blue SIM
 			else
-				pstatus blue NO
+				pstatus blue NÃO
 			fi
 		fi
 
-		_info_nol "  * CPU explicitly indicates not being affected by GDS (GDS_NO): "
+		_info_nol "  * A CPU indica explicitamente que não está sendo afetada pelo GDS (GDS_NO): "
 		if [ "$capabilities_gds_no" = -1 ]; then
-			pstatus yellow UNKNOWN "couldn't read MSR"
+			pstatus yellow DESCONHECIDO "não consegui ler MSR"
 		elif [ "$capabilities_gds_no" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
 	fi
 
 	if is_amd || is_hygon; then
-		_info "  * Selective Branch Predictor Barrier (SBPB)"
-		_info_nol "    * PRED_CMD MSR supports SBPB bit write: "
+		_info "  * Barreira Preditora de Ramo Seletivo (SBPB)"
+		_info_nol "    * PRED_CMD MSR suporta gravação de bits SBPB: "
 
 		if [ "$opt_allow_msr_write" = 1 ]; then
 			# the MSR PRED_SBPB is at offset 0x49, BIT(7), write-only
 			write_msr 0x49 128; ret=$?
 			if [ $ret = $WRITE_MSR_RET_OK ]; then
-				pstatus green YES
+				pstatus green SIM
 				cpuid_sbpb=1
 			elif [ $ret = $WRITE_MSR_RET_KO ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 				cpuid_sbpb=2
 			else
-				pstatus yellow UNKNOWN "$write_msr_msg"
+				pstatus yellow DESCONHECIDO "$write_msr_msg"
 				cpuid_sbpb=3
 			fi
 		else
-			pstatus yellow UNKNOWN "not allowed to write msr"
+			pstatus yellow DESCONHECIDO "não é permitido escrever msr"
 			cpuid_sbpb=3
 		fi
 	fi
 
-	_info_nol "  * CPU supports Transactional Synchronization Extensions (TSX): "
+	_info_nol "  * A CPU suporta extensões de sincronização transacional (TSX): "
 	ret=$READ_CPUID_RET_KO
 	cpuid_rtm=0
 	if is_intel; then
@@ -3688,31 +3688,31 @@ check_cpu()
 	fi
 	if [ $ret = $READ_CPUID_RET_OK ]; then
 		cpuid_rtm=1
-		pstatus green YES "RTM feature bit"
+		pstatus green SIM "Bit de recurso RTM"
 	elif [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
 		cpuid_rtm=-1
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 	fi
 
-	_info_nol "  * CPU supports Software Guard Extensions (SGX): "
+	_info_nol "  * CPU suporta Extensões de proteção de software (SGX): "
 	ret=$READ_CPUID_RET_KO
 	cpuid_sgx=0
 	if is_intel; then
 		read_cpuid 0x7 0x0 $EBX 2 1 1; ret=$?
 	fi
 	if [ $ret = $READ_CPUID_RET_OK ]; then
-		pstatus blue YES
+		pstatus blue SIM
 		cpuid_sgx=1
 	elif [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus green NO
+		pstatus green NÃO
 	else
 		cpuid_sgx=-1
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 	fi
 
-	_info_nol "  * CPU supports Special Register Buffer Data Sampling (SRBDS): "
+	_info_nol "  * CPU suporta Amostragem de dados de buffer de registro especial (SRBDS): "
 	# A processor supports SRBDS if it enumerates CPUID (EAX=7H,ECX=0):EDX[9] as 1
 	# That means the mitigation disabling SRBDS exists
 	ret=$READ_CPUID_RET_KO
@@ -3722,7 +3722,7 @@ check_cpu()
 		read_cpuid 0x7 0x0 $EDX 9 1 1; ret=$?
 	fi
 	if [ $ret = $READ_CPUID_RET_OK ]; then
-		pstatus blue YES
+		pstatus blue SIM
 		cpuid_srbds=1
 		read_msr 0x123; ret=$?
 		if [ $ret = $READ_MSR_RET_OK ]; then
@@ -3737,60 +3737,60 @@ check_cpu()
 			srbds_on=-1
 		fi
 	elif [ $ret = $READ_CPUID_RET_KO ]; then
-		pstatus green NO
+		pstatus green NÃO
 	else
-		pstatus yellow UNKNOWN "$read_cpuid_msg"
+		pstatus yellow DESCONHECIDO "$read_cpuid_msg"
 		cpuid_srbds=0
 	fi
 
 	if is_amd; then
-		_info_nol "  * CPU microcode is known to fix Zenbleed: "
+		_info_nol "  * O microcódigo da CPU é conhecido por corrigir o Zenbleed: "
 		has_zenbleed_fixed_firmware; ret=$?
 		if [ $ret -eq 0 ]; then
 			# affected CPU, new fw
-			pstatus green YES
+			pstatus green SIM
 		elif [ $ret -eq 1 ]; then
 			# affected CPU, old fw
-			pstatus red NO "required version: $zenbleed_fw_required"
+			pstatus red NÃO "versão necessária: $zenbleed_fw_required"
 		else
 			# unaffected CPU
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 	fi
 
-	_info_nol "  * CPU microcode is known to cause stability problems: "
+	_info_nol "  * Sabe-se que o microcódigo da CPU causa problemas de estabilidade: "
 	if is_ucode_blacklisted; then
-		pstatus red YES "$ucode_found"
+		pstatus red SIM "$ucode_found"
 		_warn
-		_warn "The microcode your CPU is running on is known to cause instability problems,"
-		_warn "such as intempestive reboots or random crashes."
-		_warn "You are advised to either revert to a previous microcode version (that might not have"
-		_warn "the mitigations for recent vulnerabilities), or upgrade to a newer one if available."
+		_warn "Sabe-se que o microcódigo em que sua CPU está sendo executada causa problemas de instabilidade,"
+		_warn "como reinicializações intempestivas ou falhas aleatórias."
+		_warn "Recomenda-se reverter para uma versão anterior do microcódigo (que pode não ter"
+		_warn "atenuações para Spectre) ou atualize para uma mais nova, se disponível."
 		_warn
 	else
-		pstatus blue NO "$ucode_found"
+		pstatus blue NÃO "$ucode_found"
 	fi
 
-	_info_nol "  * CPU microcode is the latest known available version: "
+	_info_nol "  * O microcódigo da CPU é a versão disponível mais recente conhecida: "
 	is_latest_known_ucode; ret=$?
 	if [ $ret -eq 0 ]; then
-		pstatus green YES "$ucode_latest"
+		pstatus green SIM "$ucode_latest"
 	elif [ $ret -eq 1 ]; then
-		pstatus red NO "$ucode_latest"
+		pstatus red NÃO "$ucode_latest"
 	else
-		pstatus blue UNKNOWN "$ucode_latest"
+		pstatus blue DESCONHECIDO "$ucode_latest"
 	fi
 }
 
 check_cpu_vulnerabilities()
 {
-	_info     "* CPU vulnerability to the speculative execution attack variants"
+	_info     "* Vulnerabilidade da CPU às variantes de ataque de execução especulativa"
 	for cve in $supported_cve_list; do
-		_info_nol "  * Affected by $cve ($(cve2name "$cve")): "
+		_info_nol "  * Afetado por $cve ($(cve2name "$cve")): "
 		if is_cpu_affected "$cve"; then
-			pstatus yellow YES
+			pstatus yellow SIM
 		else
-			pstatus green NO
+			pstatus green NÃO
 		fi
 	done
 }
@@ -3810,12 +3810,12 @@ check_redhat_canonical_spectre()
 		if "${opt_arch_prefix}strings" "$kernel" | grep -qw noibrs && "${opt_arch_prefix}strings" "$kernel" | grep -qw noibpb; then
 			# 1) detect their specific variant2 patch. If it's present, it means
 			# that the variant1 patch is also present (both were merged at the same time)
-			_debug "found redhat/canonical version of the variant2 patch (implies variant1)"
+			_debug "versão redhat/canonical encontrada do patch variant2 (implica variant1)"
 			redhat_canonical_spectre=1
 		elif "${opt_arch_prefix}strings" "$kernel" | grep -q 'x86/pti:'; then
 			# 2) detect their specific variant3 patch. If it's present, but the variant2
 			# is not, it means that only variant1 is present in addition to variant3
-			_debug "found redhat/canonical version of the variant3 patch (implies variant1 but not variant2)"
+			_debug "versão redhat/canonical encontrada do patch variant3 (implica na variante1, mas não na variante2)"
 			redhat_canonical_spectre=2
 		else
 			redhat_canonical_spectre=0
@@ -3825,7 +3825,7 @@ check_redhat_canonical_spectre()
 
 check_has_vmm()
 {
-	_info_nol "* This system is a host running a hypervisor: "
+	_info_nol "* Este sistema é um host executando um hypervisor: "
 	has_vmm=$opt_vmm
 	if [ "$has_vmm" = -1 ] && [ "$opt_paranoid" = 1 ]; then
 		# In paranoid mode, if --vmm was not specified on the command-line,
@@ -3850,7 +3850,7 @@ check_has_vmm()
 					# is null, which is the case for kernel threads: ignore those to
 					# avoid false positives (such as [kvm-irqfd-clean] under at least RHEL 7.6/7.7)
 					if ! [ "$(readlink -m "/proc/$_pid/exe")" = "/proc/$_pid/exe" ]; then
-						_debug "has_vmm: found PID $_pid"
+						_debug "has_vmm: PID $_pid encontrado"
 						has_vmm=1
 					fi
 				done
@@ -3866,17 +3866,17 @@ check_has_vmm()
 	fi
 	if [ "$has_vmm" = 0 ]; then
 		if [ "$opt_vmm" != -1 ]; then
-			pstatus green NO "forced from command line"
+			pstatus green NÃO "forçado a partir da linha de comando"
 		else
-			pstatus green NO
+			pstatus green NÃO
 		fi
 	else
 		if [ "$opt_vmm" != -1 ]; then
-			pstatus blue YES "forced from command line"
+			pstatus blue SIM "forçado a partir da linha de comando"
 		elif [ "$has_vmm" = 2 ]; then
-			pstatus blue YES "paranoid mode"
+			pstatus blue SIM "modo paranóico"
 		else
-			pstatus blue YES
+			pstatus blue SIM
 		fi
 	fi
 }
@@ -3888,19 +3888,19 @@ check_has_vmm()
 check_CVE_2017_5753()
 {
 	cve='CVE-2017-5753'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2017_5753_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2017_5753_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2017_5753_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/spectre_v1"; then
@@ -3912,7 +3912,7 @@ check_CVE_2017_5753_linux()
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
 		# no /sys interface (or offline mode), fallback to our own ways
-		_info_nol "* Kernel has array_index_mask_nospec: "
+		_info_nol "* O kernel possui array_index_mask_nospec: "
 		# vanilla: look for the Linus' mask aka array_index_mask_nospec()
 		# that is inlined at least in raw_copy_from_user (__get_user_X symbols)
 		#mov PER_CPU_VAR(current_task), %_ASM_DX
@@ -3942,46 +3942,46 @@ check_CVE_2017_5753_linux()
 		# http://git.arm.linux.org.uk/cgit/linux-arm.git/commit/?h=spectre&id=a78d156587931a2c3b354534aa772febf6c9e855
 		v1_mask_nospec=''
 		if [ -n "$kernel_err" ]; then
-			pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+			pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 		elif ! command -v perl >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing 'perl' binary, please install it"
+			pstatus yellow DESCONHECIDO "binário 'perl' ausente, instale-o"
 		else
 			perl -ne '/\x0f\x83....\x48\x19\xd2\x48\x21\xd0/ and $found++; END { exit($found) }' "$kernel"; ret=$?
 			if [ $ret -gt 0 ]; then
-				pstatus green YES "$ret occurrence(s) found of x86 64 bits array_index_mask_nospec()"
+				pstatus green SIM "$ret ocorrência (s) encontrada (s) de x86 64 bits array_index_mask_nospec()"
 				v1_mask_nospec="x86 64 bits array_index_mask_nospec"
 			else
 				perl -ne '/\x3b\x82..\x00\x00\x73.\x19\xd2\x21\xd0/ and $found++; END { exit($found) }' "$kernel"; ret=$?
 				if [ $ret -gt 0 ]; then
-					pstatus green YES "$ret occurrence(s) found of x86 32 bits array_index_mask_nospec()"
+					pstatus green SIM "$ret ocorrência (s) encontrada (s) de x86 32 bits array_index_mask_nospec()"
 					v1_mask_nospec="x86 32 bits array_index_mask_nospec"
 				else
 					ret=$("${opt_arch_prefix}objdump" $objdump_options "$kernel" | grep -w -e f3af8014 -e e320f014 -B2 | grep -B1 -w sbc | grep -w -c cmp)
 					if [ "$ret" -gt 0 ]; then
-						pstatus green YES "$ret occurrence(s) found of arm 32 bits array_index_mask_nospec()"
+						pstatus green SIM "$ret ocorrência (s) encontrada (s) do braço de 32 bits array_index_mask_nospec()"
 						v1_mask_nospec="arm 32 bits array_index_mask_nospec"
 					else
-						pstatus yellow NO
+						pstatus yellow NÃO
 					fi
 				fi
 			fi
 		fi
 
-		_info_nol "* Kernel has the Red Hat/Ubuntu patch: "
+		_info_nol "* O kernel possui o patch Red Hat/Ubuntu: "
 		check_redhat_canonical_spectre
 		if [ "$redhat_canonical_spectre" = -1 ]; then
-			pstatus yellow UNKNOWN "missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package"
+			pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}strings', instale-a, geralmente está no pacote binutils"
 		elif [ "$redhat_canonical_spectre" = -2 ]; then
-			pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+			pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 		elif [ "$redhat_canonical_spectre" = 1 ]; then
-			pstatus green YES
+			pstatus green SIM
 		elif [ "$redhat_canonical_spectre" = 2 ]; then
-			pstatus green YES "but without IBRS"
+			pstatus green SIM "mas sem IBRS"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "* Kernel has mask_nospec64 (arm64): "
+		_info_nol "* O kernel possui mask_nospec64 (arm64): "
 		#.macro	mask_nospec64, idx, limit, tmp
 		#sub	\tmp, \idx, \limit
 		#bic	\tmp, \tmp, \idx
@@ -3997,24 +3997,24 @@ check_CVE_2017_5753_linux()
 		#
 		# if we have v1_mask_nospec or redhat_canonical_spectre>0, don't bother disassembling the kernel, the answer is no.
 		if [ -n "$v1_mask_nospec" ] || [ "$redhat_canonical_spectre" -gt 0 ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		elif [ -n "$kernel_err" ]; then
-			pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+			pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 		elif ! command -v perl >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing 'perl' binary, please install it"
+			pstatus yellow DESCONHECIDO "falta o binário 'perl', instale-o"
 		elif ! command -v "${opt_arch_prefix}objdump" >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package"
+			pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}objdump', instale-a, geralmente está no pacote binutils"
 		else
 			"${opt_arch_prefix}objdump" $objdump_options "$kernel" | perl -ne 'push @r, $_; /\s(hint|csdb)\s/ && $r[0]=~/\ssub\s+(x\d+)/ && $r[1]=~/\sbic\s+$1,\s+$1,/ && $r[2]=~/\sand\s/ && exit(9); shift @r if @r>3'; ret=$?
 			if [ "$ret" -eq 9 ]; then
-				pstatus green YES "mask_nospec64 macro is present and used"
+				pstatus green SIM "macro mask_nospec64 está presente e é usada"
 				v1_mask_nospec="arm64 mask_nospec64"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		fi
 
-		_info_nol "* Kernel has array_index_nospec (arm64): "
+		_info_nol "* Kernel tem array_index_nospec (arm64): "
 		# in 4.19+ kernels, the mask_nospec64 asm64 macro is replaced by array_index_nospec, defined in nospec.h, and used in invoke_syscall()
 		# ffffff8008090a4c:       2a0203e2        mov     w2, w2
 		# ffffff8008090a50:       eb0200bf        cmp     x5, x2
@@ -4024,32 +4024,32 @@ check_CVE_2017_5753_linux()
 		#
 		# if we have v1_mask_nospec or redhat_canonical_spectre>0, don't bother disassembling the kernel, the answer is no.
 		if [ -n "$v1_mask_nospec" ] || [ "$redhat_canonical_spectre" -gt 0 ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		elif [ -n "$kernel_err" ]; then
-			pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+			pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 		elif ! command -v perl >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing 'perl' binary, please install it"
+			pstatus yellow DESCONHECIDO "falta o binário 'perl', instale-o"
 		elif ! command -v "${opt_arch_prefix}objdump" >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package"
+			pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}objdump', instale-a, geralmente está no pacote binutils"
 		else
 			"${opt_arch_prefix}objdump" -d "$kernel" | perl -ne 'push @r, $_; /\s(hint|csdb)\s/ && $r[0]=~/\smov\s+(w\d+),\s+(w\d+)/ && $r[1]=~/\scmp\s+(x\d+),\s+(x\d+)/ && $r[2]=~/\sngc\s+$2,/ && exit(9); shift @r if @r>3'; ret=$?
 			if [ "$ret" -eq 9 ]; then
-				pstatus green YES "array_index_nospec macro is present and used"
+				pstatus green SIM "macro array_index_nospec está presente e é usado"
 				v1_mask_nospec="arm64 array_index_nospec"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		fi
 
 		if [ "$opt_verbose" -ge 2 ] || { [ -z "$v1_mask_nospec" ] && [ "$redhat_canonical_spectre" != 1 ] && [ "$redhat_canonical_spectre" != 2 ]; }; then
 			# this is a slow heuristic and we don't need it if we already know the kernel is patched
 			# but still show it in verbose mode
-			_info_nol "* Checking count of LFENCE instructions following a jump in kernel... "
+			_info_nol "* Verificando a contagem de instruções LFENCE após um salto no kernel... "
 			if [ -n "$kernel_err" ]; then
-				pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+				pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 			else
 				if ! command -v "${opt_arch_prefix}objdump" >/dev/null 2>&1; then
-					pstatus yellow UNKNOWN "missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package"
+					pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}objdump', por favor instale-o, geralmente está no pacote binutils"
 				else
 					# here we disassemble the kernel and count the number of occurrences of the LFENCE opcode
 					# in non-patched kernels, this has been empirically determined as being around 40-50
@@ -4060,10 +4060,10 @@ check_CVE_2017_5753_linux()
 					# non patched kernel have between 0 and 20 matches, patched ones have at least 40-45
 					nb_lfence=$("${opt_arch_prefix}objdump" $objdump_options "$kernel" 2>/dev/null | grep -w -B1 lfence | grep -Ewc 'jmp|jne|je')
 					if [ "$nb_lfence" -lt 30 ]; then
-						pstatus yellow NO "only $nb_lfence jump-then-lfence instructions found, should be >= 30 (heuristic)"
+						pstatus yellow NÃO "apenas $nb_lfence jump-then-lfence instruções encontradas, devem ser >= 30 (heurística)"
 					else
 						v1_lfence=1
-						pstatus green YES "$nb_lfence jump-then-lfence instructions found, which is >= 30 (heuristic)"
+						pstatus green SIM "$nb_lfence jump-then-lfence instruções encontradas, devem ser >= 30 (heurística)"
 					fi
 				fi
 			fi
@@ -4071,36 +4071,36 @@ check_CVE_2017_5753_linux()
 
 	else
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="A interface de vulnerabilidade /sys usa forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	# report status
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU não é afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ -n "$v1_mask_nospec" ]; then
-			pvulnstatus $cve OK "Kernel source has been patched to mitigate the vulnerability ($v1_mask_nospec)"
+			pvulnstatus $cve OK "A fonte do kernel foi corrigida para mitigar a vulnerabilidade ($v1_mask_nospec)"
 		elif [ "$redhat_canonical_spectre" = 1 ] || [ "$redhat_canonical_spectre" = 2 ]; then
-			pvulnstatus $cve OK "Kernel source has been patched to mitigate the vulnerability (Red Hat/Ubuntu patch)"
+			pvulnstatus $cve OK "A fonte do kernel foi corrigida para mitigar a vulnerabilidade (patch Red Hat/Ubuntu)"
 		elif [ "$v1_lfence" = 1 ]; then
-			pvulnstatus $cve OK "Kernel source has PROBABLY been patched to mitigate the vulnerability (jump-then-lfence instructions heuristic)"
+			pvulnstatus $cve OK "A fonte do kernel PROVAVELMENTE foi corrigida para mitigar a vulnerabilidade (heurística de instruções jump-then-lfence)"
 		elif [ -n "$kernel_err" ]; then
-			pvulnstatus $cve UNK "Couldn't find kernel image or tools missing to execute the checks"
-			explain "Re-run this script with root privileges, after installing the missing tools indicated above"
+			pvulnstatus $cve DES "Não foi possível encontrar a imagem do kernel ou ferramentas faltando para executar as verificações"
+			explain "Execute novamente este script com privilégios de root, após instalar as ferramentas ausentes indicadas acima"
 		else
-			pvulnstatus $cve VULN "Kernel source needs to be patched to mitigate the vulnerability"
-			explain "Your kernel is too old to have the mitigation for Variant 1, you should upgrade to a newer kernel. If you're using a Linux distro and didn't compile the kernel yourself, you should upgrade your distro to get a newer kernel."
+			pvulnstatus $cve VULN "A fonte do kernel precisa ser corrigida para mitigar a vulnerabilidade"
+			explain "Seu kernel é muito antigo para ter a mitigação da Variante 1, você deve atualizar para um kernel mais novo. Se você está usando uma distribuição Linux e não compilou o kernel por conta própria, atualize sua distribuição para obter um kernel mais novo."
 		fi
 	else
 		if [ "$msg" = "Vulnerable" ] && [ -n "$v1_mask_nospec" ]; then
-			pvulnstatus $cve OK "Kernel source has been patched to mitigate the vulnerability (silent backport of array_index_mask_nospec)"
+			pvulnstatus $cve OK "A fonte do kernel foi corrigida para mitigar a vulnerabilidade (backport silencioso de array_index_mask_nospec)"
 		else
 			if [ "$msg" = "Vulnerable" ]; then
-				msg="Kernel source needs to be patched to mitigate the vulnerability"
-				_explain="Your kernel is too old to have the mitigation for Variant 1, you should upgrade to a newer kernel. If you're using a Linux distro and didn't compile the kernel yourself, you should upgrade your distro to get a newer kernel."
+				msg="A fonte do kernel precisa ser corrigida para mitigar a vulnerabilidade"
+				_explain="Seu kernel é muito antigo para ter a mitigação da Variante 1, você deve atualizar para um kernel mais novo. Se você está usando uma distribuição Linux e não compilou o kernel por conta própria, atualize sua distribuição para obter um kernel mais novo."
 			fi
 			pvulnstatus $cve "$status" "$msg"
 			[ -n "${_explain:-}" ] && explain "$_explain"
@@ -4113,9 +4113,9 @@ check_CVE_2017_5753_bsd()
 {
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU não é afetado"
 	else
-		pvulnstatus $cve VULN "no mitigation for BSD yet"
+		pvulnstatus $cve VULN "nenhuma mitigação para BSD ainda"
 	fi
 }
 
@@ -4126,19 +4126,19 @@ check_CVE_2017_5753_bsd()
 check_CVE_2017_5715()
 {
 	cve='CVE-2017-5715'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2017_5715_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2017_5715_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2017_5715_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/spectre_v2"; then
@@ -4146,7 +4146,7 @@ check_CVE_2017_5715_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info "* Mitigation 1"
+		_info "* Mitigação 1"
 
 		ibrs_can_tell=0
 		ibrs_supported=''
@@ -4170,21 +4170,21 @@ check_CVE_2017_5715_linux()
 					# /sys/kernel/debug/x86/ibrs_enabled: Red Hat (see https://access.redhat.com/articles/3311301)
 					# /proc/sys/kernel/ibrs_enabled: OpenSUSE tumbleweed
 					specex_knob_dir=$dir
-					ibrs_supported="$dir/ibrs_enabled exists"
+					ibrs_supported="$dir/ibrs_enabled existe"
 					ibrs_enabled=$(cat "$dir/ibrs_enabled" 2>/dev/null)
-					_debug "ibrs: found $dir/ibrs_enabled=$ibrs_enabled"
+					_debug "ibrs: encontrado $dir/ibrs_enabled=$ibrs_enabled"
 					# if ibrs_enabled is there, ibpb_enabled will be in the same dir
 					if [ -e "$dir/ibpb_enabled" ]; then
 						# if the file is there, we have IBPB compiled-in (see note above for IBRS)
-						ibpb_supported="$dir/ibpb_enabled exists"
+						ibpb_supported="$dir/ibpb_enabled existe"
 						ibpb_enabled=$(cat "$dir/ibpb_enabled" 2>/dev/null)
-						_debug "ibpb: found $dir/ibpb_enabled=$ibpb_enabled"
+						_debug "ibpb: encontrado $dir/ibpb_enabled=$ibpb_enabled"
 					else
-						_debug "ibpb: $dir/ibpb_enabled file doesn't exist"
+						_debug "ibpb: $dir/ibpb_enabled arquivo não existe"
 					fi
 					break
 				else
-					_debug "ibrs: $dir/ibrs_enabled file doesn't exist"
+					_debug "ibrs: $dir/ibrs_enabled arquivo não existe"
 				fi
 			done
 			# on some newer kernels, the spec_ctrl_ibrs flag in "$procfs/cpuinfo"
@@ -4193,8 +4193,8 @@ check_CVE_2017_5715_linux()
 			# as per the ibrs patch series v3
 			if [ -z "$ibrs_supported" ]; then
 				if grep ^flags "$procfs/cpuinfo" | grep -qw spec_ctrl_ibrs; then
-					_debug "ibrs: found spec_ctrl_ibrs flag in $procfs/cpuinfo"
-					ibrs_supported="spec_ctrl_ibrs flag in $procfs/cpuinfo"
+					_debug "ibrs: encontrado o sinalizador spec_ctrl_ibrs em $procfs/cpuinfo"
+					ibrs_supported="sinalizador spec_ctrl_ibrs em $procfs/cpuinfo"
 					# enabled=2 -> kernel & user
 					ibrs_enabled=2
 					# XXX and what about ibpb ?
@@ -4203,27 +4203,27 @@ check_CVE_2017_5715_linux()
 			if [ -n "$fullmsg" ]; then
 				# when IBPB is enabled on 4.15+, we can see it in sysfs
 				if echo "$fullmsg" | grep -q 'IBPB'; then
-					_debug "ibpb: found enabled in sysfs"
-					[ -z "$ibpb_supported" ] && ibpb_supported='IBPB found enabled in sysfs'
+					_debug "ibpb: encontrado habilitado no sysfs"
+					[ -z "$ibpb_supported" ] && ibpb_supported='IBPB encontrado habilitado no sysfs'
 					[ -z "$ibpb_enabled"   ] && ibpb_enabled=1
 				fi
 				# when IBRS_FW is enabled on 4.15+, we can see it in sysfs
 				if echo "$fullmsg" | grep -q ', IBRS_FW'; then
-					_debug "ibrs: found IBRS_FW in sysfs"
-					[ -z "$ibrs_supported" ] && ibrs_supported='found IBRS_FW in sysfs'
+					_debug "ibrs: encontrado IBRS_FW em sysfs"
+					[ -z "$ibrs_supported" ] && ibrs_supported='encontrado IBRS_FW em sysfs'
 					ibrs_fw_enabled=1
 				fi
 				# when IBRS is enabled on 4.15+, we can see it in sysfs
 				# on a more recent kernel, classic "IBRS" is not even longer an option, because of the performance impact.
 				# only "Enhanced IBRS" is available (on CPUs with the IBRS_ALL flag)
 				if echo "$fullmsg" | grep -q -e '\<IBRS\>' -e 'Indirect Branch Restricted Speculation'; then
-					_debug "ibrs: found IBRS in sysfs"
-					[ -z "$ibrs_supported" ] && ibrs_supported='found IBRS in sysfs'
+					_debug "ibrs: encontrado IBRS em sysfs"
+					[ -z "$ibrs_supported" ] && ibrs_supported='encontrado IBRS em sysfs'
 					[ -z "$ibrs_enabled"   ] && ibrs_enabled=3
 				fi
 				# checking for 'Enhanced IBRS' in sysfs, enabled on CPUs with IBRS_ALL
 				if echo "$fullmsg" | grep -q -e 'Enhanced IBRS'; then
-					[ -z "$ibrs_supported" ] && ibrs_supported='found Enhanced IBRS in sysfs'
+					[ -z "$ibrs_supported" ] && ibrs_supported='encontrado IBRS aprimorado em sysfs'
 					# 4 isn't actually a valid value of the now extinct "ibrs_enabled" flag file,
 					# that only went from 0 to 3, so we use 4 as "enhanced ibrs is enabled"
 					ibrs_enabled=4
@@ -4236,8 +4236,8 @@ check_CVE_2017_5715_linux()
 		if [ -z "$ibrs_supported" ]; then
 			check_redhat_canonical_spectre
 			if [ "$redhat_canonical_spectre" = 1 ]; then
-				ibrs_supported="Red Hat/Ubuntu variant"
-				ibpb_supported="Red Hat/Ubuntu variant"
+				ibrs_supported="Variante Red Hat/Ubuntu"
+				ibpb_supported="Variante Red Hat/Ubuntu"
 			fi
 		fi
 		if [ -z "$ibrs_supported" ] && [ -n "$kernel" ]; then
@@ -4247,16 +4247,16 @@ check_CVE_2017_5715_linux()
 				ibrs_can_tell=1
 				ibrs_supported=$("${opt_arch_prefix}strings" "$kernel" | grep -Fw -e ', IBRS_FW' | head -1)
 				if [ -n "$ibrs_supported" ]; then
-					_debug "ibrs: found ibrs evidence in kernel image ($ibrs_supported)"
-					ibrs_supported="found '$ibrs_supported' in kernel image"
+					_debug "ibrs: encontrou evidências de ibrs na imagem do kernel ($ibrs_supported)"
+					ibrs_supported="encontrado '$ibrs_supported' na imagem do kernel"
 				fi
 			fi
 		fi
 		if [ -z "$ibrs_supported" ] && [ -n "$opt_map" ]; then
 			ibrs_can_tell=1
 			if grep -q spec_ctrl "$opt_map"; then
-				ibrs_supported="found spec_ctrl in symbols file"
-				_debug "ibrs: found '*spec_ctrl*' symbol in $opt_map"
+				ibrs_supported="encontrado spec_ctrl no arquivo de símbolos"
+				_debug "ibrs: encontrado o símbolo '*spec_ctrl*' em $opt_map"
 			fi
 		fi
 		# recent (4.15) vanilla kernels have IBPB but not IBRS, and without the debugfs tunables of Red Hat
@@ -4268,35 +4268,35 @@ check_CVE_2017_5715_linux()
 				ibpb_can_tell=1
 				ibpb_supported=$("${opt_arch_prefix}strings" "$kernel" | grep -Fw -e 'ibpb' -e ', IBPB' | head -1)
 				if [ -n "$ibpb_supported" ]; then
-					_debug "ibpb: found ibpb evidence in kernel image ($ibpb_supported)"
-					ibpb_supported="found '$ibpb_supported' in kernel image"
+					_debug "ibpb: encontrou evidências ibpb na imagem do kernel ($ibpb_supported)"
+					ibpb_supported="encontrado '$ibpb_supported' na imagem do kernel"
 				fi
 			fi
 		fi
 
-		_info_nol "  * Kernel is compiled with IBRS support: "
+		_info_nol "  * O kernel é compilado com o suporte do IBRS: "
 		if [ -z "$ibrs_supported" ]; then
 			if [ "$ibrs_can_tell" = 1 ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 			else
 				# problem obtaining/inspecting kernel or strings not installed, but if the later is true,
 				# then readelf is not installed either (both in binutils) which makes the former true, so
 				# either way kernel_err should be set
-				pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+				pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 			fi
 		else
 			if [ "$opt_verbose" -ge 2 ]; then
-				pstatus green YES "$ibrs_supported"
+				pstatus green SIM "$ibrs_supported"
 			else
-				pstatus green YES
+				pstatus green SIM
 			fi
 		fi
 
-		_info_nol "    * IBRS enabled and active: "
+		_info_nol "    * IBRS ativado e ativo: "
 		if [ "$opt_live" = 1 ]; then
 			if [ "$ibpb_enabled" = 2 ]; then
 				# if ibpb=2, ibrs is forcefully=0
-				pstatus blue NO "IBPB used instead of IBRS in all kernel entrypoints"
+				pstatus blue NÃO "IBPB usado em vez do IBRS em todos os pontos de entrada do kernel"
 			else
 				# 0 means disabled
 				# 1 is enabled only for kernel space
@@ -4306,104 +4306,104 @@ check_CVE_2017_5715_linux()
 				case "$ibrs_enabled" in
 					0)
 						if [ "$ibrs_fw_enabled" = 1 ]; then
-							pstatus blue YES "for firmware code only"
+							pstatus blue SIM "apenas para código de firmware"
 						else
-							pstatus yellow NO
+							pstatus yellow NÃO
 						fi
 						;;
-					1)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green YES "for kernel space and firmware code"; else pstatus green YES "for kernel space"; fi;;
-					2)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green YES "for kernel, user space, and firmware code" ; else pstatus green YES "for both kernel and user space"; fi;;
-					3)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green YES "for kernel and firmware code"; else pstatus green YES; fi;;
-					4)	pstatus green YES "Enhanced flavor, performance impact will be greatly reduced";;
+					1)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green SIM "para espaço no kernel e código de firmware"; else pstatus green SIM "para espaço no kernel"; fi;;
+					2)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green SIM "para kernel, espaço do usuário e código de firmware" ; else pstatus green SIM "para o kernel e o espaço do usuário"; fi;;
+					3)	if [ "$ibrs_fw_enabled" = 1 ]; then pstatus green SIM "para código de kernel e firmware"; else pstatus green SIM; fi;;
+					4)	pstatus green SIM "Sabor aprimorado, o impacto no desempenho será bastante reduzido";;
 					*)	if [ "$cpuid_ibrs" != 'SPEC_CTRL' ] && [ "$cpuid_ibrs" != 'IBRS_SUPPORT' ] && [ "$cpuid_spec_ctrl" != -1 ]; 
-							then pstatus yellow NO; _debug "ibrs: known cpu not supporting SPEC-CTRL or IBRS"; 
+							then pstatus yellow NÃO; _debug "ibrs: CPU conhecida que não suporta SPEC-CTRL ou IBRS"; 
 						else 
-							pstatus yellow UNKNOWN; fi;;
+							pstatus yellow DESCONHECIDO; fi;;
 				esac
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info_nol "  * Kernel is compiled with IBPB support: "
+		_info_nol "  * O kernel é compilado com suporte ao IBPB: "
 		if [ -z "$ibpb_supported" ]; then
 			if [ "$ibpb_can_tell" = 1 ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 			else
 				# if we're in offline mode without System.map, we can't really know
-				pstatus yellow UNKNOWN "in offline mode, we need the kernel image to be able to tell"
+				pstatus yellow DESCONHECIDO "no modo offline, precisamos da imagem do kernel para poder dizer"
 			fi
 		else
 			if [ "$opt_verbose" -ge 2 ]; then
-				pstatus green YES "$ibpb_supported"
+				pstatus green SIM "$ibpb_supported"
 			else
-				pstatus green YES
+				pstatus green SIM
 			fi
 		fi
 
-		_info_nol "    * IBPB enabled and active: "
+		_info_nol "    * IBPB ativado e ativo: "
 		if [ "$opt_live" = 1 ]; then
 			case "$ibpb_enabled" in
 				"")
 					if [ "$ibrs_supported" = 1 ]; then
-						pstatus yellow UNKNOWN
+						pstatus yellow DESCONHECIDO
 					else
-						pstatus yellow NO
+						pstatus yellow NÃO
 					fi
 					;;
 				0)
-					pstatus yellow NO
+					pstatus yellow NÃO
 					;;
-				1) pstatus green YES;;
-				2) pstatus green YES "IBPB used instead of IBRS in all kernel entrypoints";;
-				*) pstatus yellow UNKNOWN;;
+				1) pstatus green SIM;;
+				2) pstatus green SIM "IBPB usado em vez do IBRS em todos os pontos de entrada do kernel";;
+				*) pstatus yellow DESCONHECIDO;;
 			esac
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info "* Mitigation 2"
-		_info_nol "  * Kernel has branch predictor hardening (arm): "
+		_info "* Mitigação 2"
+		_info_nol "  * Kernel tem proteção do preditor de ramificação (arm): "
 		bp_harden_can_tell=0
 		bp_harden=''
 		if [ -r "$opt_config" ]; then
 			bp_harden_can_tell=1
 			bp_harden=$(grep -w 'CONFIG_HARDEN_BRANCH_PREDICTOR=y' "$opt_config")
 			if [ -n "$bp_harden" ]; then
-				pstatus green YES
-				_debug "bp_harden: found '$bp_harden' in $opt_config"
+				pstatus green SIM
+				_debug "bp_harden: encontrado '$bp_harden' em $opt_config"
 			fi
 		fi
 		if [ -z "$bp_harden" ] && [ -n "$opt_map" ]; then
 			bp_harden_can_tell=1
 			bp_harden=$(grep -w bp_hardening_data "$opt_map")
 			if [ -n "$bp_harden" ]; then
-				pstatus green YES
-				_debug "bp_harden: found '$bp_harden' in $opt_map"
+				pstatus green SIM
+				_debug "bp_harden: encontrado '$bp_harden' em $opt_map"
 			fi
 		fi
 		if [ -z "$bp_harden" ]; then
 			if [ "$bp_harden_can_tell" = 1 ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 			else
-				pstatus yellow UNKNOWN
+				pstatus yellow DESCONHECIDO
 			fi
 		fi
 
-		_info_nol "  * Kernel compiled with retpoline option: "
+		_info_nol "  * Kernel compilado com a opção retpoline: "
 		# We check the RETPOLINE kernel options
 		retpoline=0
 		if [ -r "$opt_config" ]; then
 			if grep -q '^CONFIG_RETPOLINE=y' "$opt_config"; then
-				pstatus green YES
+				pstatus green SIM
 				retpoline=1
 				# shellcheck disable=SC2046
-				_debug 'retpoline: found '$(grep '^CONFIG_RETPOLINE' "$opt_config")" in $opt_config"
+				_debug 'retpoline: encontrado '$(grep '^CONFIG_RETPOLINE' "$opt_config")" em $opt_config"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		else
-			pstatus yellow UNKNOWN "couldn't read your kernel configuration"
+			pstatus yellow DESCONHECIDO "não conseguiu ler a configuração do seu kernel"
 		fi
 
 		if [ "$retpoline" = 1 ]; then
@@ -4422,17 +4422,17 @@ check_CVE_2017_5715_linux()
 				if echo "$fullmsg" | grep -qwi -e retpoline -e retpolines; then
 					if echo "$fullmsg" | grep -qwi minimal; then
 						retpoline_compiler=0
-						retpoline_compiler_reason="kernel reports minimal retpoline compilation"
+						retpoline_compiler_reason="O kernel relata compilação mínima de retpoline"
 					else
 						retpoline_compiler=1
-						retpoline_compiler_reason="kernel reports full retpoline compilation"
+						retpoline_compiler_reason="relatórios do kernel compilação completa do retpoline"
 					fi
 				fi
 			elif [ -n "$opt_map" ]; then
 				# look for the symbol
 				if grep -qw noretpoline_setup "$opt_map"; then
 					retpoline_compiler=1
-					retpoline_compiler_reason="noretpoline_setup symbol found in System.map"
+					retpoline_compiler_reason="símbolo noretpoline_setup encontrado em System.map"
 				fi
 			elif [ -n "$kernel" ]; then
 				# look for the symbol
@@ -4440,28 +4440,28 @@ check_CVE_2017_5715_linux()
 					# the proper way: use nm and look for the symbol
 					if "${opt_arch_prefix}nm" "$kernel" 2>/dev/null | grep -qw 'noretpoline_setup'; then
 						retpoline_compiler=1
-						retpoline_compiler_reason="noretpoline_setup found in kernel symbols"
+						retpoline_compiler_reason="noretpoline_setup encontrado nos símbolos do kernel"
 					fi
 				elif grep -q noretpoline_setup "$kernel"; then
 					# if we don't have nm, nevermind, the symbol name is long enough to not have
 					# any false positive using good old grep directly on the binary
 					retpoline_compiler=1
-					retpoline_compiler_reason="noretpoline_setup found in kernel"
+					retpoline_compiler_reason="noretpoline_setup encontrado no kernel"
 				fi
 			fi
 			if [ -n "$retpoline_compiler" ]; then
-				_info_nol "    * Kernel compiled with a retpoline-aware compiler: "
+				_info_nol "    * Kernel compilado com um compilador compatível com retpoline: "
 				if [ "$retpoline_compiler" = 1 ]; then
 					if [ -n "$retpoline_compiler_reason" ]; then
-						pstatus green YES "$retpoline_compiler_reason"
+						pstatus green SIM "$retpoline_compiler_reason"
 					else
-						pstatus green YES
+						pstatus green SIM
 					fi
 				else
 					if [ -n "$retpoline_compiler_reason" ]; then
-						pstatus red NO "$retpoline_compiler_reason"
+						pstatus red NÃO "$retpoline_compiler_reason"
 					else
-						pstatus red NO
+						pstatus red NÃO
 					fi
 				fi
 			fi
@@ -4472,50 +4472,50 @@ check_CVE_2017_5715_linux()
 		if [ "$opt_live" = 1 ]; then
 			if [ -e "$specex_knob_dir/retp_enabled" ]; then
 				retp_enabled=$(cat "$specex_knob_dir/retp_enabled" 2>/dev/null)
-				_debug "retpoline: found $specex_knob_dir/retp_enabled=$retp_enabled"
-				_info_nol "    * Retpoline is enabled: "
+				_debug "retpoline: encontrado $specex_knob_dir/retp_enabled=$retp_enabled"
+				_info_nol "    * Retpoline está ativado: "
 				if [ "$retp_enabled" = 1 ]; then
-					pstatus green YES
+					pstatus green SIM
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 				fi
 			fi
 		fi
 
 		# only for information, in verbose mode
 		if [ "$opt_verbose" -ge 2 ]; then
-			_info_nol "    * Local gcc is retpoline-aware: "
+			_info_nol "    * O gcc local reconhece a retpolina: "
 			if command -v gcc >/dev/null 2>&1; then
 				if [ -n "$(gcc -mindirect-branch=thunk-extern --version 2>&1 >/dev/null)" ]; then
-					pstatus blue NO
+					pstatus blue NÃO
 				else
-					pstatus green YES
+					pstatus green SIM
 				fi
 			else
-				pstatus blue NO "gcc is not installed"
+				pstatus blue NÃO "O gcc não está instalado"
 			fi
 		fi
 
 		if is_vulnerable_to_empty_rsb || [ "$opt_verbose" -ge 2 ]; then
-			_info_nol "  * Kernel supports RSB filling: "
+			_info_nol "  * O kernel suporta o preenchimento de RSB: "
 			rsb_filling=0
 			if [ "$opt_live" = 1 ] && [ "$opt_no_sysfs" != 1 ]; then
 				# if we're live and we aren't denied looking into /sys, let's do it
 				if echo "$msg" | grep -qw RSB; then
 					rsb_filling=1
-					pstatus green YES
+					pstatus green SIM
 				fi
 			fi
 			if [ "$rsb_filling" = 0 ]; then
 				if [ -n "$kernel_err" ]; then
-					pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+					pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 				else
 					if grep -qw -e 'Filling RSB on context switch' "$kernel"; then
 						rsb_filling=1
-						pstatus green YES
+						pstatus green SIM
 					else
 						rsb_filling=0
-						pstatus yellow NO
+						pstatus yellow NÃO
 					fi
 				fi
 			fi
@@ -4523,44 +4523,44 @@ check_CVE_2017_5715_linux()
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="interface de vulnerabilidade /sys usada forçada, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$retpoline" = 1 ] && [ "$retpoline_compiler" = 1 ] && [ "$retp_enabled" != 0 ] && [ -n "$ibpb_enabled" ] && [ "$ibpb_enabled" -ge 1 ] && ( ! is_vulnerable_to_empty_rsb || [ "$rsb_filling" = 1 ] ); then
-			pvulnstatus $cve OK "Full retpoline + IBPB are mitigating the vulnerability"
+			pvulnstatus $cve OK "Retpoline completo + IBPB estão mitigando a vulnerabilidade"
 		elif [ "$retpoline" = 1 ] && [ "$retpoline_compiler" = 1 ] && [ "$retp_enabled" != 0 ] && [ "$opt_paranoid" = 0 ] && ( ! is_vulnerable_to_empty_rsb || [ "$rsb_filling" = 1 ] ); then
-			pvulnstatus $cve OK "Full retpoline is mitigating the vulnerability"
+			pvulnstatus $cve OK "A retpolina completa está atenuando a vulnerabilidade"
 			if [ -n "$cpuid_ibpb" ]; then
-				_warn "You should enable IBPB to complete retpoline as a Variant 2 mitigation"
+				_warn "Você deve permitir que o IBPB complete a retpolina como uma mitigação da Variante 2"
 			else
-				_warn "IBPB is considered as a good addition to retpoline for Variant 2 mitigation, but your CPU microcode doesn't support it"
+				_warn "O IBPB é considerado um bom complemento ao retpoline para mitigação da Variante 2, mas o microcódigo da CPU não o suporta"
 			fi
 		elif [ -n "$ibrs_enabled" ] && [ -n "$ibpb_enabled" ] && [ "$ibrs_enabled" -ge 1 ] && [ "$ibpb_enabled" -ge 1 ]; then
 			if [ "$ibrs_enabled" = 4 ]; then
-				pvulnstatus $cve OK "Enhanced IBRS + IBPB are mitigating the vulnerability"
+				pvulnstatus $cve OK "IBRS + IBPB aprimorados estão mitigando a vulnerabilidade"
 			else
-				pvulnstatus $cve OK "IBRS + IBPB are mitigating the vulnerability"
+				pvulnstatus $cve OK "IBRS + IBPB estão mitigando a vulnerabilidade"
 			fi
 		elif [ "$ibpb_enabled" = 2 ] && ! is_cpu_smt_enabled; then
-			pvulnstatus $cve OK "Full IBPB is mitigating the vulnerability"
+			pvulnstatus $cve OK "O IBPB completo está mitigando a vulnerabilidade"
 		elif [ -n "$bp_harden" ]; then
-			pvulnstatus $cve OK "Branch predictor hardening mitigates the vulnerability"
+			pvulnstatus $cve OK "O reforço do preditor de ramificação atenua a vulnerabilidade"
 		elif [ -z "$bp_harden" ] && [ "$cpu_vendor" = ARM ]; then
-			pvulnstatus $cve VULN "Branch predictor hardening is needed to mitigate the vulnerability"
-			explain "Your kernel has not been compiled with the CONFIG_UNMAP_KERNEL_AT_EL0 option, recompile it with this option enabled."
+			pvulnstatus $cve VULN "O fortalecimento do preditor de ramificação é necessário para reduzir a vulnerabilidade"
+			explain "Seu kernel não foi compilado com a opção CONFIG_UNMAP_KERNEL_AT_EL0, recompile-o com esta opção ativada."
 		elif [ "$opt_live" != 1 ]; then
 			if [ "$retpoline" = 1 ] && [ -n "$ibpb_supported" ]; then
-				pvulnstatus $cve OK "offline mode: kernel supports retpoline + IBPB to mitigate the vulnerability"
+				pvulnstatus $cve OK "modo offline: o kernel suporta retpoline + IBPB para atenuar a vulnerabilidade"
 			elif [ -n "$ibrs_supported" ] && [ -n "$ibpb_supported" ]; then
-				pvulnstatus $cve OK "offline mode: kernel supports IBRS + IBPB to mitigate the vulnerability"
+				pvulnstatus $cve OK "modo offline: o kernel suporta IBRS + IBPB para atenuar a vulnerabilidade"
 			elif [ "$ibrs_can_tell" != 1 ]; then
-				pvulnstatus $cve UNK "offline mode: not enough information"
-				explain "Re-run this script with root privileges, and give it the kernel image (--kernel), the kernel configuration (--config) and the System.map file (--map) corresponding to the kernel you would like to inspect."
+				pvulnstatus $cve DES "modo offline: informações insuficientes"
+				explain "Execute novamente este script com privilégios de root e forneça a imagem do kernel (--kernel), a configuração do kernel (--config) e o arquivo System.map (--map) correspondente ao kernel que você deseja inspecionar."
 			fi
 		fi
 
@@ -4568,66 +4568,66 @@ check_CVE_2017_5715_linux()
 		if [ "$pvulnstatus_last_cve" != "$cve" ]; then
 			# explain what's needed for this CPU
 			if is_vulnerable_to_empty_rsb; then
-				pvulnstatus $cve VULN "IBRS+IBPB or retpoline+IBPB+RSB filling, is needed to mitigate the vulnerability"
-				explain "To mitigate this vulnerability, you need either IBRS + IBPB, both requiring hardware support from your CPU microcode in addition to kernel support, or a kernel compiled with retpoline and IBPB, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode. You also need a recent-enough kernel that supports RSB filling if you plan to use retpoline. For Skylake+ CPUs, the IBRS + IBPB approach is generally preferred as it guarantees complete protection, and the performance impact is not as high as with older CPUs in comparison with retpoline. More information about how to enable the missing bits for those two possible mitigations on your system follow. You only need to take one of the two approaches."
+				pvulnstatus $cve VULN "IBRS + IBPB ou retpoline + IBPB + preenchimento de RSB são necessários para atenuar a vulnerabilidade"
+				explain "Para mitigar essa vulnerabilidade, você precisa de IBRS + IBPB, ambos exigindo suporte de hardware do microcódigo da CPU além do suporte de kernel, ou um kernel compilado com retpoline e IBPB, com retpoline exigindo um compilador com reconhecimento de retpoline (execute novamente este script com -v para saber se sua versão do gcc é compatível com retpoline) e o IBPB requer suporte de hardware do microcódigo da CPU. Você também precisa de um kernel recente o suficiente que suporte o preenchimento RSB se planeja usar retpoline. Para CPUs Skylake+, a abordagem IBRS + IBPB é geralmente preferida, pois garante proteção completa e o impacto no desempenho não é tão alto quanto com CPUs mais antigas em comparação com retpoline. Mais informações sobre como habilitar os bits ausentes para essas duas possíveis mitigações em seu sistema seguem. Você só precisa tomar uma das duas abordagens."
 			elif is_zen_cpu || is_moksha_cpu; then
-				pvulnstatus $cve VULN "retpoline+IBPB is needed to mitigate the vulnerability"
-				explain "To mitigate this vulnerability, You need a kernel compiled with retpoline + IBPB support, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode."
+				pvulnstatus $cve VULN "retpoline + IBPB é necessário para atenuar a vulnerabilidade"
+				explain "Para atenuar essa vulnerabilidade, você precisa de um kernel compilado com suporte ao retpoline + IBPB, com o retpoline exigindo um compilador com reconhecimento de retpoline (execute novamente esse script com -v para saber se sua versão do gcc é compatível com retpoline) e o IBPB exigindo suporte de hardware do seu microcódigo da CPU."
 			elif is_intel || is_amd || is_hygon; then
-				pvulnstatus $cve VULN "IBRS+IBPB or retpoline+IBPB is needed to mitigate the vulnerability"
-				explain "To mitigate this vulnerability, you need either IBRS + IBPB, both requiring hardware support from your CPU microcode in addition to kernel support, or a kernel compiled with retpoline and IBPB, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode. The retpoline + IBPB approach is generally preferred as the performance impact is lower. More information about how to enable the missing bits for those two possible mitigations on your system follow. You only need to take one of the two approaches."
+				pvulnstatus $cve VULN "IBRS + IBPB ou retpoline + IBPB são necessários para atenuar a vulnerabilidade"
+				explain "Para mitigar essa vulnerabilidade, você precisa do IBRS + IBPB, que requer suporte de hardware do microcódigo da CPU, além do suporte ao kernel, ou um kernel compilado com retpoline e IBPB, com o retpoline exigindo um compilador compatível com retpoline (execute novamente este script com -v para saber se sua versão do gcc é compatível com retpoline) e o IBPB que requer suporte de hardware do microcódigo da CPU. A abordagem retpolina + IBPB é geralmente preferida, pois o impacto no desempenho é menor. Mais informações sobre como habilitar os bits ausentes para essas duas possíveis mitigações em seu sistema seguem. Você só precisa seguir uma das duas abordagens."
 			else
 				# in that case, we might want to trust sysfs if it's there
 				if [ -n "$msg" ]; then
-					[ "$msg" = Vulnerable ] && msg="no known mitigation exists for your CPU vendor ($cpu_vendor)"
+					[ "$msg" = Vulnerable ] && msg="não existe mitigação conhecida para o fornecedor da CPU ($cpu_vendor)"
 					pvulnstatus $cve $status "$msg"
 				else
-					pvulnstatus $cve VULN "no known mitigation exists for your CPU vendor ($cpu_vendor)"
+					pvulnstatus $cve VULN "não existe mitigação conhecida para o fornecedor da CPU ($cpu_vendor)"
 				fi
 			fi
 		fi
 
 		# if we are in live mode, we can check for a lot more stuff and explain further
 		if [ "$opt_live" = 1 ] && [ "$vulnstatus" != "OK" ]; then
-			_explain_hypervisor="An updated CPU microcode will have IBRS/IBPB capabilities indicated in the Hardware Check section above. If you're running under a hypervisor (KVM, Xen, VirtualBox, VMware, ...), the hypervisor needs to be up to date to be able to export the new host CPU flags to the guest. You can run this script on the host to check if the host CPU is IBRS/IBPB. If it is, and it doesn't show up in the guest, upgrade the hypervisor. You may need to reconfigure your VM to use a CPU model that has IBRS capability; in Libvirt, such CPUs are listed with an IBRS suffix."
+			_explain_hypervisor="Um microcódigo de CPU atualizado terá os recursos IBRS/IBPB indicados na seção Verificação de Hardware acima. Se você estiver executando em um hypervisor (KVM, Xen, VirtualBox, VMware, ...), o hypervisor precisará estar atualizado para poder exportar os novos sinalizadores da CPU do host para o convidado. Você pode executar este script no host para verificar se a CPU do host é IBRS/IBPB. Se for, e não aparecer no convidado, atualize o hypervisor. Pode ser necessário reconfigurar sua VM para usar um modelo de CPU com capacidade de IBRS; no Libvirt, essas CPUs são listadas com um sufixo IBRS."
 			# IBPB (amd & intel)
 			if { [ -z "$ibpb_enabled" ] || [ "$ibpb_enabled" = 0 ]; } && { is_intel || is_amd || is_hygon; }; then
 				if [ -z "$cpuid_ibpb" ]; then
-					explain "The microcode of your CPU needs to be upgraded to be able to use IBPB. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). $_explain_hypervisor"
+					explain "O microcódigo da sua CPU precisa ser atualizado para poder usar o IBPB. Isso geralmente é feito no momento da inicialização pelo seu kernel (a atualização não é persistente nas reinicializações, e é por isso que é feita em cada inicialização). Se você estiver usando uma distribuição, verifique se está atualizado, pois as atualizações de microcódigo geralmente são enviadas juntamente com o kernel da distribuição. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware). $_explain_hypervisor"
 				fi
 				if [ -z "$ibpb_supported" ]; then
-					explain "Your kernel doesn't have IBPB support, so you need to either upgrade your kernel (if you're using a distro) or recompiling a more recent kernel."
+					explain "Seu kernel não possui suporte IBPB, portanto, você precisa atualizar seu kernel (se estiver usando uma distribuição) ou recompilar um kernel mais recente."
 				fi
 				if [ -n "$cpuid_ibpb" ] && [ -n "$ibpb_supported" ]; then
 					if [ -e "$specex_knob_dir/ibpb_enabled" ]; then
 						# newer (April 2018) Red Hat kernels have ibpb_enabled as ro, and automatically enables it with retpoline
 						if [ ! -w "$specex_knob_dir/ibpb_enabled" ] && [ -e "$specex_knob_dir/retp_enabled" ]; then
-							explain "Both your CPU and your kernel have IBPB support, but it is currently disabled. You kernel should enable IBPB automatically if you enable retpoline. You may enable it with \`echo 1 > $specex_knob_dir/retp_enabled\`."
+							explain "Sua CPU e seu kernel têm suporte a IBPB, mas atualmente está desativado. O kernel deve ativar o IBPB automaticamente se você ativar o retpoline. Você pode habilitá-lo com \`echo 1 > $specex_knob_dir/retp_enabled\`."
 						else
-							explain "Both your CPU and your kernel have IBPB support, but it is currently disabled. You may enable it with \`echo 1 > $specex_knob_dir/ibpb_enabled\`."
+							explain "Sua CPU e seu kernel têm suporte a IBPB, mas atualmente está desativado. Você pode habilitá-lo com \`echo 1 > $specex_knob_dir/ibpb_enabled\`."
 						fi
 					else
-						explain "Both your CPU and your kernel have IBPB support, but it is currently disabled. You may enable it. Check in your distro's documentation on how to do this."
+						explain "Sua CPU e seu kernel têm suporte a IBPB, mas atualmente está desativado. Você pode habilitá-lo. Verifique a documentação da sua distribuição sobre como fazer isso."
 					fi
 				fi
 			elif [ "$ibpb_enabled" = 2 ] && is_cpu_smt_enabled; then
-				explain "You have ibpb_enabled set to 2, but it only offers sufficient protection when simultaneous multi-threading (aka SMT or HyperThreading) is disabled. You should reboot your system with the kernel parameter \`nosmt\`."
+				explain "Você definiu ibpb_enabled como 2, mas ele oferece proteção suficiente apenas quando a multithread simultânea (também conhecida como SMT ou HyperThreading) está desativada. Você deve reiniciar o sistema com o parâmetro do kernel \`nosmt\`."
 			fi
 			# /IBPB
 
 			# IBRS (amd & intel)
 			if { [ -z "$ibrs_enabled" ] || [ "$ibrs_enabled" = 0 ]; } && { is_intel || is_amd || is_hygon; }; then
 				if [ -z "$cpuid_ibrs" ]; then
-					explain "The microcode of your CPU needs to be upgraded to be able to use IBRS. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). $_explain_hypervisor"
+					explain "O microcódigo da sua CPU precisa ser atualizado para poder usar o IBRS. Isso geralmente é feito no momento da inicialização pelo seu kernel (a atualização não é persistente nas reinicializações, e é por isso que é feita em cada inicialização). Se você estiver usando uma distribuição, verifique se está atualizado, pois as atualizações de microcódigo geralmente são enviadas juntamente com o kernel da distribuição. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware). $_explain_hypervisor"
 				fi
 				if [ -z "$ibrs_supported" ]; then
-					explain "Your kernel doesn't have IBRS support, so you need to either upgrade your kernel (if you're using a distro) or recompiling a more recent kernel."
+					explain "Seu kernel não possui suporte para IBRS, portanto, você precisa atualizar seu kernel (se estiver usando uma distribuição) ou recompilar um kernel mais recente."
 				fi
 				if [ -n "$cpuid_ibrs" ] && [ -n "$ibrs_supported" ]; then
 					if [ -e "$specex_knob_dir/ibrs_enabled" ]; then
-						explain "Both your CPU and your kernel have IBRS support, but it is currently disabled. You may enable it with \`echo 1 > $specex_knob_dir/ibrs_enabled\`."
+						explain "Sua CPU e seu kernel têm suporte para IBRS, mas atualmente está desativado. Você pode habilitá-lo com \`echo 1 > $specex_knob_dir/ibrs_enabled\`."
 					else
-						explain "Both your CPU and your kernel have IBRS support, but it is currently disabled. You may enable it. Check in your distro's documentation on how to do this."
+						explain "Sua CPU e seu kernel têm suporte para IBRS, mas atualmente está desativado. Você pode habilitá-lo. Verifique a documentação da sua distribuição sobre como fazer isso."
 					fi
 				fi
 			fi
@@ -4637,11 +4637,11 @@ check_CVE_2017_5715_linux()
 			# RETPOLINE (amd & intel &hygon )
 			if is_amd || is_intel || is_hygon; then
 				if [ "$retpoline" = 0 ]; then
-					explain "Your kernel is not compiled with retpoline support, so you need to either upgrade your kernel (if you're using a distro) or recompile your kernel with the CONFIG_RETPOLINE option enabled. You also need to compile your kernel with a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware)."
+					explain "Seu kernel não é compilado com suporte a retpoline, então você precisa atualizar seu kernel (se estiver usando uma distro) ou recompilar seu kernel com a opção CONFIG_RETPOLINE habilitada. Você também precisa compilar seu kernel com um compilador compatível com retpoline (execute novamente este script com -v para saber se sua versão do gcc é compatível com retpoline)."
 				elif [ "$retpoline" = 1 ] && [ "$retpoline_compiler" = 0 ]; then
-					explain "Your kernel is compiled with retpoline, but without a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware)."
+					explain "Seu kernel é compilado com retpoline, mas sem um compilador com reconhecimento de retpoline (execute novamente esse script com -v para saber se sua versão do gcc tem reconhecimento de retpoline)."
 				elif [ "$retpoline" = 1 ] && [ "$retpoline_compiler" = 1 ] && [ "$retp_enabled" = 0 ]; then
-					explain "Your kernel has retpoline support and has been compiled with a retpoline-aware compiler, but retpoline is disabled. You should enable it with \`echo 1 > $specex_knob_dir/retp_enabled\`."
+					explain "Seu kernel possui suporte a retpoline e foi compilado com um compilador compatível com retpoline, mas o retpoline está desabilitado. Você deve habilitá-lo com \`echo 1 > $specex_knob_dir/retp_enabled\`."
 				fi
 			fi
 			# /RETPOLINE
@@ -4670,58 +4670,58 @@ check_CVE_2017_5715_linux()
 
 check_CVE_2017_5715_bsd()
 {
-	_info     "* Mitigation 1"
-	_info_nol "  * Kernel supports IBRS: "
+	_info     "* Mitigação 1"
+	_info_nol "  * Kernel suporta IBRS: "
 	ibrs_disabled=$(sysctl -n hw.ibrs_disable 2>/dev/null)
 	if [ -z "$ibrs_disabled" ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
-		pstatus green YES
+		pstatus green SIM
 	fi
 
-	_info_nol "  * IBRS enabled and active: "
+	_info_nol "  * IBRS ativado e ativo: "
 	ibrs_active=$(sysctl -n hw.ibrs_active 2>/dev/null)
 	if [ "$ibrs_active" = 1 ]; then
-		pstatus green YES
+		pstatus green SIM
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
-	_info     "* Mitigation 2"
-	_info_nol "  * Kernel compiled with RETPOLINE: "
+	_info     "* Mitigação 2"
+	_info_nol "  * Kernel compilado com RETPOLINE: "
 	retpoline=0
 	if [ -n "$kernel_err" ]; then
-		pstatus yellow UNKNOWN "couldn't check ($kernel_err)"
+		pstatus yellow DESCONHECIDO "não pude verificar ($kernel_err)"
 	else
 		if ! command -v "${opt_arch_prefix}readelf" >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing '${opt_arch_prefix}readelf' tool, please install it, usually it's in the binutils package"
+			pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}readelf', instale-a, geralmente está no pacote binutils"
 		else
 			nb_thunks=$("${opt_arch_prefix}readelf" -s "$kernel" | grep -c -e __llvm_retpoline_ -e __llvm_external_retpoline_ -e __x86_indirect_thunk_)
 			if [ "$nb_thunks" -gt 0 ]; then
 				retpoline=1
-				pstatus green YES "found $nb_thunks thunk(s)"
+				pstatus green SIM "encontrado $nb_thunks thunk(s)"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		fi
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ "$retpoline" = 1 ]; then
-		pvulnstatus $cve OK "Retpoline mitigates the vulnerability"
+		pvulnstatus $cve OK "Retpoline atenua a vulnerabilidade"
 	elif [ "$ibrs_active" = 1 ]; then
-		pvulnstatus $cve OK "IBRS mitigates the vulnerability"
+		pvulnstatus $cve OK "IBRS atenua a vulnerabilidade"
 	elif [ "$ibrs_disabled" = 0 ]; then
-		pvulnstatus $cve VULN "IBRS is supported by your kernel but your CPU microcode lacks support"
-		explain "The microcode of your CPU needs to be upgraded to be able to use IBRS. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). To do a microcode update, you can search the ports for the \`cpupdate\` tool. Microcode updates done this way are not reboot-proof, so be sure to do it every time the system boots up."
+		pvulnstatus $cve VULN "O IBRS é suportado pelo seu kernel, mas o microcódigo da CPU não possui suporte"
+		explain "O microcódigo da sua CPU precisa ser atualizado para poder usar o IBRS. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware). Para fazer uma atualização de microcódigo, você pode procurar nas portas a ferramenta \`cpupdate\`. As atualizações de microcódigo feitas dessa maneira não são à prova de reinicialização, portanto, faça isso sempre que o sistema inicializar."
 	elif [ "$ibrs_disabled" = 1 ]; then
-		pvulnstatus $cve VULN "IBRS is supported but administratively disabled on your system"
-		explain "To enable IBRS, use \`sysctl hw.ibrs_disable=0\`"
+		pvulnstatus $cve VULN "O IBRS é suportado, mas desativado administrativamente em seu sistema"
+		explain "Para ativar o IBRS, use \`sysctl hw.ibrs_disable=0\`"
 	else
-		pvulnstatus $cve VULN "IBRS is needed to mitigate the vulnerability but your kernel is missing support"
-		explain "You need to either upgrade your kernel or recompile yourself a more recent version having IBRS support"
+		pvulnstatus $cve VULN "O IBRS é necessário para atenuar a vulnerabilidade, mas seu suporte está ausente"
+		explain "Você precisa atualizar seu kernel ou recompilar uma versão mais recente com suporte ao IBRS"
 	fi
 }
 
@@ -4736,7 +4736,7 @@ check_CVE_2017_5715_bsd()
 # https://groups.google.com/forum/m/#!topic/mechanical-sympathy/L9mHTbeQLNU
 pti_performance_check()
 {
-	_info_nol "  * Reduced performance impact of PTI: "
+	_info_nol "  * Impacto reduzido no desempenho da PTI: "
 	if [ -e "$procfs/cpuinfo" ] && grep ^flags "$procfs/cpuinfo" | grep -qw pcid; then
 		cpu_pcid=1
 	else
@@ -4756,11 +4756,11 @@ pti_performance_check()
 	fi
 
 	if [ "$cpu_invpcid" = 1 ]; then
-		pstatus green YES 'CPU supports INVPCID, performance impact of PTI will be greatly reduced'
+		pstatus green SIM 'CPU suporta INVPCID, o impacto no desempenho da PTI será bastante reduzido'
 	elif [ "$cpu_pcid" = 1 ]; then
-		pstatus green YES 'CPU supports PCID, performance impact of PTI will be reduced'
+		pstatus green SIM 'CPU suporta PCID, o impacto no desempenho da PTI será reduzido'
 	else
-		pstatus blue NO 'PCID/INVPCID not supported, performance impact of PTI will be significant'
+		pstatus blue NÃO 'PCID/INVPCID não suportado, o impacto no desempenho da PTI será significativo'
 	fi
 }
 
@@ -4768,19 +4768,19 @@ pti_performance_check()
 check_CVE_2017_5754()
 {
 	cve='CVE-2017-5754'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2017_5754_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2017_5754_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2017_5754_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/meltdown"; then
@@ -4788,14 +4788,14 @@ check_CVE_2017_5754_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Kernel supports Page Table Isolation (PTI): "
+		_info_nol "* O kernel suporta Page Table Isolation (PTI): "
 		kpti_support=''
 		kpti_can_tell=0
 		if [ -n "$opt_config" ]; then
 			kpti_can_tell=1
 			kpti_support=$(grep -w -e CONFIG_PAGE_TABLE_ISOLATION=y -e CONFIG_KAISER=y -e CONFIG_UNMAP_KERNEL_AT_EL0=y "$opt_config")
 			if [ -n "$kpti_support" ]; then
-				_debug "kpti_support: found option '$kpti_support' in $opt_config"
+				_debug "kpti_support: opção encontrada '$kpti_support' em $opt_config"
 			fi
 		fi
 		if [ -z "$kpti_support" ] && [ -n "$opt_map" ]; then
@@ -4805,7 +4805,7 @@ check_CVE_2017_5754_linux()
 			kpti_can_tell=1
 			kpti_support=$(grep -w -e kpti_force_enabled -e parse_kpti "$opt_map")
 			if [ -n "$kpti_support" ]; then
-				_debug "kpti_support: found '$kpti_support' in $opt_map"
+				_debug "kpti_support: encontrado '$kpti_support' em $opt_map"
 			fi
 		fi
 		if [ -z "$kpti_support" ] && [ -n "$kernel" ]; then
@@ -4814,29 +4814,29 @@ check_CVE_2017_5754_linux()
 			# 'kpti=': arm
 			kpti_can_tell=1
 			if ! command -v "${opt_arch_prefix}strings" >/dev/null 2>&1; then
-				pstatus yellow UNKNOWN "missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package"
+				pstatus yellow DESCONHECIDO "faltando a ferramenta '${opt_arch_prefix}strings', instale-a, geralmente está no pacote binutils"
 			else
 				kpti_support=$("${opt_arch_prefix}strings" "$kernel" | grep -w -e nopti -e kpti=)
 				if [ -n "$kpti_support" ]; then
-					_debug "kpti_support: found '$kpti_support' in $kernel"
+					_debug "kpti_support: encontrado '$kpti_support' em $kernel"
 				fi
 			fi
 		fi
 
 		if [ -n "$kpti_support" ]; then
 			if [ "$opt_verbose" -ge 2 ]; then
-				pstatus green YES "found '$kpti_support'"
+				pstatus green SIM "encontrado '$kpti_support'"
 			else
-				pstatus green YES
+				pstatus green SIM
 			fi
 		elif [ "$kpti_can_tell" = 1 ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus yellow UNKNOWN "couldn't read your kernel configuration nor System.map file"
+			pstatus yellow DESCONHECIDO "Não foi possível ler a configuração do kernel nem o arquivo System.map"
 		fi
 
 		mount_debugfs
-		_info_nol "  * PTI enabled and active: "
+		_info_nol "  * PTI ativado e ativo: "
 		if [ "$opt_live" = 1 ]; then
 			dmesg_grep="Kernel/User page tables isolation: enabled"
 			dmesg_grep="$dmesg_grep|Kernel page table isolation enabled"
@@ -4845,16 +4845,16 @@ check_CVE_2017_5754_linux()
 			dmesg_grep="$dmesg_grep|CPU features: detected( feature)?: Kernel page table isolation \(KPTI\)"
 			if grep ^flags "$procfs/cpuinfo" | grep -qw pti; then
 				# vanilla PTI patch sets the 'pti' flag in cpuinfo
-				_debug "kpti_enabled: found 'pti' flag in $procfs/cpuinfo"
+				_debug "kpti_enabled: flag 'pti' encontrado em $procfs/cpuinfo"
 				kpti_enabled=1
 			elif grep ^flags "$procfs/cpuinfo" | grep -qw kaiser; then
 				# kernel line 4.9 sets the 'kaiser' flag in cpuinfo
-				_debug "kpti_enabled: found 'kaiser' flag in $procfs/cpuinfo"
+				_debug "kpti_enabled: encontrado o sinalizador 'kaiser' em $procfs/cpuinfo"
 				kpti_enabled=1
 			elif [ -e /sys/kernel/debug/x86/pti_enabled ]; then
 				# Red Hat Backport creates a dedicated file, see https://access.redhat.com/articles/3311301
 				kpti_enabled=$(cat /sys/kernel/debug/x86/pti_enabled 2>/dev/null)
-				_debug "kpti_enabled: file /sys/kernel/debug/x86/pti_enabled exists and says: $kpti_enabled"
+				_debug "kpti_enabled: arquivo /sys/kernel/debug/x86/pti_enabled existe e diz: $kpti_enabled"
 			elif is_xen_dom0; then
 				pti_xen_pv_domU=$(xl dmesg | grep 'XPTI' | grep 'DomU enabled' | head -1)
 
@@ -4863,34 +4863,34 @@ check_CVE_2017_5754_linux()
 			if [ -z "$kpti_enabled" ]; then
 				dmesg_grep "$dmesg_grep"; ret=$?
 				if [ $ret -eq 0 ]; then
-					_debug "kpti_enabled: found hint in dmesg: $dmesg_grepped"
+					_debug "kpti_enabled: dica encontrada no dmesg: $dmesg_grepped"
 					kpti_enabled=1
 				elif [ $ret -eq 2 ]; then
-					_debug "kpti_enabled: dmesg truncated"
+					_debug "kpti_enabled: dmesg truncado"
 					kpti_enabled=-1
 				fi
 			fi
 			if [ -z "$kpti_enabled" ]; then
-				_debug "kpti_enabled: couldn't find any hint that PTI is enabled"
+				_debug "kpti_enabled: não foi possível encontrar nenhuma dica de que a PTI está ativada"
 				kpti_enabled=0
 			fi
 			if [ "$kpti_enabled" = 1 ]; then
-				pstatus green YES
+				pstatus green SIM
 			elif [ "$kpti_enabled" = -1 ]; then
-				pstatus yellow UNKNOWN "dmesg truncated, please reboot and relaunch this script"
+				pstatus yellow DESCONHECIDO "dmesg truncado, reinicie e relançar este script"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
 		pti_performance_check
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 
@@ -4903,68 +4903,68 @@ check_CVE_2017_5754_linux()
 	if [ "$opt_live" = 1 ]; then
 		# checking whether we're running under Xen PV 64 bits. If yes, we are affected by variant3
 		# (unless we are a Dom0)
-		_info_nol "* Running as a Xen PV DomU: "
+		_info_nol "* Correndo como um Xen PV DomU: "
 		if [ "$xen_pv_domu" = 1 ]; then
-			pstatus yellow YES
+			pstatus yellow SIM
 		else
-			pstatus blue NO
+			pstatus blue NÃO
 		fi
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ "$opt_live" = 1 ]; then
 			if [ "$kpti_enabled" = 1 ]; then
-				pvulnstatus $cve OK "PTI mitigates the vulnerability"
+				pvulnstatus $cve OK "PTI atenua a vulnerabilidade"
 			elif [ "$xen_pv_domo" = 1 ]; then
-				pvulnstatus $cve OK "Xen Dom0s are safe and do not require PTI"
+				pvulnstatus $cve OK "Xen Dom0s são seguros e não exigem PTI"
 			elif [ "$xen_pv_domu" = 1 ]; then
-				pvulnstatus $cve VULN "Xen PV DomUs are vulnerable and need to be run in HVM, PVHVM, PVH mode, or the Xen hypervisor must have the Xen's own PTI patch"
-				explain "Go to https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ for more information"
+				pvulnstatus $cve VULN "As Xen PV DomUs são vulneráveis e precisam ser executadas no modo HVM, PVHVM, PVH ou o hipervisor Xen deve ter o próprio patch PTI do Xen"
+				explain "Vá para https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ para mais informações"
 			elif [ "$kpti_enabled" = -1 ]; then
-				pvulnstatus $cve UNK "couldn't find any clue of PTI activation due to a truncated dmesg, please reboot and relaunch this script"
+				pvulnstatus $cve DES "não foi possível encontrar nenhuma pista da ativação da PTI devido a um dmesg truncado, reinicie e reinicie este script"
 			else
-				pvulnstatus $cve VULN "PTI is needed to mitigate the vulnerability"
+				pvulnstatus $cve VULN "A PTI é necessária para atenuar a vulnerabilidade"
 				if [ -n "$kpti_support" ]; then
 					if [ -e "/sys/kernel/debug/x86/pti_enabled" ]; then
-						explain "Your kernel supports PTI but it's disabled, you can enable it with \`echo 1 > /sys/kernel/debug/x86/pti_enabled\`"
+						explain "Seu kernel suporta PTI mas está desabilitado, você pode habilitá-lo com \`echo 1 > /sys/kernel/debug/x86/pti_enabled\`"
 					elif echo "$kernel_cmdline" | grep -q -w -e nopti -e pti=off; then
-						explain "Your kernel supports PTI but it has been disabled on command-line, remove the nopti or pti=off option from your bootloader configuration"
+						explain "Seu kernel suporta PTI, mas foi desabilitado na linha de comando, remova a opção nopti ou pti=off da configuração do bootloader"
 					else
-						explain "Your kernel supports PTI but it has been disabled, check \`dmesg\` right after boot to find clues why the system disabled it"
+						explain "Seu kernel suporta PTI, mas foi desabilitado, verifique \`dmesg\` logo após a inicialização para encontrar pistas de por que o sistema o desabilitou"
 					fi
 				else
-					explain "If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)"
+					explain "Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel com a opção CONFIG_PAGE_TABLE_ISOLATION (chamada CONFIG_KAISER para alguns kernels) ou a opção CONFIG_UNMAP_KERNEL_AT_EL0 (para ARM64)"
 				fi
 			fi
 		else
 			if [ -n "$kpti_support" ]; then
-				pvulnstatus $cve OK "offline mode: PTI will mitigate the vulnerability if enabled at runtime"
+				pvulnstatus $cve OK "modo offline: PTI irá mitigar a vulnerabilidade se ativado em tempo de execução"
 			elif [ "$kpti_can_tell" = 1 ]; then
-				pvulnstatus $cve VULN "PTI is needed to mitigate the vulnerability"
-				explain "If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)"
+				pvulnstatus $cve VULN "PTI é necessária para mitigar a vulnerabilidade"
+				explain "Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel com a opção CONFIG_PAGE_TABLE_ISOLATION (chamada CONFIG_KAISER para alguns kernels) ou a opção CONFIG_UNMAP_KERNEL_AT_EL0 (para ARM64)"
 			else
-				pvulnstatus $cve UNK "offline mode: not enough information"
-				explain "Re-run this script with root privileges, and give it the kernel image (--kernel), the kernel configuration (--config) and the System.map file (--map) corresponding to the kernel you would like to inspect."
+				pvulnstatus $cve DESCONHECIDO "modo offline: informações insuficientes"
+				explain "Execute novamente este script com privilégios de root e forneça a imagem do kernel (--kernel), a configuração do kernel (--config) e o arquivo System.map (--map) correspondente ao kernel que você gostaria de inspecionar."
 			fi
 		fi
 	else
 		if [ "$xen_pv_domo" = 1 ]; then
-			msg="Xen Dom0s are safe and do not require PTI"
+			msg="Xen Dom0s são seguros e não requerem PTI"
 			status="OK"
 		elif [ "$xen_pv_domu" = 1 ]; then
-			msg="Xen PV DomUs are vulnerable and need to be run in HVM, PVHVM, PVH mode, or the Xen hypervisor must have the Xen's own PTI patch"
+			msg="Xen PV DomUs são vulneráveis e precisam ser executados no modo HVM, PVHVM, PVH ou o hipervisor Xen deve ter o próprio patch PTI do Xen"
 			status="VULN"
-			_explain="Go to https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ for more information"
+			_explain="Vá para https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ for more information"
 		elif [ "$msg" = "Vulnerable" ]; then
-			msg="PTI is needed to mitigate the vulnerability"
-			_explain="If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)"
+			msg="PTI é necessária para mitigar a vulnerabilidade"
+			_explain="Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel com a opção CONFIG_PAGE_TABLE_ISOLATION (chamada CONFIG_KAISER para alguns kernels) ou a opção CONFIG_UNMAP_KERNEL_AT_EL0 (para ARM64)"
 		fi
 		pvulnstatus $cve "$status" "$msg"
-		[ -z "${_explain:-}" ] && [ "$msg" = "Vulnerable" ] && _explain="If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)"
+		[ -z "${_explain:-}" ] && [ "$msg" = "Vulnerable" ] && _explain="Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel com a opção CONFIG_PAGE_TABLE_ISOLATION (chamada CONFIG_KAISER para alguns kernels) ou a opção CONFIG_UNMAP_KERNEL_AT_EL0 (para ARM64)"
 		[ -n "${_explain:-}" ] && explain "$_explain"
 		unset _explain
 	fi
@@ -4972,41 +4972,41 @@ check_CVE_2017_5754_linux()
 	# Warn the user about XSA-254 recommended mitigations
 	if [ "$xen_pv_domo" = 1 ]; then
 		_warn
-		_warn "This host is a Xen Dom0. Please make sure that you are running your DomUs"
-		_warn "in HVM, PVHVM or PVH mode to prevent any guest-to-host / host-to-guest attacks."
+		_warn "Este host é um Xen Dom0. Por favor, certifique-se de que você está executando seus DomUs"
+		_warn "no modo HVM, PVHVM ou PVH para evitar ataques de convidado a host / host a convidado."
 		_warn
-		_warn "See https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ and XSA-254 for details."
+		_warn "Consulte https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ e XSA-254 para detalhes."
 	fi
 }
 
 check_CVE_2017_5754_bsd()
 {
-	_info_nol "* Kernel supports Page Table Isolation (PTI): "
+	_info_nol "* Kernel suporta isolamento de tabela de página (PTI): "
 	kpti_enabled=$(sysctl -n vm.pmap.pti 2>/dev/null)
 	if [ -z "$kpti_enabled" ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
-		pstatus green YES
+		pstatus green SIM
 	fi
 
-	_info_nol "  * PTI enabled and active: "
+	_info_nol "  * PTI ativado e ativo: "
 	if [ "$kpti_enabled" = 1 ]; then
-		pstatus green YES
+		pstatus green SIM
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
 	pti_performance_check
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU não foi afetado"
 	elif [ "$kpti_enabled" = 1 ]; then
-		pvulnstatus $cve OK "PTI mitigates the vulnerability"
+		pvulnstatus $cve OK "PTI mitiga a vulnerabilidade"
 	elif [ -n "$kpti_enabled" ]; then
-		pvulnstatus $cve VULN "PTI is supported but disabled on your system"
+		pvulnstatus $cve VULN "PTI é suportado, mas desativado em seu sistema"
 	else
-		pvulnstatus $cve VULN "PTI is needed to mitigate the vulnerability"
+		pvulnstatus $cve VULN "A PTI é necessária para mitigar a vulnerabilidade"
 	fi
 }
 
@@ -5017,29 +5017,29 @@ check_CVE_2017_5754_bsd()
 check_CVE_2018_3640()
 {
 	cve='CVE-2018-3640'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 
-	_info_nol "* CPU microcode mitigates the vulnerability: "
+	_info_nol "* O microcódigo da CPU reduz a vulnerabilidade: "
 	if [ -n "$cpuid_ssbd" ]; then
 		# microcodes that ship with SSBD are known to also fix variant3a
 		# there is no specific cpuid bit as far as we know
-		pstatus green YES
+		pstatus green SIM
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ -n "$cpuid_ssbd" ]; then
-		pvulnstatus $cve OK "your CPU microcode mitigates the vulnerability"
+		pvulnstatus $cve OK "seu microcódigo da CPU reduz a vulnerabilidade"
 	else
-		pvulnstatus $cve VULN "an up-to-date CPU microcode is needed to mitigate this vulnerability"
-		explain "The microcode of your CPU needs to be upgraded to mitigate this vulnerability. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). The microcode update is enough, there is no additional OS, kernel or software change needed."
+		pvulnstatus $cve VULN "é necessário um microcódigo de CPU atualizado para mitigar essa vulnerabilidade"
+		explain "O microcódigo da sua CPU precisa ser atualizado para reduzir essa vulnerabilidade. Isso geralmente é feito no momento da inicialização pelo seu kernel (a atualização não é persistente nas reinicializações, e é por isso que é feita em cada inicialização). Se você estiver usando uma distribuição, verifique se está atualizado, pois as atualizações de microcódigo geralmente são enviadas juntamente com o kernel da distribuição. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware). A atualização do microcódigo é suficiente, não são necessárias alterações adicionais no SO, no kernel ou no software."
 	fi
 }
 
@@ -5050,19 +5050,19 @@ check_CVE_2018_3640()
 check_CVE_2018_3639()
 {
 	cve='CVE-2018-3639'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2018_3639_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2018_3639_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2018_3639_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/spec_store_bypass"; then
@@ -5070,115 +5070,115 @@ check_CVE_2018_3639_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Kernel supports disabling speculative store bypass (SSB): "
+		_info_nol "* O kernel suporta a desativação do desvio de armazenamento especulativo (SSB): "
 		if [ "$opt_live" = 1 ]; then
 			if grep -Eq 'Speculation.?Store.?Bypass:' "$procfs/self/status" 2>/dev/null; then
-				kernel_ssb="found in $procfs/self/status"
-				_debug "found Speculation.Store.Bypass: in $procfs/self/status"
+				kernel_ssb="encontrado em $procfs/self/status"
+				_debug "encontrado Speculation.Store.Bypass: em $procfs/self/status"
 			fi
 		fi
 		# arm64 kernels can have cpu_show_spec_store_bypass with ARM64_SSBD, so exclude them
 		if [ -z "$kernel_ssb" ] && [ -n "$kernel" ] && ! grep -q 'arm64_sys_' "$kernel"; then
 			kernel_ssb=$("${opt_arch_prefix}strings" "$kernel" | grep spec_store_bypass | head -n1);
-			[ -n "$kernel_ssb" ] && kernel_ssb="found $kernel_ssb in kernel"
+			[ -n "$kernel_ssb" ] && kernel_ssb="encontrado $kernel_ssb no kernel"
 		fi
 		# arm64 kernels can have cpu_show_spec_store_bypass with ARM64_SSBD, so exclude them
 		if [ -z "$kernel_ssb" ] && [ -n "$opt_map" ] && ! grep -q 'arm64_sys_' "$opt_map"; then
 			kernel_ssb=$(grep spec_store_bypass "$opt_map" | awk '{print $3}' | head -n1)
-			[ -n "$kernel_ssb" ] && kernel_ssb="found $kernel_ssb in System.map"
+			[ -n "$kernel_ssb" ] && kernel_ssb="encontrado $kernel_ssb no System.map"
 		fi
 		# arm64 only:
 		if [ -z "$kernel_ssb" ] && [ -n "$opt_map" ]; then
 			kernel_ssb=$(grep -w cpu_enable_ssbs "$opt_map" | awk '{print $3}' | head -n1)
-			[ -n "$kernel_ssb" ] && kernel_ssb="found $kernel_ssb in System.map"
+			[ -n "$kernel_ssb" ] && kernel_ssb="encontrado $kernel_ssb no System.map"
 		fi
 		if [ -z "$kernel_ssb" ] && [ -n "$opt_config" ]; then
 			kernel_ssb=$(grep -w 'CONFIG_ARM64_SSBD=y' "$opt_config")
-			[ -n "$kernel_ssb" ] && kernel_ssb="CONFIG_ARM64_SSBD enabled in kconfig"
+			[ -n "$kernel_ssb" ] && kernel_ssb="CONFIG_ARM64_SSBDha bilitado em kconfig"
 		fi
 		if [ -z "$kernel_ssb" ] && [ -n "$kernel" ]; then
 			# this string only appears in kernel if CONFIG_ARM64_SSBD is set
-			kernel_ssb=$(grep -w "Speculative Store Bypassing Safe (SSBS)" "$kernel")
-			[ -n "$kernel_ssb" ] && kernel_ssb="found 'Speculative Store Bypassing Safe (SSBS)' in kernel"
+			kernel_ssb=$(grep -w "Especulative Store Bypassing Safe (SSBS)" "$kernel")
+			[ -n "$kernel_ssb" ] && kernel_ssb="encontrado 'Especulative Store Bypassing Safe (SSBS)' no kernel"
 		fi
 		# /arm64 only
 
 		if [ -n "$kernel_ssb" ]; then
-			pstatus green YES "$kernel_ssb"
+			pstatus green SIM "$kernel_ssb"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
 		kernel_ssbd_enabled=-1
 		if [ "$opt_live" = 1 ]; then
 			# https://elixir.bootlin.com/linux/v5.0/source/fs/proc/array.c#L340
-			_info_nol "* SSB mitigation is enabled and active: "
+			_info_nol "* A mitigação de SSB está habilitada e ativa: "
 			if grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+thread' "$procfs/self/status" 2>/dev/null; then
 				kernel_ssbd_enabled=1
-				pstatus green YES "per-thread through prctl"
+				pstatus green SIM "por thread por meio de prctl"
 			elif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+globally mitigated' "$procfs/self/status" 2>/dev/null; then
 				kernel_ssbd_enabled=2
-				pstatus green YES "global"
+				pstatus green SIM "global"
 			elif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+vulnerable' "$procfs/self/status" 2>/dev/null; then
 				kernel_ssbd_enabled=0
-				pstatus yellow NO
+				pstatus yellow NÃO
 			elif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+not vulnerable' "$procfs/self/status" 2>/dev/null; then
 				kernel_ssbd_enabled=-2
-				pstatus blue NO "not vulnerable"
+				pstatus blue NÃO "não vulnerável"
 			elif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+unknown' "$procfs/self/status" 2>/dev/null; then
 				kernel_ssbd_enabled=0
-				pstatus blue NO
+				pstatus blue NÃO
 			else
-				pstatus blue UNKNOWN "unknown value: $(grep -E 'Speculation.?Store.?Bypass:' "$procfs/self/status" 2>/dev/null | cut -d: -f2-)"
+				pstatus blue DESCONHECIDO "valor desconhecido: $(grep -E 'Speculation.?Store.?Bypass:' "$procfs/self/status" 2>/dev/null | cut -d: -f2-)"
 			fi
 
 			if [ "$kernel_ssbd_enabled" = 1 ]; then
-				_info_nol "* SSB mitigation currently active for selected processes: "
+				_info_nol "* Mitigação de SSB atualmente ativa para processos selecionados: "
 				# silence grep's stderr here to avoid ENOENT errors from processes that have exited since the shell's expansion of the *
 				mitigated_processes=$(find /proc -mindepth 2 -maxdepth 2 -type f -name status -print0 2>/dev/null \
 					| xargs -r0 grep -El 'Speculation.?Store.?Bypass:[[:space:]]+thread (force )?mitigated' 2>/dev/null \
 					| sed s/status/exe/ | xargs -r -n1 readlink -f 2>/dev/null | xargs -r -n1 basename | sort -u | tr "\n" " " | sed 's/ $//')
 				if [ -n "$mitigated_processes" ]; then
-					pstatus green YES "$mitigated_processes"
+					pstatus green SIM "$mitigated_processes"
 				else
-					pstatus yellow NO "no process found using SSB mitigation through prctl"
+					pstatus yellow NÃO "nenhum processo encontrado usando a mitigação de SSB por meio de prctl"
 				fi
 			fi
 		fi
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ] || [ "$msg" = "Vulnerable" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ -n "$cpuid_ssbd" ]; then
 			if [ -n "$kernel_ssb" ]; then
 				if [ "$opt_live" = 1 ]; then
 					if [ "$kernel_ssbd_enabled" -gt 0 ]; then
-						pvulnstatus $cve OK "your CPU and kernel both support SSBD and mitigation is enabled"
+						pvulnstatus $cve OK "sua CPU e kernel suportam SSBD e a mitigação é ativada"
 					else
-						pvulnstatus $cve VULN "your CPU and kernel both support SSBD but the mitigation is not active"
+						pvulnstatus $cve VULN "sua CPU e kernel suportam SSBD, mas a atenuação não está ativa"
 					fi
 				else
-					pvulnstatus $cve OK "your system provides the necessary tools for software mitigation"
+					pvulnstatus $cve OK "seu sistema fornece as ferramentas necessárias para mitigação de software"
 				fi
 			else
-				pvulnstatus $cve VULN "your kernel needs to be updated"
-				explain "You have a recent-enough CPU microcode but your kernel is too old to use the new features exported by your CPU's microcode. If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel from recent-enough sources."
+				pvulnstatus $cve VULN "seu kernel precisa ser atualizado"
+				explain "Você tem um microcódigo de CPU recente o suficiente, mas seu kernel é muito antigo para usar os novos recursos exportados pelo microcódigo de sua CPU. Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel de fontes recentes o suficiente."
 			fi
 		else
 			if [ -n "$kernel_ssb" ]; then
-				pvulnstatus $cve VULN "Your CPU doesn't support SSBD"
-				explain "Your kernel is recent enough to use the CPU microcode features for mitigation, but your CPU microcode doesn't actually provide the necessary features for the kernel to use. The microcode of your CPU hence needs to be upgraded. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section)."
+				pvulnstatus $cve VULN "Sua CPU não suporta SSBD"
+				explain "Seu kernel é recente o suficiente para usar os recursos de microcódigo da CPU para mitigação, mas o microcódigo da CPU não fornece os recursos necessários para o kernel usar. O microcódigo da sua CPU precisa, portanto, ser atualizado. Isso geralmente é feito no momento da inicialização pelo seu kernel (a atualização não é persistente nas reinicializações, e é por isso que é feita em cada inicialização). Se você estiver usando uma distribuição, verifique se está atualizado, pois as atualizações de microcódigo geralmente são enviadas juntamente com o kernel da distribuição. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware)."
 			else
-				pvulnstatus $cve VULN "Neither your CPU nor your kernel support SSBD"
-				explain "Both your CPU microcode and your kernel are lacking support for mitigation. If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel from recent-enough sources. The microcode of your CPU also needs to be upgraded. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section)."
+				pvulnstatus $cve VULN "Nem sua CPU nem seu kernel suportam SSBD"
+				explain "O microcódigo da CPU e o kernel estão sem suporte para mitigação. Se você estiver usando um kernel de distribuição, atualize sua distribuição para obter o kernel mais recente disponível. Caso contrário, recompile o kernel de fontes recentes o suficiente. O microcódigo da sua CPU também precisa ser atualizado. Isso geralmente é feito no momento da inicialização pelo seu kernel (a atualização não é persistente nas reinicializações, e é por isso que é feita em cada inicialização). Se você estiver usando uma distribuição, verifique se está atualizado, pois as atualizações de microcódigo geralmente são enviadas juntamente com o kernel da distribuição. A disponibilidade de uma atualização de microcódigo para o modelo da CPU depende do fornecedor da CPU. Geralmente, você pode descobrir on-line se uma atualização de microcódigo está disponível para sua CPU pesquisando seu CPUID (indicado na seção Verificação de Hardware)."
 			fi
 		fi
 	else
@@ -5188,50 +5188,50 @@ check_CVE_2018_3639_linux()
 
 check_CVE_2018_3639_bsd()
 {
-	_info_nol "* Kernel supports speculation store bypass: "
+	_info_nol "* O kernel suporta desvio de armazenamento de especulação: "
 	if sysctl hw.spec_store_bypass_disable >/dev/null 2>&1; then
 		kernel_ssb=1
-		pstatus green YES
+		pstatus green SIM
 	else
 		kernel_ssb=0
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
-	_info_nol "* Speculation store bypass is administratively enabled: "
+	_info_nol "* O desvio de armazenamento de especulação está ativado administrativamente: "
 	ssb_enabled=$(sysctl -n hw.spec_store_bypass_disable 2>/dev/null)
 	_debug "hw.spec_store_bypass_disable=$ssb_enabled"
 	case "$ssb_enabled" in
-		0) pstatus yellow NO "disabled";;
-		1) pstatus green YES "enabled";;
-		2) pstatus green YES "auto mode";;
-		*) pstatus yellow NO "unavailable";;
+		0) pstatus yellow NÃO "disabled";;
+		1) pstatus green SIM "enabled";;
+		2) pstatus green SIM "auto mode";;
+		*) pstatus yellow NÃO "unavailable";;
 	esac
 
-	_info_nol "* Speculation store bypass is currently active: "
+	_info_nol "* O desvio de armazenamento de especulação está ativo no momento: "
 	ssb_active=$(sysctl -n hw.spec_store_bypass_disable_active 2>/dev/null)
 	_debug "hw.spec_store_bypass_disable_active=$ssb_active"
 	case "$ssb_active" in
-		1) pstatus green YES;;
-		*) pstatus yellow NO;;
+		1) pstatus green SIM;;
+		*) pstatus yellow NÃO;;
 	esac
 
 	if ! is_cpu_affected "$cve"; then
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$ssb_active" = 1 ]; then
-				pvulnstatus $cve OK "SSBD mitigates the vulnerability"
+				pvulnstatus $cve OK "SSBD atenua a vulnerabilidade"
 		elif [ -n "$cpuid_ssbd" ]; then
 			if [ "$kernel_ssb" = 1 ]; then
-				pvulnstatus $cve VULN "you need to enable SSBD through sysctl to mitigate the vulnerability"
-				explain "To enable SSBD right now, you can run \`sysctl hw.spec_store_bypass_disable=2'. To make this change persistent across reboots, you can add 'sysctl hw.spec_store_bypass_disable=2' to /etc/sysctl.conf."
+				pvulnstatus $cve VULN "você precisa habilitar o SSBD por meio do sysctl para reduzir a vulnerabilidade"
+				explain "Para ativar o SSBD agora, você pode executar \`sysctl hw.spec_store_bypass_disable=2'. Para tornar essa alteração persistente nas reinicializações, você pode adicionar 'sysctl hw.spec_store_bypass_disable=2' para /etc/sysctl.conf."
 			else
-				pvulnstatus $cve VULN "your kernel needs to be updated"
+				pvulnstatus $cve VULN "seu kernel precisa ser atualizado"
 			fi
 		else
 			if [ "$kernel_ssb" = 1 ]; then
-				pvulnstatus $cve VULN "Your CPU doesn't support SSBD"
+				pvulnstatus $cve VULN "Sua CPU não suporta SSBD"
 			else
-				pvulnstatus $cve VULN "Neither your CPU nor your kernel support SSBD"
+				pvulnstatus $cve VULN "Nem sua CPU nem seu kernel suportam SSBD"
 			fi
 		fi
 	fi
@@ -5244,9 +5244,9 @@ check_CVE_2018_3639_bsd()
 check_CVE_2018_3615()
 {
 	cve='CVE-2018-3615'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 
-	_info_nol "* CPU microcode mitigates the vulnerability: "
+	_info_nol "* O microcódigo da CPU reduz a vulnerabilidade: "
 	if { [ "$cpu_flush_cmd" = 1 ] || { [ "$msr_locked_down" = 1 ] && [ "$cpuid_l1df" = 1 ]; }; } && [ "$cpuid_sgx" = 1 ]; then
 		# no easy way to detect a fixed SGX but we know that
 		# microcodes that have the FLUSH_CMD MSR also have the
@@ -5256,20 +5256,20 @@ check_CVE_2018_3615()
 		# if the system we're running on is locked down (no way to write MSRs),
 		# make the assumption that if the L1D flush CPUID bit is set, probably
 		# that FLUSH_CMD MSR is here too
-		pstatus green YES
+		pstatus green SIM
 	elif [ "$cpuid_sgx" = 1 ]; then
-		pstatus red NO
+		pstatus red NÃO
 	else
 		pstatus blue N/A
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ "$cpu_flush_cmd" = 1 ] || { [ "$msr_locked_down" = 1 ] && [ "$cpuid_l1df" = 1 ]; } ; then
-		pvulnstatus $cve OK "your CPU microcode mitigates the vulnerability"
+		pvulnstatus $cve OK "seu microcódigo da CPU reduz a vulnerabilidade"
 	else
-		pvulnstatus $cve VULN "your CPU supports SGX and the microcode is not up to date"
+		pvulnstatus $cve VULN "sua CPU suporta SGX e o microcódigo não está atualizado"
 	fi
 }
 
@@ -5277,19 +5277,19 @@ check_CVE_2018_3615()
 check_CVE_2018_3620()
 {
 	cve='CVE-2018-3620'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2018_3620_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2018_3620_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2018_3620_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/l1tf"; then
@@ -5297,60 +5297,60 @@ check_CVE_2018_3620_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Kernel supports PTE inversion: "
+		_info_nol "* O kernel suporta inversão PTE: "
 		if ! command -v "${opt_arch_prefix}strings" >/dev/null 2>&1; then
-			pstatus yellow UNKNOWN "missing 'strings' tool, please install it"
+			pstatus yellow DESCONHECIDO "ferramenta 'strings' em falta, instale-a"
 			pteinv_supported=-1
 		elif [ -n "$kernel_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_err"
+			pstatus yellow DESCONHECIDO "$kernel_err"
 			pteinv_supported=-1
 		else
-			if "${opt_arch_prefix}strings" "$kernel" | grep -Fq 'PTE Inversion'; then
-				pstatus green YES "found in kernel image"
-				_debug "pteinv: found pte inversion evidence in kernel image"
+			if "${opt_arch_prefix}strings" "$kernel" | grep -Fq 'Inversão PTE'; then
+				pstatus green SIM "encontrado na imagem do kernel"
+				_debug "pteinv: encontraram evidências de inversão de pte na imagem do kernel"
 				pteinv_supported=1
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 				pteinv_supported=0
 			fi
 		fi
 
-		_info_nol "* PTE inversion enabled and active: "
+		_info_nol "* Inversão de PTE ativada e ativa: "
 		if [ "$opt_live" = 1 ]; then
 			if [ -n "$fullmsg" ]; then
-				if echo "$fullmsg" | grep -q 'Mitigation: PTE Inversion'; then
-					pstatus green YES
+				if echo "$fullmsg" | grep -q 'Mitigação: Inversão PTE'; then
+					pstatus green SIM
 					pteinv_active=1
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 					pteinv_active=0
 				fi
 			else
-				pstatus yellow UNKNOWN "sysfs interface not available"
+				pstatus yellow DESCONHECIDO "interface sysfs não disponível"
 				pteinv_active=-1
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ "$pteinv_supported" = 1 ]; then
 			if [ "$pteinv_active" = 1 ] || [ "$opt_live" != 1 ]; then
-				pvulnstatus $cve OK "PTE inversion mitigates the vulnerability"
+				pvulnstatus $cve OK "Inversão de PTE atenua a vulnerabilidade"
 			else
-				pvulnstatus $cve VULN "Your kernel supports PTE inversion but it doesn't seem to be enabled"
+				pvulnstatus $cve VULN "Seu kernel suporta inversão PTE, mas não parece estar ativado"
 			fi
 		else
-			pvulnstatus $cve VULN "Your kernel doesn't support PTE inversion, update it"
+			pvulnstatus $cve VULN "Seu kernel não suporta inversão PTE, atualize-o"
 		fi
 	else
 		pvulnstatus $cve "$status" "$msg"
@@ -5359,32 +5359,32 @@ check_CVE_2018_3620_linux()
 
 check_CVE_2018_3620_bsd()
 {
-	_info_nol "* Kernel reserved the memory page at physical address 0x0: "
+	_info_nol "* O kernel reservou a página de memória no endereço físico 0x0: "
 	if ! kldstat -q -m vmm; then
 		kldload vmm 2>/dev/null && kldload_vmm=1
-		_debug "attempted to load module vmm, kldload_vmm=$kldload_vmm"
+		_debug "tentou carregar o módulo vmm, kldload_vmm=$kldload_vmm"
 	else
-		_debug "vmm module already loaded"
+		_debug "módulo vmm já carregado"
 	fi
 	if sysctl hw.vmm.vmx.l1d_flush >/dev/null 2>&1; then
 		# https://security.FreeBSD.org/patches/SA-18:09/l1tf-11.2.patch
 		# this is very difficult to detect that the kernel reserved the 0 page, but this fix
 		# is part of the exact same patch than the other L1TF CVE, so we detect it
 		# and deem it as OK if the other patch is there
-		pstatus green YES
+		pstatus green SIM
 		bsd_zero_reserved=1
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 		bsd_zero_reserved=0
 	fi
 
 	if ! is_cpu_affected "$cve"; then
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$bsd_zero_reserved" = 1 ]; then
-			pvulnstatus $cve OK "kernel mitigates the vulnerability"
+			pvulnstatus $cve OK "kernel mitiga a vulnerabilidade"
 		else
-			pvulnstatus $cve VULN "your kernel needs to be updated"
+			pvulnstatus $cve VULN "seu kernel precisa ser atualizado"
 		fi
 	fi
 }
@@ -5393,19 +5393,19 @@ check_CVE_2018_3620_bsd()
 check_CVE_2018_3646()
 {
 	cve='CVE-2018-3646'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2018_3646_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2018_3646_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2018_3646_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/l1tf" '.*' quiet; then
@@ -5416,46 +5416,46 @@ check_CVE_2018_3646_linux()
 	if [ "$opt_sysfs_only" != 1 ]; then
 		check_has_vmm
 
-		_info "* Mitigation 1 (KVM)"
-		_info_nol "  * EPT is disabled: "
+		_info "* Mitigação 1 (KVM)"
+		_info_nol "  * O EPT está desativado: "
 		ept_disabled=-1
 		if [ "$opt_live" = 1 ]; then
 			if ! [ -r /sys/module/kvm_intel/parameters/ept ]; then
-				pstatus blue N/A "the kvm_intel module is not loaded"
+				pstatus blue N/A "o módulo kvm_intel não está carregado"
 			elif [ "$(cat /sys/module/kvm_intel/parameters/ept)" = N ]; then
-				pstatus green YES
+				pstatus green SIM
 				ept_disabled=1
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info "* Mitigation 2"
-		_info_nol "  * L1D flush is supported by kernel: "
+		_info "* Mitigação 2"
+		_info_nol "  * O L1D flush é suportado pelo kernel: "
 		if [ "$opt_live" = 1 ] && grep -qw flush_l1d "$procfs/cpuinfo"; then
-			l1d_kernel="found flush_l1d in $procfs/cpuinfo"
+			l1d_kernel="encontrado flush_l1d em $procfs/cpuinfo"
 		fi
 		if [ -z "$l1d_kernel" ]; then
 			if ! command -v "${opt_arch_prefix}strings" >/dev/null 2>&1; then
-				l1d_kernel_err="missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package"
+				l1d_kernel_err="faltando a ferramenta '${opt_arch_prefix}strings', instale-a, geralmente está no pacote binutils"
 			elif [ -n "$kernel_err" ]; then
 				l1d_kernel_err="$kernel_err"
 			elif "${opt_arch_prefix}strings" "$kernel" | grep -qw flush_l1d; then
-				l1d_kernel='found flush_l1d in kernel image'
+				l1d_kernel='encontrado flush_l1d na imagem do kernel'
 			fi
 		fi
 
 		if [ -n "$l1d_kernel" ]; then
-			pstatus green YES "$l1d_kernel"
+			pstatus green SIM "$l1d_kernel"
 		elif [ -n "$l1d_kernel_err" ]; then
-			pstatus yellow UNKNOWN "$l1d_kernel_err"
+			pstatus yellow DESCONHECIDO "$l1d_kernel_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "  * L1D flush enabled: "
+		_info_nol "  * Liberação L1D ativada: "
 		if [ "$opt_live" = 1 ]; then
 			if [ -n "$fullmsg" ]; then
 				# vanilla: VMX: $l1dstatus, SMT $smtstatus
@@ -5465,13 +5465,13 @@ check_CVE_2018_3646_linux()
 				# can also just be "Not affected"
 				if echo "$fullmsg" | grep -Eq -e 'Not affected' -e '(VMX:|L1D) (EPT disabled|vulnerable|flush not necessary)'; then
 					l1d_mode=0
-					pstatus yellow NO
+					pstatus yellow NÃO
 				elif echo "$fullmsg" | grep -Eq '(VMX:|L1D) conditional cache flushes'; then
 					l1d_mode=1
-					pstatus green YES "conditional flushes"
+					pstatus green SIM "descargas condicionais"
 				elif echo "$fullmsg" | grep -Eq '(VMX:|L1D) cache flushes'; then
 					l1d_mode=2
-					pstatus green YES "unconditional flushes"
+					pstatus green SIM "descargas incondicionais"
 				else
 					if is_xen_dom0; then
 						l1d_xen_hardware=$(xl dmesg | grep 'Hardware features:' | grep 'L1D_FLUSH' | head -1)
@@ -5480,131 +5480,131 @@ check_CVE_2018_3646_linux()
 
 						if [ -n "$l1d_xen_hardware" ] && [ -n "$l1d_xen_hypervisor" ] && [ -n "$l1d_xen_pv_domU" ]; then
 							l1d_mode=5
-							pstatus green YES "for XEN guests"
+							pstatus green SIM "para convidados XEN"
 						elif [ -n "$l1d_xen_hardware" ] && [ -n "$l1d_xen_hypervisor" ]; then
 							l1d_mode=4
-							pstatus yellow YES "for XEN guests (HVM only)"
+							pstatus yellow SIM "para convidados XEN (apenas HVM)"
 						elif [ -n "$l1d_xen_pv_domU" ]; then
 							l1d_mode=3
-							pstatus yellow YES "for XEN guests (PV only)"
+							pstatus yellow SIM "para convidados XEN (somente PV)"
 						else
 							l1d_mode=0
-							pstatus yellow NO "for XEN guests"
+							pstatus yellow NÃO "para convidados XEN"
 						fi
 					else
 						l1d_mode=-1
-						pstatus yellow UNKNOWN "unrecognized mode"
+						pstatus yellow DESCONHECIDO "modo não reconhecido"
 					fi
 				fi
 			else
 				l1d_mode=-1
-				pstatus yellow UNKNOWN "can't find or read /sys/devices/system/cpu/vulnerabilities/l1tf"
+				pstatus yellow DESCONHECIDO "não consegue encontrar ou ler /sys/devices/system/cpu/vulnerabilities/l1tf"
 			fi
 		else
 			l1d_mode=-1
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info_nol "  * Hardware-backed L1D flush supported: "
+		_info_nol "  * Flush L1D suportado por hardware suportado: "
 		if [ "$opt_live" = 1 ]; then
 			if grep -qw flush_l1d "$procfs/cpuinfo" || [ -n "$l1d_xen_hardware" ]; then
-				pstatus green YES "performance impact of the mitigation will be greatly reduced"
+				pstatus green SIM "impacto no desempenho da mitigação será bastante reduzido"
 			else
-				pstatus blue NO "flush will be done in software, this is slower"
+				pstatus blue NÃO "flush será feito em software, isso é mais lento"
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info_nol "  * Hyper-Threading (SMT) is enabled: "
+		_info_nol "  * O Hyper-Threading (SMT) está ativado: "
 		is_cpu_smt_enabled; smt_enabled=$?
 		if [ "$smt_enabled" = 0 ]; then
-			pstatus yellow YES
+			pstatus yellow SIM
 		elif [ "$smt_enabled" = 1 ]; then
-			pstatus green NO
+			pstatus green NÃO
 		else
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 		fi
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 		l1d_mode=-1
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
-	elif [ "$fullmsg" = "Not affected" ]; then
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
+	elif [ "$fullmsg" = "Não afetado" ]; then
 		# just in case a very recent kernel knows better than we do
-		pvulnstatus $cve OK "your kernel reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu kernel relatou seu modelo de CPU como não afetado"
 	elif [ "$has_vmm" = 0 ]; then
-		pvulnstatus $cve OK "this system is not running a hypervisor"
+		pvulnstatus $cve OK "este sistema não está executando um hypervisor"
 	else
 		if [ "$ept_disabled" = 1 ]; then
-			pvulnstatus $cve OK "EPT is disabled which mitigates the vulnerability"
+			pvulnstatus $cve OK "O EPT está desativado, o que atenua a vulnerabilidade"
 		elif [ "$opt_paranoid" = 0 ]; then
 			if [ "$l1d_mode" -ge 1 ]; then
-				pvulnstatus $cve OK "L1D flushing is enabled and mitigates the vulnerability"
+				pvulnstatus $cve OK "A liberação do L1D está ativada e atenua a vulnerabilidade"
 			else
-				pvulnstatus $cve VULN "disable EPT or enable L1D flushing to mitigate the vulnerability"
+				pvulnstatus $cve VULN "desabilite o EPT ou ative a liberação de L1D para atenuar a vulnerabilidade"
 			fi
 		else
 			if [ "$l1d_mode" -ge 2 ]; then
 				if [ "$smt_enabled" = 1 ]; then
-					pvulnstatus $cve OK "L1D unconditional flushing and Hyper-Threading disabled are mitigating the vulnerability"
+					pvulnstatus $cve OK "A descarga incondicional do L1D e o Hyper-Threading desativado estão mitigando a vulnerabilidade"
 				else
-					pvulnstatus $cve VULN "Hyper-Threading must be disabled to fully mitigate the vulnerability"
+					pvulnstatus $cve VULN "O Hyper-Threading deve estar desabilitado para reduzir totalmente a vulnerabilidade"
 				fi
 			else
 				if [ "$smt_enabled" = 1 ]; then
-					pvulnstatus $cve VULN "L1D unconditional flushing should be enabled to fully mitigate the vulnerability"
+					pvulnstatus $cve VULN "A descarga incondicional do L1D deve ser ativada para reduzir completamente a vulnerabilidade"
 				else
-					pvulnstatus $cve VULN "enable L1D unconditional flushing and disable Hyper-Threading to fully mitigate the vulnerability"
+					pvulnstatus $cve VULN "habilite a liberação incondicional do L1D e desative o Hyper-Threading para reduzir completamente a vulnerabilidade"
 				fi
 			fi
 		fi
 
 		if [ $l1d_mode -gt 3 ]; then
 			_warn
-			_warn "This host is a Xen Dom0. Please make sure that you are running your DomUs"
-			_warn "with a kernel which contains CVE-2018-3646 mitigations."
+			_warn "Este host é um Xen Dom0. Verifique se você está executando seus DomUs"
+			_warn "com um kernel que contém atenuações CVE-2018-3646."
 			_warn
-			_warn "See https://www.suse.com/support/kb/doc/?id=7023078 and XSA-273 for details."
+			_warn "Veja https://www.suse.com/support/kb/doc/?id=7023078 e XSA-273 para detalhes."
 		fi
 	fi
 }
 
 check_CVE_2018_3646_bsd()
 {
-	_info_nol "* Kernel supports L1D flushing: "
+	_info_nol "* O kernel suporta liberação L1D: "
 	if sysctl hw.vmm.vmx.l1d_flush >/dev/null 2>&1; then
-		pstatus green YES
+		pstatus green SIM
 		kernel_l1d_supported=1
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 		kernel_l1d_supported=0
 	fi
 
-	_info_nol "* L1D flushing is enabled: "
+	_info_nol "* A descarga do L1D está ativada: "
 	kernel_l1d_enabled=$(sysctl -n hw.vmm.vmx.l1d_flush 2>/dev/null)
 	case "$kernel_l1d_enabled" in
-		0) pstatus yellow NO;;
-		1) pstatus green YES;;
-		"") pstatus yellow NO;;
-		*) pstatus yellow UNKNOWN;;
+		0) pstatus yellow NÃO;;
+		1) pstatus green SIM;;
+		"") pstatus yellow NÃO;;
+		*) pstatus yellow DESCONHECIDO;;
 	esac
 
 	if ! is_cpu_affected "$cve"; then
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$kernel_l1d_enabled" = 1 ]; then
-			pvulnstatus $cve OK "L1D flushing mitigates the vulnerability"
+			pvulnstatus $cve OK "A descarga de L1D atenua a vulnerabilidade"
 		elif [ "$kernel_l1d_supported" = 1 ]; then
-			pvulnstatus $cve VULN "L1D flushing is supported by your kernel but is disabled"
+			pvulnstatus $cve VULN "A liberação do L1D é suportada pelo seu kernel, mas está desativada"
 		else
-			pvulnstatus $cve VULN "your kernel needs to be updated"
+			pvulnstatus $cve VULN "seu kernel precisa ser atualizado"
 		fi
 	fi
 }
@@ -5653,64 +5653,64 @@ check_CVE_2019_11091()
 check_mds()
 {
 	cve=$1
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_mds_linux "$cve"
 	elif echo "$os" | grep -q BSD; then
 		check_mds_bsd "$cve"
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_mds_bsd()
 {
-	_info_nol "* Kernel supports using MD_CLEAR mitigation: "
+	_info_nol "* O kernel suporta o uso da mitigação MD_CLEAR: "
 	if [ "$opt_live" = 1 ]; then
 		if sysctl hw.mds_disable >/dev/null 2>&1; then
-			pstatus green YES
+			pstatus green SIM
 			kernel_md_clear=1
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 			kernel_md_clear=0
 		fi
 	else
 		if grep -Fq hw.mds_disable $opt_kernel; then
-			pstatus green YES
+			pstatus green SIM
 			kernel_md_clear=1
 		else
 			kernel_md_clear=0
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 	fi
 
-	_info_nol "* CPU Hyper-Threading (SMT) is disabled: "
+	_info_nol "* O Hyper-Threading da CPU (SMT) está desativado: "
 	if sysctl machdep.hyperthreading_allowed >/dev/null 2>&1; then
 		kernel_smt_allowed=$(sysctl -n machdep.hyperthreading_allowed 2>/dev/null)
 		if [ "$kernel_smt_allowed" = 1 ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 		else
-			pstatus green YES
+			pstatus green SIM
 		fi
 	else
-		pstatus yellow UNKNOWN "sysctl machdep.hyperthreading_allowed doesn't exist"
+		pstatus yellow DESCONHECIDO "sysctl machdep.hyperthreading_allowed não existe"
 	fi
 
-	_info_nol "* Kernel mitigation is enabled: "
+	_info_nol "* A atenuação do kernel está ativada: "
 	if [ "$kernel_md_clear" = 1 ]; then
 		kernel_mds_enabled=$(sysctl -n hw.mds_disable 2>/dev/null)
 	else
 		kernel_mds_enabled=0
 	fi
 	case "$kernel_mds_enabled" in
-		0) pstatus yellow NO;;
-		1) pstatus green YES "with microcode support";;
-		2) pstatus green YES "software-only support (SLOW)";;
-		3) pstatus green YES;;
-		*) pstatus yellow UNKNOWN "unknown value $kernel_mds_enabled"
+		0) pstatus yellow NÃO;;
+		1) pstatus green SIM "com suporte a microcódigo";;
+		2) pstatus green SIM "suporte somente de software (LENTO)";;
+		3) pstatus green SIM;;
+		*) pstatus yellow DESCONHECIDO "valor desconhecido $kernel_mds_enabled"
 	esac
 
-	_info_nol "* Kernel mitigation is active: "
+	_info_nol "* A mitigação do kernel está ativa: "
 	if [ "$kernel_md_clear" = 1 ]; then
 		kernel_mds_state=$(sysctl -n hw.mds_disable_state 2>/dev/null)
 	else
@@ -5718,14 +5718,14 @@ check_mds_bsd()
 	fi
 	# https://github.com/freebsd/freebsd/blob/master/sys/x86/x86/cpu_machdep.c#L953
 	case "$kernel_mds_state" in
-		inactive)  pstatus yellow NO;;
-		VERW)      pstatus green YES "with microcode support";;
-		software*) pstatus green YES "software-only support (SLOW)";;
-		*)         pstatus yellow UNKNOWN
+		inactive)  pstatus yellow NÃO;;
+		VERW)      pstatus green SIM "com suporte a microcódigo";;
+		software*) pstatus green SIM "suporte somente de software (LENTO)";;
+		*)         pstatus yellow DESCONHECIDO
 	esac
 
 	if ! is_cpu_affected "$cve"; then
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$cpuid_md_clear" = 1 ]; then
 			if [ "$kernel_md_clear" = 1 ]; then
@@ -5733,25 +5733,25 @@ check_mds_bsd()
 					# mitigation must also be enabled
 					if [ "$kernel_mds_enabled" -ge 1 ]; then
 						if [ "$opt_paranoid" != 1 ] || [ "$kernel_smt_allowed" = 0 ]; then
-							pvulnstatus "$cve" OK "Your microcode and kernel are both up to date for this mitigation, and mitigation is enabled"
+							pvulnstatus "$cve" OK "Seu microcódigo e kernel estão atualizados para essa mitigação, e a mitigação está ativada"
 						else
-							pvulnstatus "$cve" VULN "Your microcode and kernel are both up to date for this mitigation, but you must disable SMT (Hyper-Threading) for a complete mitigation"
+							pvulnstatus "$cve" VULN "Seu microcódigo e kernel estão atualizados para essa atenuação, mas você deve desativar o SMT (Hyper-Threading) para obter uma atenuação completa"
 						fi
 					else
-						pvulnstatus "$cve" VULN "Your microcode and kernel are both up to date for this mitigation, but the mitigation is not active"
-						explain "To enable mitigation, run \`sysctl hw.mds_disable=1'. To make this change persistent across reboots, you can add 'hw.mds_disable=1' to /etc/sysctl.conf."
+						pvulnstatus "$cve" VULN "Seu microcódigo e kernel estão atualizados para essa atenuação, mas a atenuação não está ativa"
+						explain "Para habilitar a mitigação, execute \`sysctl hw.mds_disable=1'. Para tornar essa alteração persistente nas reinicializações, você pode adicionar 'hw.mds_disable=1' para /etc/sysctl.conf."
 					fi
 				else
-					pvulnstatus "$cve" OK "Your microcode and kernel are both up to date for this mitigation"
+					pvulnstatus "$cve" OK "Seu microcódigo e kernel estão atualizados para essa mitigação"
 				fi
 			else
-				pvulnstatus "$cve" VULN "Your microcode supports mitigation, but your kernel doesn't, upgrade it to mitigate the vulnerability"
+				pvulnstatus "$cve" VULN "Seu microcódigo suporta mitigação, mas seu kernel não, atualize-o para reduzir a vulnerabilidade"
 			fi
 		else
 			if [ "$kernel_md_clear" = 1 ]; then
-				pvulnstatus "$cve" VULN "Your kernel supports mitigation, but your CPU microcode also needs to be updated to mitigate the vulnerability"
+				pvulnstatus "$cve" VULN "Seu kernel suporta mitigação, mas o microcódigo da CPU também precisa ser atualizado para reduzir a vulnerabilidade"
 			else
-				pvulnstatus "$cve" VULN "Neither your kernel or your microcode support mitigation, upgrade both to mitigate the vulnerability"
+				pvulnstatus "$cve" VULN "Nem o seu kernel nem o seu microcódigo suportam mitigação, atualize os dois para reduzir a vulnerabilidade"
 			fi
 		fi
 	fi
@@ -5759,7 +5759,7 @@ check_mds_bsd()
 
 check_mds_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/mds" '^[^;]+'; then
@@ -5767,12 +5767,12 @@ check_mds_linux()
 	fi
 
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Kernel supports using MD_CLEAR mitigation: "
+		_info_nol "* O kernel suporta o uso da mitigação MD_CLEAR: "
 		kernel_md_clear=''
 		kernel_md_clear_can_tell=1
 		if [ "$opt_live" = 1 ] && grep ^flags "$procfs/cpuinfo" | grep -qw md_clear; then
-			kernel_md_clear="md_clear found in $procfs/cpuinfo"
-			pstatus green YES "$kernel_md_clear"
+			kernel_md_clear="md_clear encontrado em  $procfs/cpuinfo"
+			pstatus green SIM "$kernel_md_clear"
 		fi
 		if [ -z "$kernel_md_clear" ]; then
 			if ! command -v "${opt_arch_prefix}strings" >/dev/null 2>&1; then
@@ -5780,46 +5780,46 @@ check_mds_linux()
 			elif [ -n "$kernel_err" ]; then
 				kernel_md_clear_can_tell=0
 			elif "${opt_arch_prefix}strings" "$kernel" | grep -q 'Clear CPU buffers'; then
-				_debug "md_clear: found 'Clear CPU buffers' string in kernel image"
-				kernel_md_clear='found md_clear implementation evidence in kernel image'
-				pstatus green YES "$kernel_md_clear"
+				_debug "md_clear: encontrou a string 'Clear CPU buffers' na imagem do kernel"
+				kernel_md_clear='encontrou evidências de implementação md_clear na imagem do kernel'
+				pstatus green SIM "$kernel_md_clear"
 			fi
 		fi
 		if [ -z "$kernel_md_clear" ]; then
 			if [ "$kernel_md_clear_can_tell" = 1 ]; then
-				pstatus yellow NO
+				pstatus yellow NÃO
 			else
-				pstatus yellow UNKNOWN
+				pstatus yellow DESCONHECIDO
 			fi
 		fi
 
 		if [ "$opt_live" = 1 ] && [ "$sys_interface_available" = 1 ]; then
-			_info_nol "* Kernel mitigation is enabled and active: "
+			_info_nol "* A mitigação do kernel está ativada e ativa: "
 			if echo "$fullmsg" | grep -qi ^mitigation; then
 				mds_mitigated=1
-				pstatus green YES
+				pstatus green SIM
 			else
 				mds_mitigated=0
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
-			_info_nol "* SMT is either mitigated or disabled: "
+			_info_nol "* O SMT é mitigado ou desativado: "
 			if echo "$fullmsg" | grep -Eq 'SMT (disabled|mitigated)'; then
 				mds_smt_mitigated=1
-				pstatus green YES
+				pstatus green SIM
 			else
 				mds_smt_mitigated=0
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		fi
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	else
 		if [ "$opt_sysfs_only" != 1 ]; then
 			# compute mystatus and mymsg from our own logic
@@ -5830,30 +5830,30 @@ check_mds_linux()
 						if [ "$mds_mitigated" = 1 ]; then
 							if [ "$opt_paranoid" != 1 ] || [ "$mds_smt_mitigated" = 1 ]; then
 								mystatus=OK
-								mymsg="Your microcode and kernel are both up to date for this mitigation, and mitigation is enabled"
+								mymsg="Seu microcódigo e kernel estão atualizados para essa mitigação, e a mitigação está ativada"
 							else
 								mystatus=VULN
-								mymsg="Your microcode and kernel are both up to date for this mitigation, but you must disable SMT (Hyper-Threading) for a complete mitigation"
+								mymsg="Seu microcódigo e kernel estão atualizados para essa atenuação, mas você deve desativar o SMT (Hyper-Threading) para obter uma atenuação completa"
 							fi
 						else
 							mystatus=VULN
-							mymsg="Your microcode and kernel are both up to date for this mitigation, but the mitigation is not active"
+							mymsg="Seu microcódigo e kernel estão atualizados para essa atenuação, mas a atenuação não está ativa"
 						fi
 					else
 						mystatus=OK
-						mymsg="Your microcode and kernel are both up to date for this mitigation"
+						mymsg="Seu microcódigo e kernel estão atualizados para essa mitigação"
 					fi
 				else
 					mystatus=VULN
-					mymsg="Your microcode supports mitigation, but your kernel doesn't, upgrade it to mitigate the vulnerability"
+					mymsg="Seu microcódigo suporta mitigação, mas seu kernel não, atualize-o para reduzir a vulnerabilidade"
 				fi
 			else
 				if [ -n "$kernel_md_clear" ]; then
 					mystatus=VULN
-					mymsg="Your kernel supports mitigation, but your CPU microcode also needs to be updated to mitigate the vulnerability"
+					mymsg="Seu kernel suporta mitigação, mas o microcódigo da CPU também precisa ser atualizado para reduzir a vulnerabilidade"
 				else
 					mystatus=VULN
-					mymsg="Neither your kernel or your microcode support mitigation, upgrade both to mitigate the vulnerability"
+					mymsg="Nem o seu kernel nem o seu microcódigo suportam mitigação, atualize os dois para reduzir a vulnerabilidade"
 				fi
 			fi
 		else
@@ -5886,19 +5886,19 @@ check_mds_linux()
 check_CVE_2019_11135()
 {
 	cve='CVE-2019-11135'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2019_11135_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2019_11135_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2019_11135_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/tsx_async_abort"; then
@@ -5906,63 +5906,63 @@ check_CVE_2019_11135_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* TAA mitigation is supported by kernel: "
+		_info_nol "* A mitigação de TAA é suportada pelo kernel: "
 		kernel_taa=''
 		if [ -n "$kernel_err" ]; then
 			kernel_taa_err="$kernel_err"
 		elif grep -q 'tsx_async_abort' "$kernel"; then
-			kernel_taa="found tsx_async_abort in kernel image"
+			kernel_taa="tsx_async_abort encontrado na imagem do kernel"
 		fi
 		if [ -n "$kernel_taa" ]; then
-			pstatus green YES "$kernel_taa"
+			pstatus green SIM "$kernel_taa"
 		elif [ -n "$kernel_taa_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_taa_err"
+			pstatus yellow DESCONHECIDO "$kernel_taa_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "* TAA mitigation enabled and active: "
+		_info_nol "* Atenuação de TAA ativada e ativa: "
 		if [ "$opt_live" = 1 ]; then
 			if [ -n "$fullmsg" ]; then
 				if echo "$fullmsg" | grep -qE '^Mitigation'; then
-					pstatus green YES "$fullmsg"
+					pstatus green SIM "$fullmsg"
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 				fi
 			else
-				pstatus yellow NO "tsx_async_abort not found in sysfs hierarchy"
+				pstatus yellow NÃO "tsx_async_abort não encontrado na hierarquia do sysfs"
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ "$opt_live" = 1 ]; then
 			# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old
-			pvulnstatus $cve VULN "Your kernel doesn't support TAA mitigation, update it"
+			pvulnstatus $cve VULN "Seu kernel não suporta mitigação de TAA, atualize-o"
 		else
 			if [ -n "$kernel_taa" ]; then
-				pvulnstatus $cve OK "Your kernel supports TAA mitigation"
+				pvulnstatus $cve OK "Seu kernel suporta mitigação de TAA"
 			else
-				pvulnstatus $cve VULN "Your kernel doesn't support TAA mitigation, update it"
+				pvulnstatus $cve VULN "Seu kernel não suporta mitigação de TAA, atualize-o"
 			fi
 		fi
 	else
 		if [ "$opt_paranoid" = 1 ]; then
 			# in paranoid mode, TSX or SMT enabled are not OK, even if TAA is mitigated
-			if ! echo "$fullmsg" | grep -qF 'TSX disabled'; then
-				pvulnstatus $cve VULN "TSX must be disabled for full mitigation"
-			elif echo "$fullmsg" | grep -qF 'SMT vulnerable'; then
-				pvulnstatus $cve VULN "SMT (HyperThreading) must be disabled for full mitigation"
+			if ! echo "$fullmsg" | grep -qF 'TSX desativado'; then
+				pvulnstatus $cve VULN "O TSX deve estar desativado para mitigação total"
+			elif echo "$fullmsg" | grep -qF 'Vulnerável a SMT'; then
+				pvulnstatus $cve VULN "O SMT (HyperThreading) deve estar desativado para mitigação total"
 			else
 				pvulnstatus $cve "$status" "$msg"
 			fi
@@ -5976,9 +5976,9 @@ check_CVE_2019_11135_bsd()
 {
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU não foi afetado"
 	else
-		pvulnstatus "$cve" UNK "your CPU is affected, but mitigation detection has not yet been implemented for BSD in this script"
+		pvulnstatus "$cve" DES "sua CPU é afetada, mas a detecção de mitigação ainda não foi implementada para BSD neste script"
 	fi
 }
 
@@ -5988,19 +5988,19 @@ check_CVE_2019_11135_bsd()
 check_CVE_2018_12207()
 {
 	cve='CVE-2018-12207'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2018_12207_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2018_12207_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2018_12207_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/itlb_multihit"; then
@@ -6010,57 +6010,57 @@ check_CVE_2018_12207_linux()
 	if [ "$opt_sysfs_only" != 1 ]; then
 		check_has_vmm
 
-		_info_nol "* iTLB Multihit mitigation is supported by kernel: "
+		_info_nol "* A atenuação do iTLB Multihit é suportada pelo kernel: "
 		kernel_itlbmh=''
 		if [ -n "$kernel_err" ]; then
 			kernel_itlbmh_err="$kernel_err"
 		# commit 5219505fcbb640e273a0d51c19c38de0100ec5a9
 		elif grep -q 'itlb_multihit' "$kernel"; then
-			kernel_itlbmh="found itlb_multihit in kernel image"
+			kernel_itlbmh="encontrou itlb_multihit na imagem do kernel"
 		fi
 		if [ -n "$kernel_itlbmh" ]; then
-			pstatus green YES "$kernel_itlbmh"
+			pstatus green SIM "$kernel_itlbmh"
 		elif [ -n "$kernel_itlbmh_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_itlbmh_err"
+			pstatus yellow DESCONHECIDO "$kernel_itlbmh_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "* iTLB Multihit mitigation enabled and active: "
+		_info_nol "* Ativação iTLB Multihit ativada e ativa: "
 		if [ "$opt_live" = 1 ]; then
 			if [ -n "$fullmsg" ]; then
 				if echo "$fullmsg" | grep -qF 'Mitigation'; then
-					pstatus green YES "$fullmsg"
+					pstatus green SIM "$fullmsg"
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 				fi
 			else
-				pstatus yellow NO "itlb_multihit not found in sysfs hierarchy"
+				pstatus yellow NÃO "itlb_multihit não encontrado na hierarquia do sysfs"
 			fi
 		else
 			pstatus blue N/A "not testable in offline mode"
 		fi
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="uso da interface de vulnerabilidade /sys forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU como não afetado"
 	elif [ "$has_vmm" = 0 ]; then
-		pvulnstatus "$cve" OK "this system is not running a hypervisor"
+		pvulnstatus "$cve" OK "este sistema não está executando um hypervisor"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ "$opt_live" = 1 ]; then
 			# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old
-			pvulnstatus $cve VULN "Your kernel doesn't support iTLB Multihit mitigation, update it"
+			pvulnstatus $cve VULN "Seu kernel não suporta a atenuação do iTLB Multihit, atualize-o"
 		else
 			if [ -n "$kernel_itlbmh" ]; then
-				pvulnstatus $cve OK "Your kernel supports iTLB Multihit mitigation"
+				pvulnstatus $cve OK "Seu kernel suporta a atenuação do iTLB Multihit"
 			else
-				pvulnstatus $cve VULN "Your kernel doesn't support iTLB Multihit mitigation, update it"
+				pvulnstatus $cve VULN "Seu kernel não suporta a atenuação do iTLB Multihit, atualize-o"
 			fi
 		fi
 	else
@@ -6070,31 +6070,31 @@ check_CVE_2018_12207_linux()
 
 check_CVE_2018_12207_bsd()
 {
-	_info_nol "* Kernel supports disabling superpages for executable mappings under EPT: "
+	_info_nol "* Kernel suporta desabilitar superpáginas para mapeamentos executáveis em EPT: "
 	kernel_2m_x_ept=$(sysctl -n vm.pmap.allow_2m_x_ept 2>/dev/null)
 	if [ -z "$kernel_2m_x_ept" ]; then
-		pstatus yellow NO
+		pstatus yellow NÃO
 	else
-		pstatus green YES
+		pstatus green SIM
 	fi
 
-	_info_nol "* Superpages are disabled for executable mappings under EPT: "
+	_info_nol "* Superpáginas estão desabilitadas para mapeamentos executáveis em EPT: "
 	if [ "$kernel_2m_x_ept" = 0 ]; then
-		pstatus green YES
+		pstatus green SIM
 	else
-		pstatus yellow NO
+		pstatus yellow NÃO
 	fi
 
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU não foi afetado"
 	elif [ -z "$kernel_2m_x_ept" ]; then
-		pvulnstatus $cve VULN "Your kernel doesn't support mitigating this CVE, you should update it"
+		pvulnstatus $cve VULN "Seu kernel não suporta mitigar este CVE, você deve atualizá-lo"
 	elif [ "$kernel_2m_x_ept" != 0 ]; then
-		pvulnstatus $cve VULN "Your kernel supports mitigating this CVE, but the mitigation is disabled"
-		explain "To enable the mitigation, use \`sysctl vm.pmap.allow_2m_x_ept=0\`"
+		pvulnstatus $cve VULN "Seu kernel suporta a mitigação deste CVE, mas a mitigação está desabilitada"
+		explain "Para habilitar a mitigação, use \`sysctl vm.pmap.allow_2m_x_ept=0\`"
 	else
-		pvulnstatus $cve OK "Your kernel has support for mitigation and the mitigation is enabled"
+		pvulnstatus $cve OK "Seu kernel tem suporte para mitigação e a mitigação está habilitada"
 	fi
 }
 
@@ -6105,19 +6105,19 @@ check_CVE_2018_12207_bsd()
 check_CVE_2020_0543()
 {
 	cve='CVE-2020-0543'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2020_0543_linux
 	elif echo "$os" | grep -q BSD; then
 		check_CVE_2020_0543_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não suportado ($os)"
 	fi
 }
 
 check_CVE_2020_0543_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if sys_interface_check "/sys/devices/system/cpu/vulnerabilities/srbds"; then
@@ -6125,42 +6125,42 @@ check_CVE_2020_0543_linux()
 		sys_interface_available=1
 	fi
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* SRBDS mitigation control is supported by the kernel: "
+		_info_nol "* O controle de mitigação SRBDS é suportado pelo kernel: "
 		kernel_srbds=''
 		if [ -n "$kernel_err" ]; then
 			kernel_srbds_err="$kernel_err"
-		elif grep -q 'Dependent on hypervisor' "$kernel"; then
-			kernel_srbds="found SRBDS implementation evidence in kernel image. Your kernel is up to date for SRBDS mitigation"
+		elif grep -q 'Dependente do hipervisor' "$kernel"; then
+			kernel_srbds="encontrou evidências de implementação de SRBDS na imagem do kernel. Seu kernel está atualizado para mitigação SRBDS"
 		fi
 		if [ -n "$kernel_srbds" ]; then
-			pstatus green YES "$kernel_srbds"
+			pstatus green SIM "$kernel_srbds"
 		elif [ -n "$kernel_srbds_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_srbds_err"
+			pstatus yellow DESCONHECIDO "$kernel_srbds_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
-		_info_nol "* SRBDS mitigation control is enabled and active: "
+		_info_nol "* O controle de mitigação SRBDS está habilitado e ativo: "
 		if [ "$opt_live" = 1 ]; then
 			if [ -n "$fullmsg" ]; then
 				if echo "$fullmsg" | grep -qE '^Mitigation'; then
-					pstatus green YES "$fullmsg"
+					pstatus green SIM "$fullmsg"
 				else
-					pstatus yellow NO
+					pstatus yellow NÃO
 				fi
 			else
-				pstatus yellow NO "SRBDS not found in sysfs hierarchy"
+				pstatus yellow NÃO "SRBDS não encontrado na hierarquia sysfs"
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável em modo offline"
 		fi
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="A interface de vulnerabilidade /sys usa forçado, mas não está disponível!"
+		status=DESC
 	fi
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou que seu modelo de CPU não é afetado"
 	else
 		if [ "$opt_sysfs_only" != 1 ]; then
 			if [ "$cpuid_srbds" = 1 ]; then
@@ -6171,13 +6171,13 @@ check_CVE_2020_0543_linux()
 						# if msg is empty, sysfs check didn't fill it, rely on our own test
 						if [ "$opt_live" = 1 ]; then
 							# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old
-							pvulnstatus "$cve" OK "Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated"
+							pvulnstatus "$cve" OK "Seu microcódigo está atualizado para o controle de mitigação SRBDS. O kernel precisa ser atualizado"
 						fi
 					else
 						if [ -n "$kernel_srbds" ]; then
-							pvulnstatus "$cve" OK "Your microcode and kernel are both up to date for SRBDS mitigation control. Mitigation is enabled"
+							pvulnstatus "$cve" OK "Seu microcódigo e kernel estão atualizados para o controle de mitigação SRBDS. Mitigação está habilitada"
 						else
-							pvulnstatus "$cve" OK "Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated"
+							pvulnstatus "$cve" OK "Seu microcódigo está atualizado para o controle de mitigação SRBDS. O kernel precisa ser atualizado"
 						fi
 					fi
 				elif [ "$srbds_on" = 0 ]; then
@@ -6185,22 +6185,22 @@ check_CVE_2020_0543_linux()
 					if [ -z "$msg" ]; then
 						if [ "$opt_live" = 1 ]; then
 							# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old
-							pvulnstatus "$cve" VULN "Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated. Mitigation is disabled"
+							pvulnstatus "$cve" VULN "Seu microcódigo está atualizado para o controle de mitigação SRBDS. O kernel precisa ser atualizado. Mitigação está desativada"
 						fi
 					else
 						if [ -n "$kernel_srbds" ]; then
-							pvulnstatus "$cve" VULN "Your microcode and kernel are both up to date for SRBDS mitigation control. Mitigation is disabled"
+							pvulnstatus "$cve" VULN "Seu microcódigo e kernel estão atualizados para o controle de mitigação SRBDS. Mitigação está desativada"
 						else
-							pvulnstatus "$cve" VULN "Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated. Mitigation is disabled"
+							pvulnstatus "$cve" VULN "Seu microcódigo está atualizado para o controle de mitigação SRBDS. O kernel precisa ser atualizado. Mitigação está desativada"
 						fi
 					fi
 				else
 					# rdmsr: CPU 0 cannot read MSR 0x00000123
-					pvulnstatus "$cve" UNK "Not able to enumerate MSR for SRBDS mitigation control"
+					pvulnstatus "$cve" DESC "Não é possível enumerar MSR para controle de mitigação SRBDS"
 				fi
 			else
 				# [ $cpuid_srbds != 1 ]
-				pvulnstatus "$cve" VULN "Your CPU microcode may need to be updated to mitigate the vulnerability"
+				pvulnstatus "$cve" VULN "Seu microcódigo de CPU pode precisar ser atualizado para mitigar a vulnerabilidade"
 			fi
 		else
 			# sysfs only: return the status/msg we got
@@ -6214,9 +6214,9 @@ check_CVE_2020_0543_bsd()
 {
 	if ! is_cpu_affected "$cve"; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus $cve OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus $cve OK "seu fornecedor de CPU relatou que seu modelo de CPU não foi afetado"
 	else
-		pvulnstatus "$cve" UNK "your CPU is affected, but mitigation detection has not yet been implemented for BSD in this script"
+		pvulnstatus "$cve" DES "sua CPU é afetada, mas a detecção de mitigação ainda não foi implementada para BSD neste script"
 	fi
 }
 
@@ -6226,38 +6226,38 @@ check_CVE_2020_0543_bsd()
 check_CVE_2023_20593()
 {
 	cve='CVE-2023-20593'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]; then
 		check_CVE_2023_20593_linux
 	#elif echo "$os" | grep -q BSD; then
 	#	check_CVE_2023_20593_bsd
 	else
-		_warn "Unsupported OS ($os)"
+		_warn "SO não compatível ($os)"
 	fi
 }
 
 check_CVE_2023_20593_linux()
 {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Zenbleed mitigation is supported by kernel: "
+		_info_nol "* A mitigação do Zenbleed é suportada pelo kernel: "
 		kernel_zenbleed=''
 		if [ -n "$kernel_err" ]; then
 			kernel_zenbleed_err="$kernel_err"
 		# commit 522b1d69219d8f083173819fde04f994aa051a98
 		elif grep -q 'Zenbleed:' "$kernel"; then
-			kernel_zenbleed="found zenbleed message in kernel image"
+			kernel_zenbleed="mensagem zenbleed encontrada na imagem do kernel"
 		fi
 		if [ -n "$kernel_zenbleed" ]; then
-			pstatus green YES "$kernel_zenbleed"
+			pstatus green SIM "$kernel_zenbleed"
 		elif [ -n "$kernel_zenbleed_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_zenbleed_err"
+			pstatus yellow DESCONHECIDO "$kernel_zenbleed_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
-		_info_nol "* Zenbleed kernel mitigation enabled and active: "
+		_info_nol "* Mitigação do kernel Zenbleed habilitada e ativa: "
 		if [ "$opt_live" = 1 ]; then
 			# read the DE_CFG MSR, we want to check the 9th bit
 			# don't do it on non-Zen2 AMD CPUs or later, aka Family 17h,
@@ -6266,78 +6266,78 @@ check_CVE_2023_20593_linux()
 				read_msr 0xc0011029; ret=$?
 				if [ $ret = $READ_MSR_RET_OK ]; then
 					if [ $(( read_msr_value >> 9 & 1 )) -eq 1 ]; then
-						pstatus green YES "FP_BACKUP_FIX bit set in DE_CFG"
+						pstatus green SIM "Bit FP_BACKUP_FIX definido em DE_CFG"
 						fp_backup_fix=1
 					else
-						pstatus yellow NO "FP_BACKUP_FIX is cleared in DE_CFG"
+						pstatus yellow NÃO "FP_BACKUP_FIX é limpo em DE_CFG"
 						fp_backup_fix=0
 					fi
 				elif [ $ret = $READ_MSR_RET_KO ]; then
-					pstatus yellow UNKNOWN "Couldn't read the DE_CFG MSR"
+					pstatus yellow DESCONHECIDO "Não foi possível ler o DE_CFG MSR"
 				else
-					pstatus yellow UNKNOWN "$read_msr_msg"
+					pstatus yellow DESCONHECIDO "$read_msr_msg"
 				fi
 			else
 				fp_backup_fix=0
-				pstatus blue N/A "CPU is incompatible"
+				pstatus blue N/A "CPU é incompatível"
 			fi
 		else
-			pstatus blue N/A "not testable in offline mode"
+			pstatus blue N/A "não testável no modo offline"
 		fi
 
-		_info_nol "* Zenbleed mitigation is supported by CPU microcode: "
+		_info_nol "* A mitigação do Zenbleed é suportada pelo microcódigo da CPU: "
 		has_zenbleed_fixed_firmware; ret=$?
 		if [ $ret -eq 0 ]; then
-			pstatus green YES
+			pstatus green SIM
 			cpu_ucode_zenbleed=1
 		elif [ $ret -eq 1 ]; then
-			pstatus yellow NO
+			pstatus yellow NÃO
 			cpu_ucode_zenbleed=2
 		else
-			pstatus yellow UNKNOWN
+			pstatus yellow DESCONHECIDO
 			cpu_ucode_zenbleed=3
 		fi
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="interface de vulnerabilidade /sys usa forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		zenbleed_print_vuln=0
 		if [ "$opt_live" = 1 ]; then
 			if [ "$fp_backup_fix" = 1 ] && [ "$cpu_ucode_zenbleed" = 1 ]; then
 				# this should never happen, but if it does, it's interesting to know
-				pvulnstatus $cve OK "Both your CPU microcode and kernel are mitigating Zenbleed"
+				pvulnstatus $cve OK "Tanto o microcódigo da CPU quanto o kernel estão mitigando o Zenbleed"
 			elif [ "$cpu_ucode_zenbleed" = 1 ]; then
-				pvulnstatus $cve OK "Your CPU microcode mitigates Zenbleed"
+				pvulnstatus $cve OK "O microcódigo da sua CPU mitiga o Zenbleed"
 			elif [ "$fp_backup_fix" = 1 ]; then
-				pvulnstatus $cve OK "Your kernel mitigates Zenbleed"
+				pvulnstatus $cve OK "Seu kernel mitiga o Zenbleed"
 			else
 				zenbleed_print_vuln=1
 			fi
 		else
 			if [ "$cpu_ucode_zenbleed" = 1 ]; then
-				pvulnstatus $cve OK "Your CPU microcode mitigates Zenbleed"
+				pvulnstatus $cve OK "O microcódigo da sua CPU mitiga o Zenbleed"
 			elif [ -n "$kernel_zenbleed" ]; then
-				pvulnstatus $cve OK "Your kernel mitigates Zenbleed"
+				pvulnstatus $cve OK "Seu kernel mitiga o Zenbleed"
 			else
 				zenbleed_print_vuln=1
 			fi
 		fi
 		if [ "$zenbleed_print_vuln" = 1 ]; then
-			pvulnstatus $cve VULN "Your kernel is too old to mitigate Zenbleed and your CPU microcode doesn't mitigate it either"
-			explain "Your CPU vendor may have a new microcode for your CPU model that mitigates this issue (refer to the hardware section above).\n " \
-"Otherwise, the Linux kernel is able to mitigate this issue regardless of the microcode version you have, but in this case\n " \
-"your kernel is too old to support this, your Linux distribution vendor might have a more recent version you should upgrade to.\n " \
-"Note that either having an up to date microcode OR an up to date kernel is enough to mitigate this issue.\n " \
-"To manually mitigate the issue right now, you may use the following command: \`wrmsr -a 0xc0011029 \$((\$(rdmsr -c 0xc0011029) | (1<<9)))\`,\n " \
-"however note that this manual mitigation will only be active until the next reboot."
+			pvulnstatus $cve VULN "Seu kernel é muito antigo para atenuar o Zenbleed e seu microcódigo de CPU também não o atenua"
+explique "Seu fornecedor de CPU pode ter um novo microcódigo para seu modelo de CPU que atenua esse problema (consulte a seção de hardware acima).\n " \
+"Caso contrário, o kernel do Linux é capaz de mitigar esse problema independentemente da versão do microcódigo que você possui, mas neste caso\n " \
+"seu kernel é muito antigo para suportar isso, seu fornecedor de distribuição Linux pode ter uma versão mais recente para a qual você deve atualizar.\n " \
+"Observe que ter um microcódigo atualizado OU um kernel atualizado é suficiente para atenuar esse problema.\n " \
+"Para atenuar manualmente o problema agora, você pode usar o seguinte comando: \`wrmsr -a 0xc0011029 \$((\$(rdmsr -c 0xc0011029) | (1<<9)))\`,\n " \
+"no entanto, observe que esta mitigação manual só estará ativa até a próxima reinicialização."
 		fi
 		unset zenbleed_print_vuln
 	else
@@ -6350,17 +6350,17 @@ check_CVE_2023_20593_linux()
 
 check_CVE_2022_40982() {
 	cve='CVE-2022-40982'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]
 	then
 		check_CVE_2022_40982_linux
 	else
-		_warn "Unsupported OS ($os)."
+		_warn "SO não suportado ($os)."
 	fi
 }
 
 check_CVE_2022_40982_linux() {
-	status=UNK
+	status=DESC
 	sys_interface_available=0
 	msg=''
 
@@ -6370,75 +6370,75 @@ check_CVE_2022_40982_linux() {
 	fi
 
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* GDS is mitigated by microcode: "
+		_info_nol "* O GDS é mitigado pelo microcódigo: "
 		if [ "$capabilities_gds_ctrl" = 1 ] && [ "$mcu_opt_ctrl_gds_mitg_dis" = 0 ]; then
-			pstatus green OK "microcode mitigation is supported and enabled"
+			pstatus green OK "a mitigação de microcódigo é suportada e habilitada"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
-		_info_nol "* Kernel supports software mitigation by disabling AVX: "
+		_info_nol "* O kernel oferece suporte à mitigação de software desativando o AVX: "
 		if [ -n "$kernel_err" ]; then	
 			kernel_gds_err="$kernel_err"
 		elif grep -q 'gather_data_sampling' "$kernel"; then
-			kernel_gds="found gather_data_sampling in kernel image"
+			kernel_gds="encontrado gather_data_sampling na imagem do kernel"
 		fi
 		if [ -n "$kernel_gds" ]; then
-			pstatus green YES "$kernel_gds"
+			pstatus green SIM "$kernel_gds"
 		elif [ -n "$kernel_gds_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_gds_err"
+			pstatus yellow DESCONHECIDO "$kernel_gds_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
 		if [ -n "$kernel_gds" ]; then
-			_info_nol "* Kernel has disabled AVX as a mitigation: "
+			_info_nol "* Kernel desativou o AVX como uma mitigação: "
 
 			# Check dmesg message to see whether AVX has been disabled
-			dmesg_grep 'Microcode update needed! Disabling AVX as mitigation'; dmesgret=$?
+			dmesg_grep 'Atualização de microcódigo necessária! Desativando o AVX como mitigação'; dmesgret=$?
 			if [ $dmesgret -eq 0 ]; then
-				kernel_avx_disabled="AVX disabled by the kernel (dmesg)"
-				pstatus green YES "$kernel_avx_disabled"
+				kernel_avx_disabled="AVX desativado pelo kernel (dmesg)"
+				pstatus green SIM "$kernel_avx_disabled"
 			elif [ "$has_avx2" = 0 ]; then
 				# Find out by ourselves
 				# cpuinfo says we don't have AVX2, query
 				# the CPU directly about AVX2 support
 				read_cpuid 0x7 0x0 $EBX 5 1 1; ret=$?
 				if [ $ret -eq $READ_CPUID_RET_OK ]; then
-					kernel_avx_disabled="AVX disabled by the kernel (cpuid)"
-					pstatus green YES "$kernel_avx_disabled"
+					kernel_avx_disabled="AVX desativado pelo kernel (cpuid)"
+					pstatus green SIM "$kernel_avx_disabled"
 				elif [ $ret -eq $READ_CPUID_RET_KO ]; then
-					pstatus yellow NO "CPU doesn't support AVX"
+					pstatus yellow NÃO "CPU não suporta AVX"
 				elif [ $dmesgret -eq 2 ]; then
-					pstatus yellow UNKNOWN "dmesg truncated, can't tell whether mitigation is active, please reboot and relaunch this script"
+					pstatus yellow DESCONHECIDO "dmesg truncado, não sei se a mitigação está ativa. Por favor, reinicie e abra novamente este script"
 				else
-					pstatus yellow UNKNOWN "No sign of mitigation in dmesg and couldn't read cpuid info"
+					pstatus yellow DESCONHECIDO "Nenhum sinal de mitigação no dmesg e não foi possível ler as informações do cpuid"
 				fi
 			else
-					pstatus yellow NO "AVX support is enabled"
+					pstatus yellow NÃO "O suporte AVX está ativado"
 			fi
 		fi
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="interface de vulnerabilidade /sys usa forçado, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, rely on our own test
 		if [ "$capabilities_gds_ctrl" = 1 ] && [ "$mcu_opt_ctrl_gds_mitg_dis" = 0 ]; then
-			pvulnstatus $cve OK "Your microcode is up to date and mitigation is enabled"
+			pvulnstatus $cve OK "Seu microcódigo está atualizado e a mitigação está habilitada"
 		elif [ "$capabilities_gds_ctrl" = 1 ] && [ "$mcu_opt_ctrl_gds_mitg_dis" = 1 ]; then
-			pvulnstatus $cve VULN "Your microcode is up to date but mitigation is disabled"
+			pvulnstatus $cve VULN "Seu microcódigo está atualizado, mas a mitigação está desativada"
 		elif [ -z "$kernel_gds" ]; then
-			pvulnstatus $cve VULN "Your microcode doesn't mitigate the vulnerability, and your kernel doesn't support mitigation"
+			pvulnstatus $cve VULN "Seu microcódigo não atenua a vulnerabilidade e seu kernel não oferece suporte à mitigação"
 		elif [ -z "$kernel_avx_disabled" ]; then
-			pvulnstatus $cve VULN "Your microcode doesn't mitigate the vulnerability, your kernel support the mitigation but the script did not detect AVX as disabled by the kernel"
+			pvulnstatus $cve VULN "Seu microcódigo não atenua a vulnerabilidade, seu kernel suporta a mitigação, mas o script não detectou o AVX como desativado pelo kernel"
 		else
-			pvulnstatus $cve OK "Your microcode doesn't mitigate the vulnerability, but your kernel has disabled AVX support"
+			pvulnstatus $cve OK "Seu microcódigo não atenua a vulnerabilidade, mas seu kernel desativou o suporte AVX"
 		fi
 	else
 		pvulnstatus $cve "$status" "$msg"
@@ -6450,17 +6450,17 @@ check_CVE_2022_40982_linux() {
 
 check_CVE_2023_20569() {
 	cve='CVE-2023-20569'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]
 	then
 		check_CVE_2023_20569_linux
 	else
-		_warn "Unsupported OS ($os)."
+		_warn "SO não suportado ($os)."
 	fi
 }
 
 check_CVE_2023_20569_linux() {
-	status=UNK
+	status=DES
 	sys_interface_available=0
 	msg=''
 
@@ -6470,143 +6470,143 @@ check_CVE_2023_20569_linux() {
 	fi
 
 	if [ "$opt_sysfs_only" != 1 ]; then
-		_info_nol "* Kernel supports mitigation: "
+		_info_nol "* Kernel suporta mitigação: "
 		if [ -n "$kernel_err" ]; then
 			kernel_sro_err="$kernel_err"
 		elif grep -q 'spec_rstack_overflow' "$kernel"; then
-			kernel_sro="found spec_rstack_overflow in kernel image"
+			kernel_sro="encontrado spec_rstack_overflow na imagem do kernel"
 		fi
 		if [ -n "$kernel_sro" ]; then
-			pstatus green YES "$kernel_sro"
+			pstatus green SIM "$kernel_sro"
 		elif [ -n "$kernel_sro_err" ]; then
-			pstatus yellow UNKNOWN "$kernel_sro_err"
+			pstatus yellow DESCONHECIDO "$kernel_sro_err"
 		else
-			pstatus yellow NO
+			pstatus yellow NÃO
 		fi
 
-		_info_nol "* Kernel compiled with SRSO support: "
+		_info_nol "* Kernel compilado com suporte SRSO: "
 		if [ -r "$opt_config" ]; then
 			if grep -q '^CONFIG_CPU_SRSO=y' "$opt_config"; then
-				pstatus green YES
-				kernel_srso="CONFIG_CPU_SRSO=y found in kernel config"
+				pstatus green SIM
+				kernel_srso="CONFIG_CPU_SRSO=y encontrado na configuração do kernel"
 			else
-				pstatus yellow NO "required for safe RET and ibpb_on_vmexit mitigations"
+				pstatus yellow NÃO "necessário para mitigações seguras de RET e ibpb_on_vmexit"
 			fi
 		else
 			# https://github.com/torvalds/linux/commit/138bcddb86d8a4f842e4ed6f0585abc9b1a764ff#diff-17bd24a7a7850613cced545790ac30646097e8d6207348c2bd1845f397acb390R2313
 			if [ -n "$kernel_err" ]; then
-				pstatus yellow UNKNOWN "$kernel_err"
+				pstatus yellow DESCONHECIDO "$kernel_err"
 			elif grep -q 'WARNING: kernel not compiled with CPU_SRSO' "$kernel"; then
 				# this msg is optimized out at compile time if the option is not enabled, see commit referenced above
 				# if it's present, then SRSO is NOT compiled in
-				pstatus yellow NO "kernel not compiled with CPU_SRSO"
+				pstatus yellow NÃO "kernel não compilado com CPU_SRSO"
 			else
 				# if it's not present, then SRSO is compiled in IF kernel_sro==1, otherwise we're just
 				# in front of an old kernel that doesn't have the mitigation logic at all
 				if [ "$kernel_sro" = 1 ]; then
-					kernel_srso="SRSO mitigation logic is compiled in the kernel"
+					kernel_srso="A lógica de mitigação SRSO é compilada no kernel"
 					pstatus green OK "$kernel_srso"
 				else
-					pstatus yellow NO "your kernel is too old and doesn't have the mitigation logic"
+					pstatus yellow NÃO "seu kernel é muito antigo e não possui lógica de mitigação"
 				fi
 			fi
 		fi
 
-		_info_nol "* Kernel compiled with IBPB_ENTRY support: "
+		_info_nol "* Kernel compilado com suporte IBPB_ENTRY: "
 		if [ -r "$opt_config" ]; then
 			if grep -q '^CONFIG_CPU_IBPB_ENTRY=y' "$opt_config"; then
-				pstatus green YES
-				kernel_ibpb_entry="CONFIG_CPU_IBPB_ENTRY=y found in kernel config"
+				pstatus green SIM
+				kernel_ibpb_entry="CONFIG_CPU_IBPB_ENTRY=y encontrado na configuração do kernel"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		else
 			# https://github.com/torvalds/linux/commit/138bcddb86d8a4f842e4ed6f0585abc9b1a764ff#diff-17bd24a7a7850613cced545790ac30646097e8d6207348c2bd1845f397acb390R2325
 			if [ -n "$kernel_err" ]; then
-				pstatus yellow UNKNOWN "$kernel_err"
+				pstatus yellow DESCONHECIDO "$kernel_err"
 			elif grep -q 'WARNING: kernel not compiled with CPU_IBPB_ENTRY' "$kernel"; then
 				# this msg is optimized out at compile time if the option is not enabled, see commit referenced above
 				# if it's present, then IBPB_ENTRY is NOT compiled in
-				pstatus yellow NO "kernel not compiled with CPU_IBPB_ENTRY"
+				pstatus yellow NÃO "kernel não compilado com CPU_IBPB_ENTRY"
 			else
 				# if it's not present, then IBPB_ENTRY is compiled in IF kernel_sro==1, otherwise we're just
 				# in front of an old kernel that doesn't have the mitigation logic at all
 				if [ "$kernel_sro" = 1 ]; then
-					kernel_ibpb_entry="IBPB_ENTRY mitigation logic is compiled in the kernel"
+					kernel_ibpb_entry="A lógica de mitigação IBPB_ENTRY é compilada no kernel"
 					pstatus green OK "$kernel_ibpb_entry"
 				else
-					pstatus yellow NO "your kernel is too old and doesn't have the mitigation logic"
+					pstatus yellow NÃO "seu kernel é muito antigo e não possui lógica de mitigação"
 				fi
 			fi
 		fi
 
 		# Zen & Zen2 : if the right IBPB microcode applied + SMT off --> not vuln
 		if [ "$cpu_family" = $(( 0x17 )) ]; then
-			_info_nol "* CPU supports IBPB: "
+			_info_nol "* CPU suporta IBPB: "
 			if [ -n "$cpuid_ibpb" ]; then
-				pstatus green YES "$cpuid_ibpb"
+				pstatus green SIM "$cpuid_ibpb"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 
-			_info_nol "* Hyper-Threading (SMT) is enabled: "
+			_info_nol "* Hyper-Threading (SMT) está habilitado: "
 			is_cpu_smt_enabled; smt_enabled=$?
 			if [ "$smt_enabled" = 0 ]; then
-				pstatus yellow YES
+				pstatus yellow SIM
 			else
-				pstatus green NO
+				pstatus green NÃO
 			fi
 		# Zen 3/4 microcode brings SBPB mitigation
 		elif [ "$cpu_family" = $(( 0x19 )) ]; then
-			_info_nol "* CPU supports SBPB: "
+			_info_nol "* CPU suporta SBPB: "
 			if [ "$cpuid_sbpb" = 1 ]; then
-				pstatus green YES
+				pstatus green SIM
 			elif [ "$cpuid_sbpb" = 3 ]; then
-				pstatus yellow UNKNOWN "cannot write MSR, rerun with --allow-msr-write"
+				pstatus yellow DESCONHECIDO "não é possível escrever MSR, execute novamente com --allow-msr-write"
 			else
-				pstatus yellow NO
+				pstatus yellow NÃO
 			fi
 		fi
 
 	elif [ "$sys_interface_available" = 0 ]; then
 		# we have no sysfs but were asked to use it only!
-		msg="/sys vulnerability interface use forced, but it's not available!"
-		status=UNK
+		msg="Uso forçado da interface de vulnerabilidade /sys, mas não está disponível!"
+		status=DESC
 	fi
 
 	if ! is_cpu_affected "$cve" ; then
 		# override status & msg in case CPU is not vulnerable after all
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou seu modelo de CPU como não afetado"
 	elif [ -z "$msg" ]; then
 		# if msg is empty, sysfs check didn't fill it, so we rely on our own logic
 		# Zen/Zen2
 		if [ "$cpu_family" = $(( 0x17 )) ]; then
 			if [ "$smt_enabled" = 0 ]; then
-				pvulnstatus "$cve" VULN "SMT is enabled on your Zen/Zen2 CPU, which makes mitigation ineffective"
-				explain "For Zen/Zen2 CPUs, proper mitigation needs an up to date microcode, and SMT needs to be disabled (this can be done by adding \`nosmt\` to your kernel command line)"
+				pvulnstatus "$cve" VULN "SMT está habilitado em sua CPU Zen/Zen2, o que torna a mitigação ineficaz"
+				explain "Para CPUs Zen/Zen2, a mitigação adequada precisa de um microcódigo atualizado e o SMT precisa ser desabilitado (isso pode ser feito adicionando \`nosmt\` à linha de comando do kernel)"
 			elif [ -z "$kernel_sro" ]; then
-				pvulnstatus "$cve" VULN "Your kernel is too old and doesn't have the SRSO mitigation logic"
+				pvulnstatus "$cve" VULN "Seu kernel é muito antigo e não possui a lógica de mitigação SRSO"
 			elif [ -n "$cpuid_ibpb" ]; then
-				pvulnstatus "$cve" OK "SMT is disabled and both your kernel and microcode support mitigation"
+				pvulnstatus "$cve" OK "SMT está desabilitado e tanto o kernel quanto o microcódigo suportam mitigação"
 			else
-				pvulnstatus "$cve" VULN "Your microcode is too old"
+				pvulnstatus "$cve" VULN "Seu microcódigo é muito antigo"
 			fi
 		# Zen3/Zen4
 		elif [ "$cpu_family" = $(( 0x19 )) ]; then
 			if [ -z "$kernel_sro" ]; then
-				pvulnstatus "$cve" VULN "Your kernel is too old and doesn't have the SRSO mitigation logic"
+				pvulnstatus "$cve" VULN "Seu kernel é muito antigo e não possui a lógica de mitigação SRSO"
 			elif [ -z "$kernel_srso" ] && [ -z "$kernel_ibpb_entry" ]; then
-				pvulnstatus "$cve" VULN "Your kernel doesn't have either SRSO or IBPB_ENTRY compiled-in"
+				pvulnstatus "$cve" VULN "Seu kernel não possui SRSO ou IBPB_ENTRY compilado"
 			elif [ "$cpuid_sbpb" = 3 ]; then
-				pvulnstatus "$cve" UNK "Couldn't verify if your microcode supports IBPB (rerun with --allow-msr-write)"
+				pvulnstatus "$cve" DESC "Não foi possível verificar se o seu microcódigo suporta IBPB (executar novamente com --allow-msr-write)"
 			elif [ "$cpuid_sbpb" = 2 ]; then
-				pvulnstatus "$cve" VULN "Your microcode doesn't support SBPB"
+				pvulnstatus "$cve" VULN "Seu microcódigo não é compatível com SBPB"
 			else
-				pvulnstatus "$cve" OK "Your kernel and microcode both support mitigation"
+				pvulnstatus "$cve" OK "Seu kernel e microcódigo suportam mitigação"
 			fi
 		else
 			# not supposed to happen, as normally this CPU should not be affected and not run this code
-			pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+			pvulnstatus "$cve" OK "seu fornecedor de CPU relatou seu modelo de CPU como não afetado"
 		fi
 	else
 		pvulnstatus $cve "$status" "$msg"
@@ -6618,12 +6618,12 @@ check_CVE_2023_20569_linux() {
 
 check_CVE_2023_23583() {
 	cve='CVE-2023-23583'
-	_info "\033[1;34m$cve aka '$(cve2name "$cve")'\033[0m"
+	_info "\033[1;34m$cve também conhecido como '$(cve2name "$cve")'\033[0m"
 	if [ "$os" = Linux ]
 	then
 		check_CVE_2023_23583_linux
 	else
-		_warn "Unsupported OS ($os)."
+		_warn "SO não suportado ($os)."
 	fi
 }
 
@@ -6636,15 +6636,15 @@ check_CVE_2023_23583_linux() {
 	# the mitigation is only ucode-based and there's no flag exposed,
 	# so most of the work has already been done by is_cpu_affected()
 	if ! is_cpu_affected "$cve" ; then
-		pvulnstatus "$cve" OK "your CPU vendor reported your CPU model as not affected"
+		pvulnstatus "$cve" OK "seu fornecedor de CPU relatou seu modelo de CPU como não afetado"
 	else
-		_info_nol "* Reptar is mitigated by microcode: "
+		_info_nol "* Reptar é mitigado por microcódigo: "
 		if [ "$cpu_ucode" -lt "$reptar_fixed_ucode_version" ]; then
-			pstatus yellow NO "You have ucode $(printf "0x%x" $cpu_ucode) and version $(printf "0x%x" $reptar_fixed_ucode_version) minimum is required"
-			pvulnstatus $cve VULN "Your microcode is too old to mitigate the vulnerability"
+			pstatus yellow NÃO "Você tem ucode $(printf "0x%x" $cpu_ucode) e a versão $(printf "0x%x" $reptar_fixed_ucode_version) mínima é necessária"
+			pvulnstatus $cve VULN "Seu microcódigo é muito antigo para mitigar a vulnerabilidade"
 		else
-			pstatus green YES "You have ucode $(printf "0x%x" $cpu_ucode) which is recent enough (>= $(printf "0x%x" $reptar_fixed_ucode_version))"
-			pvulnstatus $cve OK "Your microcode mitigates the vulnerability"
+			pstatus green SIM "Você tem ucode $(printf "0x%x" $cpu_ucode) que é recente o suficiente (>= $(printf "0x%x" $reptar_fixed_ucode_version))"
+			pvulnstatus $cve OK "Seu microcódigo atenua a vulnerabilidade"
 		fi
 	fi
 }
@@ -6668,16 +6668,16 @@ do
 done
 
 if [ -n "$final_summary" ]; then
-	_info "> \033[46m\033[30mSUMMARY:\033[0m$final_summary"
+	_info "> \033[46m\033[30mRESUMO:\033[0m$final_summary"
 	_info ""
 fi
 
 if [ "$bad_accuracy" = 1 ]; then
-	_warn "We're missing some kernel info (see -v), accuracy might be reduced"
+	_warn "Faltam algumas informações do kernel (consulte -v), a precisão pode ser reduzida"
 fi
 
 _vars=$(set | grep -Ev '^[A-Z_[:space:]]' | grep -v -F 'mockme=' | sort | tr "\n" '|')
-_debug "variables at end of script: $_vars"
+_debug "variáveis no final do script: $_vars"
 
 if [ -n "$mockme" ] && [ "$opt_mock" = 1 ]; then
 	if command -v "gzip" >/dev/null 2>&1; then
@@ -6695,31 +6695,31 @@ if [ -n "$mockme" ] && [ "$opt_mock" = 1 ]; then
 	fi
 	_info ""
 	# shellcheck disable=SC2046
-	_warn "To mock this CPU, set those vars: "$(echo "$mockme" | sort -u)
+	_warn "Para zombar desta CPU, defina essas variáveis: "$(echo "$mockme" | sort -u)
 fi
 
 # root check
 if [ "$(id -u)" -ne 0 ]; then
-	_warn "Note that you should launch this script with root privileges to get completely accurate information."
-	_warn "To run it as root, you can try the following command: sudo $0"
+	_warn "Observe que você deve iniciar este script com privilégios de root para obter informações completamente precisas."
+	_warn "Para executá-lo como root, você pode tentar o seguinte comando: sudo $0"
 	_warn
 fi
 
 if [ "$opt_explain" = 0 ]; then
-	_info "Need more detailed information about mitigation options? Use --explain"
+	_info "Precisa de informações mais detalhadas sobre as opções de mitigação? Use --explain"
 fi
 
-_info "A false sense of security is worse than no security at all, see --disclaimer"
+_info "Uma falsa sensação de segurança é pior do que nenhuma segurança, veja --disclaimer"
 
 if [ "$mocked" = 1 ]; then
 	_info ""
-	_warn "One or several values have been mocked. This should only be done when debugging/testing this script."
-	_warn "The results do NOT reflect the actual status of the system we're running on."
+	_warn "Um ou vários valores foram simulados. Isso só deve ser feito ao depurar/testar este script."
+	_warn "Os resultados NÃO refletem o status real do sistema em que estamos executando."
 fi
 
 if [ "$opt_batch" = 1 ] && [ "$opt_batch_format" = "nrpe" ]; then
 	if [ -n "$nrpe_vuln" ]; then
-		echo "Vulnerable:$nrpe_vuln"
+		echo "Vulnerável:$nrpe_vuln"
 	else
 		echo "OK"
 	fi
@@ -6734,8 +6734,8 @@ if [ "$opt_batch" = 1 ] && [ "$opt_batch_format" = "json" ]; then
 fi
 
 if [ "$opt_batch" = 1 ] && [ "$opt_batch_format" = "prometheus" ]; then
-	echo "# TYPE specex_vuln_status untyped"
-	echo "# HELP specex_vuln_status Exposure of system to speculative execution vulnerabilities"
+	echo "# TYPE specex_vuln_status sem tipo"
+	echo "# HELP specex_vuln_status Exposição do sistema a vulnerabilidades de execução especulativas"
 	printf "%b\n" "$prometheus_output"
 fi
 
