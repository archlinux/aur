#!/bin/bash
# Description: Script to automate privateinternetacces port forwarding and 
# starting/stopping transmission when connected/disconnected and other stuff
# Version: 0.9.5.1
# Author: Philipp Schmitt (philipp<at>schmitt.co)
# Documentation: cf. pia-tools.groff
# Sources: iptables -> https://www.privateinternetaccess.com/forum/index.php?p=/discussion/35/block-non-vpn-traffic-on-linux-with-iptables-protect-against-disconnect/p1
# Dependencies: transmission-daemon openvpn systemd sudo wget ufw unzip

# Source config file

test "$PIA_CONF" || PIA_CONF='/etc/pia-tools.conf'
[[ -r "$PIA_CONF" ]] && . $PIA_CONF

# Setup default config if not already set in pia-tools.conf
if [[ -z "$PIA_CONFIG_DIR" ]]; then
    PIA_CONFIG_DIR='/etc/openvpn/pia'
fi
if [[ -z "$PIA_CONFIG_URL" ]]; then
    PIA_CONFIG_URL='https://www.privateinternetaccess.com/openvpn/openvpn.zip'
fi
if [[ -z "$PIA_COMMON_CONFIG" ]]; then
    PIA_COMMON_CONFIG="$PIA_CONFIG_DIR/pia_common"
fi
if [[ -z "$PIA_SERVERS_FILE" ]]; then
    PIA_SERVERS_FILE="$PIA_CONFIG_DIR/piaservers"
fi
if [[ -z "$PIA_SERVERS_IP_FILE" ]]; then
    PIA_SERVERS_IP_FILE="$PIA_CONFIG_DIR/piaserverips"
fi
if [[ -z "$PIA_PASSWD_FILE" ]]; then
    PIA_PASSWD_FILE="$PIA_CONFIG_DIR/passwd"
fi
if [[ -z "$PIA_CLIENT_ID_FILE" ]]; then
    PIA_CLIENT_ID_FILE="$PIA_CONFIG_DIR/clientid"
fi
if [[ -z "$TRANSMISSION_SETTINGS_FILE" ]]; then
    TRANSMISSION_SETTINGS_FILE='/home/dl/.config/transmission-daemon/settings.json'
fi
if [[ -z "$PIA_OPEN_PORT_FILE" ]]; then
    PIA_OPEN_PORT_FILE="$PIA_CONFIG_DIR/open_port"
fi
PIA_OPEN_PORT="$(cat $PIA_OPEN_PORT_FILE 2>/dev/null)"
if [[ -z "$VIRT_NET_DEV" ]]; then
    VIRT_NET_DEV='tun0'
fi

function usage() {
    echo "Usage: $1 [-p|r] [-a|d] [-u] [-c] [-h]"
    echo "-p: Request new port"
    echo "-r: Refresh (request port forwarding again) [default]"
    echo "-a: Block non VPN traffic (iptables)"
    echo "-d: Unblock non VPN traffic (iptables) [default]"
    echo "-g: Use PIA DNS (updates resolv.conf)"
    echo "-u: Update configuration files"
    echo "-s: Run setup"
    echo "-c: Ensure OpenVPN is running. If not stop transmissiond"
    echo "-h: Display this message"
    echo "-v: Verbose output"
}

# Checks if executed as root. If not reinvoke self with sudo
function check_root() {
    if [[ $EUID -ne 0 ]]; then
        if test "$VERBOSE"; then
            echo -e "This script must be run as root\nInvoking sudo -- $0 $*" 1>&2
        fi
        exec sudo -- $0 $*
    fi
}

function check_transmission() {
    systemctl is-active transmissiond > /dev/null 2>&1
}

# Checks if the OpenVPN service is running
function check_ovpn() {
    local ovpnd="$(systemctl -t service | grep 'pia@.* active')"
    if [[ -z "$ovpnd" ]]; then
        echo 'OpenVPN service not running !' >&2
        if check_transmission; then
            echo -n 'Stopping transmissiond... '
            systemctl stop transmissiond
            echo 'Done!'
        else
            echo "Transmissiond not running" >&2
        fi
        iplist_unblock
        return 1
    fi
}

function info() {
    local vpn_exit="$(systemctl -t service | grep 'pia@.* active' \
                    | awk '{ print $NF }')"
    if check_ovpn; then
        echo "OpenVPN is running (Exit point: $vpn_exit)"
    else
        echo "OpenVPN stopped"
    fi
    if check_transmission; then
        echo "Transmissiond is running"
    else
        echo "Transmissiond stopped"
    fi
}

function _ufw_port_allowed() {
    ufw status | grep -E "^$1\s+ALLOW" > /dev/null
}

# Delete previous rule from ufw
function _ufw_delete_old_rule() {
    if test "$PIA_OPEN_PORT" && _ufw_port_allowed "$PIA_OPEN_PORT"; then
        ufw delete allow $PIA_OPEN_PORT
    fi
}

# Add a new rule to ufw
function _ufw_add_new_rule () {
    if test "$PIA_OPEN_PORT_NEW" && \
          ! _ufw_port_allowed "$PIA_OPEN_PORT_NEW"; then
        ufw allow $PIA_OPEN_PORT_NEW
    fi
}

# Update ufw rules
function ufw_update() {
    # Check if ufw is running
    systemctl is-active ufw > /dev/null 2>&1 || return 1
    echo -n "Updating UFW rules... "
    _ufw_delete_old_rule
    _ufw_add_new_rule
    ufw reload > /dev/null
    echo 'Done!'
}

function transmission_peer_port_update() {
    local transmission_peer_port="$(grep 'peer-port\"' $TRANSMISSION_SETTINGS_FILE | grep -Eo '[0-9]+')"
    echo -n "Updating transmission's listening port... "
    # Check if transmission is running
    if check_transmission; then
        # get current listening port
        transmission_peer_port="$(transmission-remote -si | grep Listenport | grep -oE '[0-9]+')"
        if [[ "$PIA_OPEN_PORT_NEW" != "$transmission_peer_port" ]]; then
            transmission-remote -p "$PIA_OPEN_PORT_NEW"
            # systemctl restart transmissiond
            echo 'Checking port...'
            # TODO The sleep timer may need to be adjusted
            sleep 3 && transmission-remote -pt
        fi
    else
        # write new listening port to config
        if test "$PIA_OPEN_PORT_NEW" && \
           [[ "$PIA_OPEN_PORT_NEW" != "$transmission_peer_port" ]]; then
            echo "Writing new peer port to transmission's settings.json..."
            sed -i 's/\(\"peer-port\":\).*,/\1 '$PIA_OPEN_PORT_NEW',/' $TRANSMISSION_SETTINGS_FILE
        fi
        check_ovpn && systemctl restart transmissiond
    fi
    echo 'Done!'
}

# Return a new client ID
function new_client_id() {
    head -n 100 /dev/urandom | md5sum | tr -d " -" | tee $PIA_CLIENT_ID_FILE
}

function request_port() {
    local username="$(head -1 $PIA_PASSWD_FILE)"
    local passwd="$(tail -1 $PIA_PASSWD_FILE)"
    local local_vpn_ip="$(ip addr show $VIRT_NET_DEV | grep inet | awk '{ print $2 }')"
    local client_id="$1"
    #[[ -z "$client_id" ]] || client_id=$(new_client_id)
    echo -n "Updating port forwarding... "
    if test $VERBOSE; then
        echo "Username: $username"
        echo "Client ID: $client_id"
        echo "VPN local IP: $local_vpn_ip"
    fi
    PIA_OPEN_PORT_NEW="$(\
        wget -q -O- --post-data "user=$username&pass=$passwd&client_id=$client_id&local_ip=$local_vpn_ip" \
        https://www.privateinternetaccess.com/vpninfo/port_forward_assignment \
        | grep -oE "[0-9]+" 2>&1)"
    # PIA_OPEN_PORT_NEW="$(\
    #     curl -s -d "user=$username&pass=$passwd&client_id=$client_id&local_ip=$local_vpn_ip" \
    #     https://www.privateinternetaccess.com/vpninfo/port_forward_assignment \
    #     | grep -oE "[0-9]+" 2>&1)"
    if test "$PIA_OPEN_PORT_NEW"; then
        echo "$PIA_OPEN_PORT_NEW" > "$PIA_OPEN_PORT_FILE"
        echo "Done! Port: $PIA_OPEN_PORT_NEW"
        if [[ "$PIA_OPEN_PORT_NEW" != "$PIA_OPEN_PORT" ]]; then
            echo "(Previous: $PIA_OPEN_PORT)"
            ufw_update                    # Update firewall rules
            transmission_peer_port_update # Update Transmission's peer port
        fi
   else
        echo 'Failed'
   fi
}

function setup() {
    if [[ -e $PIA_PASSWD_FILE ]]; then
        echo -en "$PIA_PASSWD_FILE exits.\nRemove it? (y|N) "
        read delete
        if [[ $delete == "y" ]]; then
            rm -f "$PIA_PASSWD_FILE"
        else
            update_config
            return
        fi
    fi
    mkdir -p $PIA_CONFIG_DIR
    echo -n "Username: "
    read username
    echo -ne "Password: "
    read -s password
    echo -e "${username}\n${password}" > $PIA_PASSWD_FILE
    chmod 400 $PIA_PASSWD_FILE
    echo
    update_config
    echo "Now you can connect to the VPN"
    echo "# systemctl start pia@Sweden"
}

function update_config() {
    echo -n 'Updating configuration... '
    local ovpn ovpn_spaceless

    # Clean up
    rm -f $PIA_CONFIG_DIR/ca.crt $PIA_CONFIG_DIR/*.ovpn
    
    # Fetch server config files
    wget -N -q --directory-prefix=$PIA_CONFIG_DIR $PIA_CONFIG_URL
    unzip -d $PIA_CONFIG_DIR -q $PIA_CONFIG_DIR/openvpn.zip
    
    # Replace space by underscore in filenames
    local ifs_bak=$IFS
    IFS=$(echo -en "\n\b")
    for ovpn in $(ls $PIA_CONFIG_DIR/*.ovpn); do
        # Rename files so that do not contain spaces
        ovpn_spaceless="$(sed 's/ /_/g' <<< $ovpn)"
        if [[ "$ovpn" != "$ovpn_spaceless" ]]; then
            mv "$ovpn" "$ovpn_spaceless"
        fi
        # Append up/down scripts to every ovpn file
        cat $PIA_COMMON_CONFIG  >> $ovpn_spaceless
    done
    IFS=$ifs_bak
    
    # Extract server addresses and resolve hosts
    grep -h "remote " $PIA_CONFIG_DIR/*.ovpn | cut -d ' ' -f 2 \
        | sort -u > $PIA_SERVERS_FILE
    cat $PIA_SERVERS_FILE | nslookup | grep Address | grep -v "192.168.1.1" \
        | awk '{ print $2 }' > $PIA_SERVERS_IP_FILE

    # why is following dig cmd failing randomly ?
    #dig -f /tmp/piaservers A +short | sort > $PIA_SERVERS_IP_FILE
    echo 'Done!'
}

function iplist_block() {
    echo -n 'Blocking non VPN-traffic... '
    check_ovpn || return 0
    [[ -f $PIA_SERVERS_IP_FILE ]] || update_config
    # Add PIA server IPs to script
    local ip_list=$(tr '\n' ' ' < $PIA_SERVERS_IP_FILE)
    test "$ip_list" || { echo 'IP list is empty !' >2; exit 2; }
    # Start building iptables blocklist
    iptables -F
    iptables -A INPUT -i tun+ -j ACCEPT
    iptables -A OUTPUT -o tun+ -j ACCEPT
    iptables -A INPUT -s 127.0.0.1 -j ACCEPT
    iptables -A OUTPUT -d 127.0.0.1 -j ACCEPT

    for IP in $ip_list; do
        iptables -A INPUT -s ${IP} -j ACCEPT
        iptables -A OUTPUT -d ${IP} -j ACCEPT
    done

    # Allow connecting to local network
    iptables -A INPUT -s 192.168.0.0/24 -j ACCEPT
    iptables -A OUTPUT -d 192.168.0.0/24 -j ACCEPT
    # Disallow other connections
    iptables -A INPUT -j DROP
    iptables -A OUTPUT -j DROP
    echo 'Done!'
}

function iplist_unblock() {
    echo -n 'Unblocking ... '
    iptables -F
    iptables -A INPUT -j ACCEPT
    iptables -A OUTPUT -j ACCEPT
    echo 'Done!'
}

function _dns() {
    if mv /etc/resolv.conf /etc/resolv.conf.orig; then
        test $VERBOSE && echo "Backed up /etc/resolv.conf to /etc/resolv.conf.orig"
    fi
    echo -n "Updating resolv.conf file... "
    echo "# Generated by pia-tools" > /etc/resolv.conf
    for dns in $@; do
        echo "nameserver $dns" >> /etc/resolv.conf
    done
    echo 'Done!'
    test $VERBOSE && echo -e "New resolv.conf:\n$(cat /etc/resolv.conf)"
}

function pia_dns() {
    _dns '4.2.2.1' '4.2.2.2'
}

function google_dns() {
    _dns '8.8.8.8' '8.8.4.4'
}

function restore_dns() {
    if [[ ! -f /etc/resolv.conf.orig ]]; then
        echo "Could not find a resolv.conf.orig" >&2
        return 1
    fi
    mv -f /etc/resolv.conf.orig /etc/resolv.conf
}

# If no option -> refresh
# When started by OpenVPN daemon (up script) this script gets called like this:
# $0 tun0 1500 1542 10.185.1.6 10.185.1.5 init
if [[ $# -eq 0 ]] || [[ $# -gt 5 ]]; then
    action_port=refresh
    #action_fw=disallow
fi

# Every function except help needs root permissions
check_root "$*"

while getopts ':adgprciuhsv-' OPTION; do
    case "$OPTION" in
        a)
            test $action_fw && exit 1
            action_fw=allow
            ;;
        d)
            test $action_fw && exit 1
            action_fw=disallow
            ;;
        p)
            test $action_port && exit 1
            action_port=portfwd
            ;;
        r)
            test $action_port && exit 1
            action_port=refresh
            ;;
        g)
            test $dns && exit 1
            action_dns=pia
            ;;
        u)
            action_update=1
            ;;
        s)
            action_setup=1
            ;;
        c)
            action_check=1
            ;;
        i)
            action_info=1
            ;;
        h)
            action_help=1
            ;;
        v)
            VERBOSE=1
            ;;
        -)
            [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1 ) || optind=$OPTIND
            eval OPTION="\$$optind"
            OPTARG=$(echo $OPTION | cut -d'=' -f2)
            OPTION=$(echo $OPTION | cut -d'=' -f1)
            case $OPTION in
                --port)
                    test $action_port && exit 1
                    action_port=portfwd
                    ;;
                --refresh)
                    test $action_port && exit 1
                    action_port=refresh
                    ;;
                --allow)
                    test $action_fw && exit 1
                    action_fw=allow
                    ;;
                --disallow)
                    test $action_fw && exit 1
                    action_fw=disallow
                    ;;
                --pia-dns)
                    test $dns && exit 1
                    action_dns=pia
                    ;;
                --google-dns)
                    test $dns && exit 1
                    action_dns=google
                    ;;
                --restore-dns)
                    test $dns && exit 1
                    action_dns=restore
                    ;;
                --update)
                    action_update=1
                    ;;
                --setup)
                    action_setup=1
                    ;;
                --check)
                    action_check=1
                    ;;
                --info)
                    action_info=1
                    ;;
                --help)
                    action_help=1 
                    ;;
                --verbose)
                    VERBOSE=1
                    ;;
                *)
                    action_help=1 
                    ;;
            esac
            OPTIND=1
            shift
            ;;
        ?)
            action_help=1 
            ;;
    esac
done

test $action_help && { usage $(basename $0); exit $?; }
test $action_info && { info; exit $?; }
test $action_setup && { setup; exit $?; }
test $action_update && update_config
test $action_check && check_ovpn

# Request port forwarding if action_port is set or no other action is
if test "$action_port" || ! test $action_port $action_dns $action_fw $action_check $action_info $action_update $action_setup; then
    client_id=$(cat $PIA_CLIENT_ID_FILE)
    if [[ -z "$client_id" ]] || [[ "$action_port" == "portfwd" ]]; then
        client_id=$(new_client_id)
    fi
    check_ovpn
    request_port $client_id
    unset client_id action_port
fi

# Block/Unblock non-VPN traffic if requested
case "$action_fw" in
    disallow) iplist_block ;;
    allow) iplist_unblock ;;
esac

case "$action_dns" in
    google) google_dns ;;
    restore) restore_dns ;;
    pia) pia_dns ;;
esac

exit 0
