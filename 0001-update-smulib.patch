diff --color --unified --recursive --text ryzen_monitor-1.0.5.orig/src/lib/libsmu.c ryzen_monitor-1.0.5.new/src/lib/libsmu.c
--- ryzen_monitor-1.0.5.orig/src/lib/libsmu.c	2023-09-04 19:34:05.001654260 +0200
+++ ryzen_monitor-1.0.5.new/src/lib/libsmu.c	2023-09-04 19:34:38.289651936 +0200
@@ -34,6 +34,7 @@
 #define SMU_ARG_PATH                    DRIVER_CLASS_PATH "smu_args"
 #define RSMU_CMD_PATH                   DRIVER_CLASS_PATH "rsmu_cmd"
 #define MP1_SMU_CMD_PATH                DRIVER_CLASS_PATH "mp1_smu_cmd"
+#define HSMP_SMU_CMD_PATH               DRIVER_CLASS_PATH "hsmp_smu_cmd"
 
 #define PM_VERSION_PATH                 DRIVER_CLASS_PATH "pm_table_version"
 #define PM_SIZE_PATH                    DRIVER_CLASS_PATH "pm_table_size"
@@ -45,7 +46,7 @@
 /* Maximum is defined as: "255.255.255.255\n" */
 #define LIBSMU_MAX_SMU_VERSION_LEN      16
 
-int try_open_path(const char* pathname, int mode, int* fd) {
+static int try_open_path(const char* pathname, int mode, int* fd) {
     int ret = 1;
 
     *fd = open(pathname, mode);
@@ -57,10 +58,10 @@
     return ret;
 }
 
-smu_return_val smu_init_parse(smu_obj_t* obj) {
+static smu_return_val smu_init_parse(smu_obj_t* obj) {
     int ver_maj, ver_min, ver_rev, ver_alt, len, i, c;
     char rd_buf[1024];
-    int tmp_fd, ret, ok;
+    int tmp_fd, ret;
 
     memset(rd_buf, 0, sizeof(rd_buf));
 
@@ -75,12 +76,7 @@
         return SMU_Return_RWError;
 
     // The driver version must match the expected exactly.
-    if (rd_buf[strlen(rd_buf)-1]=='\n') rd_buf[strlen(rd_buf)-1]=0;
-    printf("ryzen_smu version string: %s\n", rd_buf);
-    for (i=0,ok=0; i<KERNEL_DRIVER_SUPP_VERS_COUNT; i++)
-        if (!strcmp(rd_buf, kernel_driver_supported_versions[i]))
-            ok=1;
-    if (!ok)
+    if (strcmp(rd_buf, LIBSMU_SUPPORTED_DRIVER_VERSION "\n"))
         return SMU_Return_DriverVersion;
 
     sscanf(rd_buf, "%d.%d.%d\n", &ver_maj, &ver_min, &ver_rev);
@@ -101,8 +97,8 @@
         if (rd_buf[i] == '.')
             c++;
 
-    // Depending on the processor, there can be either a 3 or 4 part segment.
-    // We account for both
+    // Depending on the processor, there can be either a 3 or 4 part version segmentation.
+    // We account for both.
     switch (c) {
         case 2:
             ret = sscanf(rd_buf, "%d.%d.%d\n", &ver_maj, &ver_min, &ver_rev);
@@ -173,7 +169,7 @@
     return SMU_Return_OK;
 }
 
-int smu_init(smu_obj_t* obj) {
+smu_return_val smu_init(smu_obj_t* obj) {
     int i, ret;
 
     memset(obj, 0, sizeof(*obj));
@@ -186,6 +182,7 @@
     // The driver must provide access to these files.
     if (!try_open_path(SMN_PATH, O_RDWR, &obj->fd_smn) ||
         !try_open_path(MP1_SMU_CMD_PATH, O_RDWR, &obj->fd_mp1_smu_cmd) ||
+        !try_open_path(HSMP_SMU_CMD_PATH, O_RDWR, &obj->fd_hsmp_smu_cmd) ||
         !try_open_path(SMU_ARG_PATH, O_RDWR, &obj->fd_smu_args))
         return SMU_Return_RWError;
 
@@ -208,6 +205,9 @@
 void smu_free(smu_obj_t* obj) {
     int i;
 
+    if (!obj->init)
+        return;
+
     if (obj->fd_smn)
         close(obj->fd_smn);
 
@@ -217,6 +217,9 @@
     if (obj->fd_mp1_smu_cmd)
         close(obj->fd_mp1_smu_cmd);
 
+    if (obj->fd_hsmp_smu_cmd)
+        close(obj->fd_hsmp_smu_cmd);
+
     if (obj->fd_smu_args)
         close(obj->fd_smu_args);
 
@@ -235,6 +238,7 @@
     if (!obj->init)
         return "Uninitialized";
 
+    // Determine if this is a 24-bit or 32-bit version and show it accordingly.
     if (obj->smu_version & 0xff000000) {
         sprintf(fw, "%d.%d.%d.%d",
             (obj->smu_version >> 24) & 0xff, (obj->smu_version >> 16) & 0xff,
@@ -248,9 +252,13 @@
     return fw;
 }
 
-unsigned int smu_read_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int* result) {
+smu_return_val smu_read_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int* result) {
     unsigned int ret;
 
+    // Don't attempt to execute without initialization.
+    if (!obj->init)
+        return SMU_Return_Failed;
+
     pthread_mutex_lock(&obj->lock[SMU_MUTEX_SMN]);
 
     lseek(obj->fd_smn, 0, SEEK_SET);
@@ -271,6 +279,12 @@
 smu_return_val smu_write_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int value) {
     unsigned int buffer[2], ret;
 
+    // Don't attempt to execute without initialization.
+    if (!obj->init)
+        return SMU_Return_Failed;
+
+    // buffer[0] contains the destination write target.
+    // buffer[1] contains the value to write to the address.
     buffer[0] = address;
     buffer[1] = value;
 
@@ -284,10 +298,14 @@
     return ret == sizeof(buffer) ? SMU_Return_OK : SMU_Return_RWError;
 }
 
-smu_return_val smu_send_command(smu_obj_t* obj, unsigned int op, smu_arg_t args,
+smu_return_val smu_send_command(smu_obj_t* obj, unsigned int op, smu_arg_t* args,
     enum smu_mailbox mailbox) {
     unsigned int ret, status, fd_smu_cmd;
 
+    // Don't attempt to execute without initialization.
+    if (!obj->init)
+        return SMU_Return_Failed;
+
     switch (mailbox) {
         case TYPE_RSMU:
             fd_smu_cmd = obj->fd_rsmu_cmd;
@@ -295,20 +313,23 @@
         case TYPE_MP1:
             fd_smu_cmd = obj->fd_mp1_smu_cmd;
             break;
+        case TYPE_HSMP:
+            fd_smu_cmd = obj->fd_hsmp_smu_cmd;
+            break;
         default:
             return SMU_Return_Unsupported;
     }
 
-    // Check if fd is valid
+    // Check if fd is valid.
     if (!fd_smu_cmd)
         return SMU_Return_Unsupported;
 
     pthread_mutex_lock(&obj->lock[SMU_MUTEX_CMD]);
 
     lseek(obj->fd_smu_args, 0, SEEK_SET);
-    ret = write(obj->fd_smu_args, args.args, sizeof(args));
+    ret = write(obj->fd_smu_args, args->args, sizeof(*args));
 
-    if (ret != sizeof(args)) {
+    if (ret != sizeof(*args)) {
         ret = SMU_Return_RWError;
         goto BREAK_OUT;
     }
@@ -321,6 +342,9 @@
         goto BREAK_OUT;
     }
 
+    // Commands should be completed instantly as the driver attempts to continuously
+    //  execute it till a timeout has occurred and immediately updates the result.
+    // Therefore it shouldn't be necessary to apply any sort of waiting here.
     lseek(fd_smu_cmd, 0, SEEK_SET);
     ret = read(fd_smu_cmd, &status, sizeof(status));
 
@@ -331,10 +355,9 @@
 
     if (ret == SMU_Return_OK) {
         lseek(obj->fd_smu_args, 0, SEEK_SET);
-        ret = read(obj->fd_smu_args, args.args, sizeof(args.args));
-
-        if (ret != sizeof(args.args))
-            ret = SMU_Return_RWError;
+        ret = read(obj->fd_smu_args, args->args, sizeof(args->args)) == sizeof(args->args)
+            ? SMU_Return_OK
+            : SMU_Return_RWError;
     }
 
 BREAK_OUT:
@@ -346,6 +369,10 @@
 smu_return_val smu_read_pm_table(smu_obj_t* obj, unsigned char* dst, size_t dst_len) {
     int ret;
 
+    // Don't attempt to execute without initialization.
+    if (!obj->init)
+        return SMU_Return_Failed;
+
     if (dst_len != obj->pm_table_size)
         return SMU_Return_InsufficientSize;
 
@@ -386,6 +413,8 @@
             return "Insufficient Buffer Size Provided";
         case SMU_Return_MappedError:
             return "Memory Mapping I/O Error";
+        case SMU_Return_PCIFailed:
+            return "PCIe Programming Error";
         case SMU_Return_DriverNotPresent:
             return "SMU Driver Not Present Or Fault";
         case SMU_Return_RWError:
@@ -419,8 +448,8 @@
             return "Summit Ridge";
         case CODENAME_THREADRIPPER:
             return "Thread Ripper";
-        case CODENAME_REMBRANT:
-            return "Rembrant";
+        case CODENAME_REMBRANDT:
+            return "Rembrandt";
         case CODENAME_VERMEER:
             return "Vermeer";
         case CODENAME_VANGOGH:
@@ -431,6 +460,10 @@
             return "Milan";
         case CODENAME_DALI:
             return "Dali";
+        case CODENAME_LUCIENNE:
+            return "Lucienne";
+        case CODENAME_NAPLES:
+            return "Naples";
         default:
             return "Undefined";
     }
diff --color --unified --recursive --text ryzen_monitor-1.0.5.orig/src/lib/libsmu.h ryzen_monitor-1.0.5.new/src/lib/libsmu.h
--- ryzen_monitor-1.0.5.orig/src/lib/libsmu.h	2023-09-04 19:34:05.001654260 +0200
+++ ryzen_monitor-1.0.5.new/src/lib/libsmu.h	2023-09-04 19:34:41.848651688 +0200
@@ -24,12 +24,7 @@
 #include <pthread.h>
 
 /* Version the loaded driver must use to be compatible. */
-#define KERNEL_DRIVER_SUPP_VERS_COUNT 3
-static char kernel_driver_supported_versions[KERNEL_DRIVER_SUPP_VERS_COUNT][10] = {
-    "0.1.0",
-    "0.1.1",
-    "0.1.2"
-};
+#define LIBSMU_SUPPORTED_DRIVER_VERSION                    "0.1.5"
 
 /**
  * SMU Mailbox Target
@@ -37,6 +32,7 @@
 enum smu_mailbox {
     TYPE_RSMU,
     TYPE_MP1,
+    TYPE_HSMP,
 };
 
 /**
@@ -61,15 +57,17 @@
     SMU_Return_InsufficientSize  = 0xF8,
     // Failed to map physical address.
     SMU_Return_MappedError       = 0xF7,
+    // PCIe programming error.
+    SMU_Return_PCIFailed         = 0xF6,
 
     // Userspace Library Codes
 
     // Driver is not currently loaded or inaccessible.
-    SMU_Return_DriverNotPresent  = 0xF6,
+    SMU_Return_DriverNotPresent  = 0xF0,
     // Read or write error has occurred. Check errno for last error.
-    SMU_Return_RWError           = 0xF5,
+    SMU_Return_RWError           = 0xE9,
     // Driver version is incompatible.
-    SMU_Return_DriverVersion     = 0xF4,
+    SMU_Return_DriverVersion     = 0xE8,
 } smu_return_val;
 
 /**
@@ -87,14 +85,15 @@
     CODENAME_RAVENRIDGE2,
     CODENAME_SUMMITRIDGE,
     CODENAME_PINNACLERIDGE,
-
-    // Not yet supported but still added for now.
-    CODENAME_REMBRANT,
+    CODENAME_REMBRANDT,
     CODENAME_VERMEER,
     CODENAME_VANGOGH,
     CODENAME_CEZANNE,
     CODENAME_MILAN,
     CODENAME_DALI,
+    CODENAME_LUCIENNE,
+    CODENAME_NAPLES,
+    CODENAME_CHAGALL,
 
     CODENAME_COUNT
 } smu_processor_codename;
@@ -123,20 +122,21 @@
 };
 
 typedef struct {
-    /* Accessible To Users */
-    int                         init;
-    int                         driver_version;
+    /* Accessible To Users, Read-Only. */
+    unsigned int                init;
+    unsigned int                driver_version;
 
     smu_processor_codename      codename;
     smu_if_version              smu_if_version;
-    int                         smu_version;
-    int                         pm_table_size;
-    int                         pm_table_version;
+    unsigned int                smu_version;
+    unsigned int                pm_table_size;
+    unsigned int                pm_table_version;
 
     /* Internal Library Use Only */
     int                         fd_smn;
     int                         fd_rsmu_cmd;
     int                         fd_mp1_smu_cmd;
+    int                         fd_hsmp_smu_cmd;
     int                         fd_smu_args;
     int                         fd_pm_table;
 
@@ -167,13 +167,16 @@
 
 /**
  * Initializes or frees the userspace library for use.
- * Upon successful initialization, users are allowed to access
- *  codename, smu_version, pm_table_size and pm_table_version from
- *  the initialized structure.
+ * Upon successful initialization, users are allowed to access the following members:
+ *  - codename
+ *  - smu_if_version
+ *  - smu_version
+ *  - pm_table_size
+ *  - pm_table_version
  *
  * Returns SMU_Return_OK on success.
  */
-int smu_init(smu_obj_t* obj);
+smu_return_val smu_init(smu_obj_t* obj);
 void smu_free(smu_obj_t* obj);
 
 /**
@@ -184,7 +187,7 @@
 /**
  * Reads or writes a 32 bit word from the SMN address space.
  */
-unsigned int smu_read_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int* result);
+smu_return_val smu_read_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int* result);
 smu_return_val smu_write_smn_addr(smu_obj_t* obj, unsigned int address, unsigned int value);
 
 /**
@@ -193,7 +196,7 @@
  * 
  * Returns SMU_Return_OK on success.
  */
-smu_return_val smu_send_command(smu_obj_t* obj, unsigned int op, smu_arg_t args,
+smu_return_val smu_send_command(smu_obj_t* obj, unsigned int op, smu_arg_t *args,
     enum smu_mailbox mailbox);
 
 /**
