From 52a47361d0c6fc38f634e7076584e018066fc924 Mon Sep 17 00:00:00 2001
From: tokyo4j <hrak1529@gmail.com>
Date: Fri, 23 Feb 2024 03:50:55 +0900
Subject: [PATCH 2/3] IME: support popups

---
 include/input/ime.h |   7 +++
 include/node.h      |   1 +
 src/desktop.c       |   5 ++
 src/input/ime.c     | 137 ++++++++++++++++++++++++++++++++++++++++++++
 src/layers.c        |   5 ++
 src/output.c        |   2 +
 src/xdg.c           |   2 +-
 7 files changed, 158 insertions(+), 1 deletion(-)

diff --git a/include/input/ime.h b/include/input/ime.h
index d904625..97d5444 100644
--- a/include/input/ime.h
+++ b/include/input/ime.h
@@ -29,12 +29,19 @@ struct input_method_relay {
 	 */
 	struct text_input *active_text_input;
 
+	struct wlr_input_popup_surface_v2 *popup_surface;
+	struct wlr_scene_tree *popup_tree;
+
 	struct wl_listener new_text_input;
 	struct wl_listener new_input_method;
 
 	struct wl_listener input_method_commit;
 	struct wl_listener input_method_grab_keyboard;
 	struct wl_listener input_method_destroy;
+	struct wl_listener input_method_new_popup_surface;
+
+	struct wl_listener popup_surface_destroy;
+	struct wl_listener popup_surface_commit;
 
 	struct wl_listener keyboard_grab_destroy;
 	struct wl_listener focused_surface_destroy;
diff --git a/include/node.h b/include/node.h
index 419aa99..6d44664 100644
--- a/include/node.h
+++ b/include/node.h
@@ -15,6 +15,7 @@ enum node_descriptor_type {
 	LAB_NODE_DESC_XDG_POPUP,
 	LAB_NODE_DESC_LAYER_SURFACE,
 	LAB_NODE_DESC_LAYER_POPUP,
+	LAB_NODE_DESC_INPUT_METHOD_POPUP,
 	LAB_NODE_DESC_MENUITEM,
 	LAB_NODE_DESC_TREE,
 	LAB_NODE_DESC_SSD_BUTTON,
diff --git a/src/desktop.c b/src/desktop.c
index 35d56b8..aac7f73 100644
--- a/src/desktop.c
+++ b/src/desktop.c
@@ -416,6 +416,11 @@ get_cursor_context(struct server *server)
 				ret.type = LAB_SSD_CLIENT;
 				ret.surface = get_surface_from_layer_node(node);
 				return ret;
+			case LAB_NODE_DESC_INPUT_METHOD_POPUP:
+				ret.node = node;
+				ret.type = LAB_SSD_CLIENT;
+				ret.surface = lab_wlr_surface_from_node(node);
+				return ret;
 			case LAB_NODE_DESC_MENUITEM:
 				/* Always return the top scene node for menu items */
 				ret.node = node;
diff --git a/src/input/ime.c b/src/input/ime.c
index 18d5420..29a8f9c 100644
--- a/src/input/ime.c
+++ b/src/input/ime.c
@@ -152,6 +152,90 @@ update_text_inputs_focused_surface(struct input_method_relay *relay)
 	}
 }
 
+static void
+update_popup_position(struct input_method_relay *relay)
+{
+	struct server *server = relay->seat->server;
+	struct text_input *text_input = relay->active_text_input;
+
+	if (!text_input || !relay->focused_surface || !relay->popup_surface
+			|| !relay->popup_surface->surface->mapped) {
+		return;
+	}
+
+	struct wlr_box cursor_rect;
+	struct wlr_xdg_surface *xdg_surface =
+		wlr_xdg_surface_try_from_wlr_surface(relay->focused_surface);
+	struct wlr_layer_surface_v1 *layer_surface =
+		wlr_layer_surface_v1_try_from_wlr_surface(relay->focused_surface);
+
+	if ((text_input->input->current.features
+			& WLR_TEXT_INPUT_V3_FEATURE_CURSOR_RECTANGLE)
+			&& (xdg_surface || layer_surface)) {
+		cursor_rect = text_input->input->current.cursor_rectangle;
+
+		struct wlr_scene_tree *tree = relay->focused_surface->data;
+		int lx, ly;
+		wlr_scene_node_coords(&tree->node, &lx, &ly);
+		cursor_rect.x += lx;
+		cursor_rect.y += ly;
+
+		if (xdg_surface) {
+			/*
+			 * The position of cursor rectangle set by client
+			 * is in wl_surface-coordinate so we need to convert
+			 * it to offset relative to top-left corner of the
+			 * view (set by xdg_surface.set_window_geometry).
+			 */
+			cursor_rect.x -= xdg_surface->current.geometry.x;
+			cursor_rect.y -= xdg_surface->current.geometry.y;
+		}
+	} else {
+		cursor_rect = (struct wlr_box){0};
+	}
+
+	struct output *output =
+		output_nearest_to(server, cursor_rect.x, cursor_rect.y);
+	if (!output_is_usable(output)) {
+		wlr_log(WLR_ERROR,
+			"Cannot position IME popup (invalid output)");
+		return;
+	}
+	struct wlr_box output_box;
+	wlr_output_layout_get_box(server->output_layout, output->wlr_output,
+		&output_box);
+
+	/* Use xdg-positioner utilities to position popup */
+	struct wlr_xdg_positioner_rules rules = {
+		.anchor_rect = cursor_rect,
+		.anchor = XDG_POSITIONER_ANCHOR_BOTTOM_LEFT,
+		.gravity = XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT,
+		.size = {
+			.width = relay->popup_surface->surface->current.width,
+			.height = relay->popup_surface->surface->current.height,
+		},
+		.constraint_adjustment =
+			XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y
+			| XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X,
+	};
+
+	/* Calculate the popup position */
+	struct wlr_box popup_box;
+	wlr_xdg_positioner_rules_get_geometry(&rules, &popup_box);
+	wlr_xdg_positioner_rules_unconstrain_box(&rules, &output_box, &popup_box);
+
+	wlr_scene_node_set_position(&relay->popup_tree->node,
+		popup_box.x, popup_box.y);
+
+	wlr_input_popup_surface_v2_send_text_input_rectangle(
+		relay->popup_surface, &(struct wlr_box){
+			.x = cursor_rect.x - popup_box.x,
+			.y = cursor_rect.y - popup_box.y,
+			.width = cursor_rect.width,
+			.height = cursor_rect.height,
+		});
+}
+
 static void
 handle_input_method_commit(struct wl_listener *listener, void *data)
 {
@@ -236,6 +320,49 @@ handle_input_method_destroy(struct wl_listener *listener, void *data)
 	update_active_text_input(relay);
 }
 
+static void
+handle_popup_surface_destroy(struct wl_listener *listener, void *data)
+{
+	struct input_method_relay *relay = wl_container_of(listener, relay,
+		popup_surface_destroy);
+	wl_list_remove(&relay->popup_surface_destroy.link);
+	wl_list_remove(&relay->popup_surface_commit.link);
+	relay->popup_surface = NULL;
+}
+
+static void
+handle_popup_surface_commit(struct wl_listener *listener, void *data)
+{
+	struct input_method_relay *relay = wl_container_of(listener, relay,
+		popup_surface_commit);
+	update_popup_position(relay);
+}
+
+static void
+handle_input_method_new_popup_surface(struct wl_listener *listener, void *data)
+{
+	struct input_method_relay *relay = wl_container_of(listener, relay,
+		input_method_new_popup_surface);
+
+	if (relay->popup_surface) {
+		wlr_log(WLR_INFO, "Multiple IME popups are not supported");
+		return;
+	}
+
+	relay->popup_surface = data;
+
+	wl_signal_add(&relay->popup_surface->events.destroy,
+		&relay->popup_surface_destroy);
+	wl_signal_add(&relay->popup_surface->surface->events.commit,
+		&relay->popup_surface_commit);
+
+	struct wlr_scene_node *scene_node = &wlr_scene_surface_create(
+		relay->popup_tree, relay->popup_surface->surface)->buffer->node;
+	node_descriptor_create(scene_node, LAB_NODE_DESC_INPUT_METHOD_POPUP, NULL);
+
+	update_popup_position(relay);
+}
+
 static void
 handle_new_input_method(struct wl_listener *listener, void *data)
 {
@@ -268,6 +395,11 @@ handle_new_input_method(struct wl_listener *listener, void *data)
 	wl_signal_add(&relay->input_method->events.destroy,
 		&relay->input_method_destroy);
 
+	relay->input_method_new_popup_surface.notify =
+		handle_input_method_new_popup_surface;
+	wl_signal_add(&relay->input_method->events.new_popup_surface,
+		&relay->input_method_new_popup_surface);
+
 	update_text_inputs_focused_surface(relay);
 	update_active_text_input(relay);
 }
@@ -333,6 +465,7 @@ handle_text_input_commit(struct wl_listener *listener, void *data)
 	struct input_method_relay *relay = text_input->relay;
 
 	if (relay->active_text_input == text_input) {
+		update_popup_position(relay);
 		send_state_to_input_method(relay);
 	}
 }
@@ -412,6 +545,10 @@ input_method_relay_create(struct seat *seat)
 		&relay->new_input_method);
 
 	relay->focused_surface_destroy.notify = handle_focused_surface_destroy;
+	relay->popup_surface_destroy.notify = handle_popup_surface_destroy;
+	relay->popup_surface_commit.notify = handle_popup_surface_commit;
+
+	relay->popup_tree = wlr_scene_tree_create(&seat->server->scene->tree);
 
 	return relay;
 }
diff --git a/src/layers.c b/src/layers.c
index 79cffe9..be77f46 100644
--- a/src/layers.c
+++ b/src/layers.c
@@ -277,6 +277,8 @@ create_popup(struct wlr_xdg_popup *wlr_popup, struct wlr_scene_tree *parent,
 		free(popup);
 		return NULL;
 	}
+	/* In support of IME popups */
+	popup->wlr_popup->base->surface->data = popup->scene_tree;
 	node_descriptor_create(&popup->scene_tree->node,
 		LAB_NODE_DESC_LAYER_POPUP, popup);
 
@@ -402,6 +404,9 @@ handle_new_layer_surface(struct wl_listener *listener, void *data)
 		return;
 	}
 
+	/* In support of IME popups */
+	layer_surface->surface->data = surface->scene_layer_surface->tree;
+
 	node_descriptor_create(&surface->scene_layer_surface->tree->node,
 		LAB_NODE_DESC_LAYER_SURFACE, surface);
 
diff --git a/src/output.c b/src/output.c
index 6d05ee9..07ed2d3 100644
--- a/src/output.c
+++ b/src/output.c
@@ -320,6 +320,7 @@ new_output_notify(struct wl_listener *listener, void *data)
 	/*
 	 * Set the z-positions to achieve the following order (from top to
 	 * bottom):
+	 *	- IME popups
 	 *	- session lock layer
 	 *	- layer-shell popups
 	 *	- overlay layer
@@ -334,6 +335,7 @@ new_output_notify(struct wl_listener *listener, void *data)
 	wlr_scene_node_raise_to_top(&output->layer_tree[3]->node);
 	wlr_scene_node_raise_to_top(&output->layer_popup_tree->node);
 	wlr_scene_node_raise_to_top(&output->session_lock_tree->node);
+	wlr_scene_node_raise_to_top(&server->seat.input_method_relay->popup_tree->node);
 
 	/*
 	 * Wait until wlr_output_layout_add_auto() returns before
diff --git a/src/xdg.c b/src/xdg.c
index dc9acc9..8a96807 100644
--- a/src/xdg.c
+++ b/src/xdg.c
@@ -771,7 +771,7 @@ xdg_surface_new(struct wl_listener *listener, void *data)
 	 */
 	kde_server_decoration_set_view(view, xdg_surface->surface);
 
-	/* In support of xdg popups */
+	/* In support of xdg popups and IME popups */
 	xdg_surface->surface->data = tree;
 
 	view_connect_map(view, xdg_surface->surface);
-- 
2.43.2

