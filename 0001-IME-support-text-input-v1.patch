From f71b072bfdaa97a478d119b6615ebd6f48c57b7b Mon Sep 17 00:00:00 2001
From: tokyo4j <hrak1529@gmail.com>
Date: Fri, 23 Feb 2024 03:57:01 +0900
Subject: [PATCH] IME: support text-input-v1

---
 include/input/ime.h   |   1 +
 protocols/meson.build |   1 +
 src/input/ime.c       | 337 +++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 338 insertions(+), 1 deletion(-)

diff --git a/include/input/ime.h b/include/input/ime.h
index 06dd16f..2463809 100644
--- a/include/input/ime.h
+++ b/include/input/ime.h
@@ -50,6 +50,7 @@ struct input_method_relay {
 struct text_input {
 	struct input_method_relay *relay;
 	struct wlr_text_input_v3 *input;
+	bool v1;
 	struct wl_list link;
 
 	struct wl_listener enable;
diff --git a/protocols/meson.build b/protocols/meson.build
index acaf021..ffb371a 100644
--- a/protocols/meson.build
+++ b/protocols/meson.build
@@ -20,6 +20,7 @@ server_protocols = [
 	wl_protocol_dir / 'staging/drm-lease/drm-lease-v1.xml',
 	wl_protocol_dir / 'staging/xwayland-shell/xwayland-shell-v1.xml',
 	wl_protocol_dir / 'staging/tearing-control/tearing-control-v1.xml',
+	wl_protocol_dir / 'unstable/text-input/text-input-unstable-v1.xml',
 	'wlr-layer-shell-unstable-v1.xml',
 	'wlr-input-inhibitor-unstable-v1.xml',
 	'wlr-output-power-management-unstable-v1.xml',
diff --git a/src/input/ime.c b/src/input/ime.c
index bb08f6d..7c44d20 100644
--- a/src/input/ime.c
+++ b/src/input/ime.c
@@ -6,11 +6,277 @@
 #include "input/ime.h"
 #include "node.h"
 #include "view.h"
+#include "text-input-unstable-v1-protocol.h"
 
 #define SAME_CLIENT(wlr_obj1, wlr_obj2) \
 	(wl_resource_get_client((wlr_obj1)->resource) \
 	== wl_resource_get_client((wlr_obj2)->resource))
 
+/*
+ * ----------------------------------------------------------------------------
+ *                 text-input-unstable-v1 protocol support
+ * ----------------------------------------------------------------------------
+ * To reuse code for text-input-unstable-v3, zwp_text_input_v1 interface is
+ * wrapped as wlr_text_input_v3, by converting zwp_text_input_v1-specific
+ * events and emitting them as wlr_text_input_v3's events. When
+ * zwp_text_input_manager_v1.create_text_input event is received, a wrapped
+ * wlr_text_input_v3 is created and added to
+ * wlr_text_input_manager_v3.text_inputs.
+ * ----------------------------------------------------------------------------
+ */
+
+struct text_input_manager_v1 {
+	struct wl_global *global;
+	struct wlr_text_input_manager_v3 *wlr_manager_v3;
+	struct wl_listener display_destroy;
+};
+
+static void
+text_input_v1_clear_focused_surface(struct wlr_text_input_v3 *text_input)
+{
+	if (text_input->focused_surface) {
+		wl_list_remove(&text_input->surface_destroy.link);
+	}
+	text_input->focused_surface = NULL;
+}
+
+static void
+text_input_v1_clear_seat(struct wlr_text_input_v3 *text_input)
+{
+	if (text_input->seat) {
+		wl_list_remove(&text_input->seat_destroy.link);
+	}
+	text_input->seat = NULL;
+}
+
+static void
+text_input_v1_destroy(struct wlr_text_input_v3 *text_input)
+{
+	wl_signal_emit_mutable(&text_input->events.destroy, NULL);
+
+	text_input_v1_clear_focused_surface(text_input);
+	text_input_v1_clear_seat(text_input);
+
+	wl_list_remove(&text_input->link);
+	free(text_input->current.surrounding.text);
+	free(text_input);
+}
+
+static void
+handle_text_input_v1_focused_surface_destroy(struct wl_listener *listener,
+		void *data)
+{
+	struct wlr_text_input_v3 *text_input =
+		wl_container_of(listener, text_input, surface_destroy);
+	text_input_v1_clear_focused_surface(text_input);
+}
+
+static void
+handle_text_input_v1_activate(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *seat,
+		struct wl_resource *surface)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+	struct wlr_seat_client *seat_client = wlr_seat_client_from_resource(seat);
+
+	text_input->seat = seat_client->seat;
+	wl_signal_add(&seat_client->events.destroy, &text_input->seat_destroy);
+
+	text_input->current_enabled = true;
+	text_input->active_features = text_input->current.features;
+	wl_signal_emit_mutable(&text_input->events.enable, NULL);
+}
+
+static void
+handle_text_input_v1_deactivate(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *seat)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+
+	text_input_v1_clear_seat(text_input);
+
+	text_input->current_enabled = false;
+	text_input->active_features = 0;
+	wl_signal_emit_mutable(&text_input->events.disable, NULL);
+}
+
+static void
+handle_text_input_v1_reset(struct wl_client *client, struct wl_resource *resource)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+	text_input->current = (struct wlr_text_input_v3_state){0};
+	free(text_input->current.surrounding.text);
+	wl_signal_emit_mutable(&text_input->events.commit, NULL);
+}
+
+static void
+handle_text_input_v1_set_surrounding_text(struct wl_client *client,
+		struct wl_resource *resource, const char *text,
+		uint32_t cursor, uint32_t anchor)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+
+	free(text_input->current.surrounding.text);
+	text_input->current.surrounding.text = xstrdup(text);
+	text_input->current.surrounding.cursor = cursor;
+	text_input->current.surrounding.anchor = anchor;
+	text_input->current.features |= WLR_TEXT_INPUT_V3_FEATURE_SURROUNDING_TEXT;
+	text_input->active_features = text_input->current.features;
+	wl_signal_emit_mutable(&text_input->events.commit, NULL);
+}
+
+static void
+handle_text_input_v1_set_cursor_rectangle(struct wl_client *client,
+		struct wl_resource *resource, int32_t x, int32_t y,
+		int32_t width, int32_t height)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+	text_input->current.cursor_rectangle.x = x;
+	text_input->current.cursor_rectangle.y = y;
+	text_input->current.cursor_rectangle.width = width;
+	text_input->current.cursor_rectangle.height = height;
+	text_input->current.features |= WLR_TEXT_INPUT_V3_FEATURE_CURSOR_RECTANGLE;
+	text_input->active_features = text_input->current.features;
+	wl_signal_emit_mutable(&text_input->events.commit, NULL);
+}
+
+static void
+handle_text_input_v1_commit_state(struct wl_client *client,
+		struct wl_resource *resource, uint32_t serial)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+	text_input->current_serial = serial;
+}
+
+static void noop(void){}
+static const struct zwp_text_input_v1_interface text_input_impl = {
+	.activate = handle_text_input_v1_activate,
+	.deactivate = handle_text_input_v1_deactivate,
+	.show_input_panel = (__typeof__(text_input_impl.show_input_panel))noop,
+	.hide_input_panel = (__typeof__(text_input_impl.hide_input_panel))noop,
+	.reset = handle_text_input_v1_reset,
+	.set_surrounding_text = handle_text_input_v1_set_surrounding_text,
+	.set_content_type = (__typeof__(text_input_impl.set_content_type))noop,
+	.set_cursor_rectangle = handle_text_input_v1_set_cursor_rectangle,
+	.set_preferred_language = (__typeof__(text_input_impl.set_preferred_language))noop,
+	.commit_state = handle_text_input_v1_commit_state,
+	.invoke_action = (__typeof__(text_input_impl.invoke_action))noop,
+};
+
+static void
+handle_text_input_v1_resource_destroy(struct wl_resource *resource)
+{
+	struct wlr_text_input_v3 *text_input = wl_resource_get_user_data(resource);
+	if (!text_input) {
+		return;
+	}
+	text_input_v1_destroy(text_input);
+	wl_resource_set_user_data(resource, NULL);
+}
+
+static void
+handle_text_input_v1_seat_destroy(struct wl_listener *listener, void *data)
+{
+	struct wlr_text_input_v3 *text_input =
+		wl_container_of(listener, text_input, seat_destroy);
+	if (!text_input) {
+		return;
+	}
+	struct wl_resource *resource = text_input->resource;
+	text_input_v1_destroy(text_input);
+	wl_resource_set_user_data(resource, NULL);
+}
+
+static void
+handle_manager_v1_create_text_input(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id)
+{
+	int version = wl_resource_get_version(resource);
+	struct wl_resource *text_input_resource = wl_resource_create(client,
+		&zwp_text_input_v1_interface, version, id);
+	struct text_input_manager_v1 *manager_v1 = wl_resource_get_user_data(resource);
+	struct wlr_text_input_manager_v3 *wlr_manager_v3 = manager_v1->wlr_manager_v3;
+
+	struct wlr_text_input_v3 *text_input = znew(*text_input);
+	text_input->resource = text_input_resource;
+
+	wl_signal_init(&text_input->events.commit);
+	wl_signal_init(&text_input->events.enable);
+	wl_signal_init(&text_input->events.disable);
+	wl_signal_init(&text_input->events.destroy);
+
+	wl_resource_set_implementation(text_input_resource, &text_input_impl,
+		text_input, handle_text_input_v1_resource_destroy);
+
+	text_input->seat_destroy.notify =
+		handle_text_input_v1_seat_destroy;
+	text_input->surface_destroy.notify =
+		handle_text_input_v1_focused_surface_destroy;
+
+	wl_list_insert(&wlr_manager_v3->text_inputs, &text_input->link);
+
+	wl_signal_emit_mutable(&wlr_manager_v3->events.text_input, text_input);
+}
+
+static const struct zwp_text_input_manager_v1_interface text_input_manager_v1_impl = {
+	.create_text_input = handle_manager_v1_create_text_input,
+};
+
+static void
+handle_manager_v1_bind(struct wl_client *wl_client, void *data,
+		uint32_t version, uint32_t id)
+{
+	struct text_input_manager_v1 *manager_v1 = data;
+
+	struct wl_resource *resource = wl_resource_create(wl_client,
+		&zwp_text_input_manager_v1_interface, version, id);
+	wl_resource_set_implementation(resource, &text_input_manager_v1_impl,
+		manager_v1, NULL);
+}
+
+static void
+handle_display_destroy(struct wl_listener *listener, void *data)
+{
+	struct text_input_manager_v1 *manager_v1 =
+		wl_container_of(listener, manager_v1, display_destroy);
+	wl_list_remove(&manager_v1->display_destroy.link);
+	wl_global_destroy(manager_v1->global);
+	free(manager_v1);
+}
+
+static void
+text_input_manager_v1_init(struct wl_display *display,
+		struct wlr_text_input_manager_v3 *wlr_manager_v3)
+{
+	struct text_input_manager_v1 *manager_v1 = znew(*manager_v1);
+	manager_v1->wlr_manager_v3 = wlr_manager_v3;
+	manager_v1->global = wl_global_create(display,
+		&zwp_text_input_manager_v1_interface, 1, manager_v1,
+		handle_manager_v1_bind);
+	manager_v1->display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(display, &manager_v1->display_destroy);
+}
+
+static void
+text_input_v1_send_enter(struct wlr_text_input_v3 *text_input,
+		struct wlr_surface *surface)
+{
+	assert(!text_input->focused_surface);
+	text_input->focused_surface = surface;
+	wl_signal_add(&text_input->focused_surface->events.destroy,
+		&text_input->surface_destroy);
+	zwp_text_input_v1_send_enter(text_input->resource,
+		surface->resource);
+}
+
+static void
+text_input_v1_send_leave(struct wlr_text_input_v3 *text_input)
+{
+	assert(text_input->focused_surface);
+	text_input_v1_clear_focused_surface(text_input);
+	zwp_text_input_v1_send_leave(text_input->resource);
+}
+
 /*
  * Get keyboard grab of the seat from keyboard if we should forward events
  * to it.
@@ -144,9 +410,16 @@ update_text_inputs_focused_surface(struct input_method_relay *relay)
 			continue;
 		}
 		if (input->focused_surface) {
+			if (text_input->v1)
+				text_input_v1_send_leave(input);
+			else
 			wlr_text_input_v3_send_leave(input);
 		}
 		if (new_focused_surface) {
+			if (text_input->v1)
+				text_input_v1_send_enter(input,
+					new_focused_surface);
+			else
 			wlr_text_input_v3_send_enter(input, new_focused_surface);
 		}
 	}
@@ -253,6 +526,62 @@ handle_input_method_commit(struct wl_listener *listener, void *data)
 		return;
 	}
 
+	if (text_input->v1) {
+		/*
+		 * For some reason, if I send commit_string after preedit_string,
+		 * the text is doubled in the integrated terminal of VSCode.
+		 */
+		if (input_method->current.commit_text) {
+			zwp_text_input_v1_send_commit_string(
+				text_input->input->resource,
+				text_input->input->current_serial,
+				input_method->current.commit_text);
+		}
+		if (input_method->current.preedit.text) {
+			int preedit_len = strlen(input_method->current.preedit.text);
+			zwp_text_input_v1_send_preedit_cursor(
+				text_input->input->resource,
+				input_method->current.preedit.cursor_begin
+			);
+			if (0 < input_method->current.preedit.cursor_begin) {
+				zwp_text_input_v1_send_preedit_styling(
+					text_input->input->resource, 0,
+					input_method->current.preedit.cursor_begin,
+					ZWP_TEXT_INPUT_V1_PREEDIT_STYLE_UNDERLINE);
+			}
+			if (input_method->current.preedit.cursor_begin
+					< input_method->current.preedit.cursor_end) {
+				zwp_text_input_v1_send_preedit_styling(
+					text_input->input->resource,
+					input_method->current.preedit.cursor_begin,
+					input_method->current.preedit.cursor_end
+						- input_method->current.preedit.cursor_begin,
+					ZWP_TEXT_INPUT_V1_PREEDIT_STYLE_HIGHLIGHT);
+			}
+			if (input_method->current.preedit.cursor_end < preedit_len) {
+				zwp_text_input_v1_send_preedit_styling(
+					text_input->input->resource,
+					input_method->current.preedit.cursor_end,
+					preedit_len - input_method->current.preedit.cursor_end,
+					ZWP_TEXT_INPUT_V1_PREEDIT_STYLE_UNDERLINE);
+			}
+			zwp_text_input_v1_send_preedit_string(
+				text_input->input->resource,
+				text_input->input->current_serial,
+				input_method->current.preedit.text,
+				input_method->current.preedit.text);
+		} else {
+			zwp_text_input_v1_send_preedit_cursor(
+				text_input->input->resource, 0);
+			zwp_text_input_v1_send_preedit_styling(
+				text_input->input->resource, 0, 0,
+				ZWP_TEXT_INPUT_V1_PREEDIT_STYLE_NONE);
+			zwp_text_input_v1_send_preedit_string(
+				text_input->input->resource,
+				text_input->input->current_serial, "", "");
+		}
+		return;
+	}
 	if (input_method->current.preedit.text) {
 		wlr_text_input_v3_send_preedit_string(
 			text_input->input,
@@ -505,11 +834,14 @@ handle_new_text_input(struct wl_listener *listener, void *data)
 	struct input_method_relay *relay =
 		wl_container_of(listener, relay, new_text_input);
 	struct wlr_text_input_v3 *wlr_text_input = data;
-	if (relay->seat->seat != wlr_text_input->seat) {
+	bool is_v1 = !strcmp("zwp_text_input_v1",
+		wl_resource_get_class(wlr_text_input->resource));
+	if (!is_v1 && relay->seat->seat != wlr_text_input->seat) {
 		return;
 	}
 
 	struct text_input *text_input = znew(*text_input);
+	text_input->v1 = is_v1;
 	text_input->input = wlr_text_input;
 	text_input->relay = relay;
 	wl_list_insert(&relay->text_inputs, &text_input->link);
@@ -563,6 +895,9 @@ input_method_relay_create(struct seat *seat)
 	relay->popup_surface_destroy.notify = handle_popup_surface_destroy;
 	relay->popup_surface_commit.notify = handle_popup_surface_commit;
 
+	text_input_manager_v1_init(seat->server->wl_display,
+		seat->server->text_input_manager);
+
 	return relay;
 }
 
-- 
2.44.0

