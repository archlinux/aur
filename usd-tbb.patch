From 9443dc6121948c054ade923ab0ee4fddfa6214a1 Mon Sep 17 00:00:00 2001
From: Alex Fuller <boberfly@gmail.com>
Date: Wed, 17 May 2023 16:27:47 +0200
Subject: [PATCH 01/14] oneTBB: tbb::atomic to std::atomic in pcp

---
 pxr/usd/pcp/mapExpression.cpp | 4 ++--
 pxr/usd/pcp/mapExpression.h   | 3 +--
 pxr/usd/pcp/pch.h             | 1 -
 3 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/pxr/usd/pcp/mapExpression.cpp b/pxr/usd/pcp/mapExpression.cpp
index d8f90d7eef..ad8b7df1ee 100644
--- a/pxr/usd/pcp/mapExpression.cpp
+++ b/pxr/usd/pcp/mapExpression.cpp
@@ -238,7 +238,7 @@ PcpMapExpression::_Node::New( _Op op_,
         // Check for existing instance to re-use
         _NodeMap::accessor accessor;
         if (_nodeRegistry->map.insert(accessor, key) ||
-            accessor->second->_refCount.fetch_and_increment() == 0) {
+            accessor->second->_refCount.fetch_add(1) == 0) {
             // Either there was no node in the table, or there was but it had
             // begun dying (another client dropped its refcount to 0).  We have
             // to create a new node in the table.  When the client that is
@@ -388,7 +388,7 @@ intrusive_ptr_add_ref(PcpMapExpression::_Node* p)
 void
 intrusive_ptr_release(PcpMapExpression::_Node* p)
 {
-    if (p->_refCount.fetch_and_decrement() == 1)
+    if (p->_refCount.fetch_sub(1) == 1)
         delete p;
 }
 
diff --git a/pxr/usd/pcp/mapExpression.h b/pxr/usd/pcp/mapExpression.h
index 9c89201416..2b34621098 100644
--- a/pxr/usd/pcp/mapExpression.h
+++ b/pxr/usd/pcp/mapExpression.h
@@ -30,7 +30,6 @@
 
 #include <boost/intrusive_ptr.hpp>
 
-#include <tbb/atomic.h>
 #include <tbb/spin_mutex.h>
 
 #include <atomic>
@@ -267,7 +266,7 @@ class PcpMapExpression
         struct _NodeMap;
         static TfStaticData<_NodeMap> _nodeRegistry;
 
-        mutable tbb::atomic<int> _refCount;
+        mutable std::atomic<int> _refCount;
         mutable Value _cachedValue;
         mutable std::set<_Node*> _dependentExpressions;
         Value _valueForVariable;
diff --git a/pxr/usd/pcp/pch.h b/pxr/usd/pcp/pch.h
index a7180637dd..220c3ef386 100644
--- a/pxr/usd/pcp/pch.h
+++ b/pxr/usd/pcp/pch.h
@@ -194,7 +194,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>

From 28d51e991f21f6e3cc13d274926ccb69b0c65a73 Mon Sep 17 00:00:00 2001
From: Alex Fuller <boberfly@gmail.com>
Date: Wed, 17 May 2023 16:27:47 +0200
Subject: [PATCH 02/14] oneTBB: tbb::atomic to std::atomic in usdGeom

---
 pxr/usd/usdGeom/bboxCache.cpp | 21 +++++++++++++++++----
 pxr/usd/usdGeom/pch.h         |  1 -
 2 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/pxr/usd/usdGeom/bboxCache.cpp b/pxr/usd/usdGeom/bboxCache.cpp
index 454f97bcb8..68d2b30d71 100644
--- a/pxr/usd/usdGeom/bboxCache.cpp
+++ b/pxr/usd/usdGeom/bboxCache.cpp
@@ -46,6 +46,7 @@
 
 #include <tbb/enumerable_thread_specific.h>
 #include <algorithm>
+#include <atomic>
 
 PXR_NAMESPACE_OPEN_SCOPE
 
@@ -124,11 +125,24 @@ class UsdGeomBBoxCache::_PrototypeBBoxResolver
 
     struct _PrototypeTask
     {
-        _PrototypeTask() : numDependencies(0) { }
+        _PrototypeTask() noexcept
+            : numDependencies(0) { }
+
+        _PrototypeTask(const _PrototypeTask &other) noexcept
+            : dependentPrototypes(other.dependentPrototypes)
+        {
+            numDependencies.store(other.numDependencies.load());
+        }
+
+        _PrototypeTask(_PrototypeTask &&other) noexcept
+            : dependentPrototypes(std::move(other.dependentPrototypes))
+        {
+            numDependencies.store(other.numDependencies.load());
+        }
 
         // Number of dependencies -- prototype prims that must be resolved
         // before this prototype can be resolved.
-        tbb::atomic<size_t> numDependencies;
+        std::atomic<size_t> numDependencies;
 
         // List of prototype prims that depend on this prototype.
         std::vector<_PrimContext> dependentPrototypes;
@@ -220,7 +234,7 @@ class UsdGeomBBoxCache::_PrototypeBBoxResolver
             _PrototypeTask& dependentPrototypeData =
                 prototypeTasks->find(dependentPrototype)->second;
             if (dependentPrototypeData.numDependencies
-                .fetch_and_decrement() == 1){
+                .fetch_sub(1) == 1){
                 dispatcher->Run(
                     &_PrototypeBBoxResolver::_ExecuteTaskForPrototype,
                     this, dependentPrototype, prototypeTasks, xfCaches,
@@ -1522,4 +1536,3 @@ UsdGeomBBoxCache::_PrimContext::ToString() const {
 }
 
 PXR_NAMESPACE_CLOSE_SCOPE
-
diff --git a/pxr/usd/usdGeom/pch.h b/pxr/usd/usdGeom/pch.h
index 824c5b0f93..1a5fd65073 100644
--- a/pxr/usd/usdGeom/pch.h
+++ b/pxr/usd/usdGeom/pch.h
@@ -181,7 +181,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>

From 173bf3ababe2796fb67417ac0abc62495948d93b Mon Sep 17 00:00:00 2001
From: Alex Fuller <boberfly@gmail.com>
Date: Wed, 17 May 2023 16:27:47 +0200
Subject: [PATCH 03/14] oneTBB: tbb::atomic to std::atomic in sdf

---
 pxr/usd/sdf/changeManager.cpp | 10 +++++-----
 pxr/usd/sdf/layer.cpp         |  2 +-
 pxr/usd/sdf/layer.h           |  2 +-
 pxr/usd/sdf/pch.h             |  1 -
 4 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/pxr/usd/sdf/changeManager.cpp b/pxr/usd/sdf/changeManager.cpp
index 9d55d29a3d..00b9095627 100644
--- a/pxr/usd/sdf/changeManager.cpp
+++ b/pxr/usd/sdf/changeManager.cpp
@@ -34,7 +34,7 @@
 #include "pxr/base/tf/instantiateSingleton.h"
 #include "pxr/base/tf/stackTrace.h"
 
-#include <tbb/atomic.h>
+#include <atomic>
 
 using std::string;
 using std::vector;
@@ -150,9 +150,9 @@ Sdf_ChangeManager::_ProcessRemoveIfInert(_Data *data)
     TF_VERIFY(data->outermostBlock);
 }
 
-static tbb::atomic<size_t> &
+static std::atomic<size_t> &
 _InitChangeSerialNumber() {
-    static tbb::atomic<size_t> value;
+    static std::atomic<size_t> value;
     value = 1;
     return value;
 }
@@ -191,8 +191,8 @@ Sdf_ChangeManager::_SendNotices(_Data *data)
     }
 
     // Obtain a serial number for this round of change processing.
-    static tbb::atomic<size_t> &changeSerialNumber = _InitChangeSerialNumber();
-    size_t serialNumber = changeSerialNumber.fetch_and_increment();
+    static std::atomic<size_t> &changeSerialNumber = _InitChangeSerialNumber();
+    size_t serialNumber = changeSerialNumber.fetch_add(1);
 
     // Send global notice.
     SdfNotice::LayersDidChange(changes, serialNumber).Send();
diff --git a/pxr/usd/sdf/layer.cpp b/pxr/usd/sdf/layer.cpp
index 6ff2b4dceb..9ad0803e80 100644
--- a/pxr/usd/sdf/layer.cpp
+++ b/pxr/usd/sdf/layer.cpp
@@ -214,7 +214,7 @@ SdfLayer::SdfLayer(
     _MarkCurrentStateAsClean();
 }
 
-SdfLayer::~SdfLayer()
+SdfLayer::~SdfLayer() noexcept
 {
     TF_PY_ALLOW_THREADS_IN_SCOPE();
 
diff --git a/pxr/usd/sdf/layer.h b/pxr/usd/sdf/layer.h
index 514f27f38f..75f84cbd2c 100644
--- a/pxr/usd/sdf/layer.h
+++ b/pxr/usd/sdf/layer.h
@@ -98,7 +98,7 @@ class SdfLayer
 public:
     /// Destructor
     SDF_API
-    virtual ~SdfLayer(); 
+    virtual ~SdfLayer() noexcept; // noexcept needed for std::atomic member
 
     /// Noncopyable
     SdfLayer(const SdfLayer&) = delete;
diff --git a/pxr/usd/sdf/pch.h b/pxr/usd/sdf/pch.h
index 0728ebe683..6af480e7e3 100644
--- a/pxr/usd/sdf/pch.h
+++ b/pxr/usd/sdf/pch.h
@@ -225,7 +225,6 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>

From 0677c3cace63cf965930a314e6ac9c80e5b6482f Mon Sep 17 00:00:00 2001
From: Alex Fuller <boberfly@gmail.com>
Date: Wed, 17 May 2023 16:27:47 +0200
Subject: [PATCH 04/14] oneTBB: remove tbb atomic includes in precompiled
 headers

---
 extras/usd/examples/usdObj/pch.h            | 1 -
 extras/usd/examples/usdSchemaExamples/pch.h | 1 -
 pxr/base/plug/pch.h                         | 1 -
 pxr/base/tf/pch.h                           | 1 -
 pxr/base/trace/pch.h                        | 1 -
 pxr/base/vt/pch.h                           | 1 -
 pxr/base/work/pch.h                         | 1 -
 pxr/imaging/garch/pch.h                     | 1 -
 pxr/imaging/glf/pch.h                       | 1 -
 pxr/imaging/hd/pch.h                        | 1 -
 pxr/imaging/hdGp/pch.h                      | 1 -
 pxr/imaging/hdMtlx/pch.h                    | 1 -
 pxr/imaging/hdSt/pch.h                      | 1 -
 pxr/imaging/hdar/pch.h                      | 1 -
 pxr/imaging/hdsi/pch.h                      | 1 -
 pxr/imaging/hdx/pch.h                       | 1 -
 pxr/imaging/hgiMetal/pch.h                  | 1 -
 pxr/imaging/plugin/hdEmbree/pch.h           | 1 -
 pxr/imaging/plugin/hdStorm/pch.h            | 1 -
 pxr/imaging/plugin/hioOiio/pch.h            | 1 -
 pxr/usd/ar/pch.h                            | 1 -
 pxr/usd/ndr/pch.h                           | 1 -
 pxr/usd/plugin/usdAbc/pch.h                 | 1 -
 pxr/usd/plugin/usdDraco/pch.h               | 1 -
 pxr/usd/usd/pch.h                           | 1 -
 pxr/usd/usdHydra/pch.h                      | 1 -
 pxr/usd/usdLux/pch.h                        | 1 -
 pxr/usd/usdMedia/pch.h                      | 1 -
 pxr/usd/usdMtlx/pch.h                       | 1 -
 pxr/usd/usdPhysics/pch.h                    | 1 -
 pxr/usd/usdProc/pch.h                       | 1 -
 pxr/usd/usdRender/pch.h                     | 1 -
 pxr/usd/usdRi/pch.h                         | 1 -
 pxr/usd/usdShade/pch.h                      | 1 -
 pxr/usd/usdSkel/pch.h                       | 1 -
 pxr/usd/usdUI/pch.h                         | 1 -
 pxr/usd/usdUtils/pch.h                      | 1 -
 pxr/usd/usdVol/pch.h                        | 1 -
 38 files changed, 38 deletions(-)

diff --git a/extras/usd/examples/usdObj/pch.h b/extras/usd/examples/usdObj/pch.h
index 6a8744cbc7..5e95273058 100644
--- a/extras/usd/examples/usdObj/pch.h
+++ b/extras/usd/examples/usdObj/pch.h
@@ -166,7 +166,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/extras/usd/examples/usdSchemaExamples/pch.h b/extras/usd/examples/usdSchemaExamples/pch.h
index 47666439a2..ef31dc083d 100644
--- a/extras/usd/examples/usdSchemaExamples/pch.h
+++ b/extras/usd/examples/usdSchemaExamples/pch.h
@@ -168,7 +168,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/base/plug/pch.h b/pxr/base/plug/pch.h
index 98b6fc7825..64ffff9b92 100644
--- a/pxr/base/plug/pch.h
+++ b/pxr/base/plug/pch.h
@@ -183,7 +183,6 @@
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_vector.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git a/pxr/base/tf/pch.h b/pxr/base/tf/pch.h
index 64e232c846..01781a6a06 100644
--- a/pxr/base/tf/pch.h
+++ b/pxr/base/tf/pch.h
@@ -242,7 +242,6 @@
 #include <boost/variant.hpp>
 #include <boost/variant/get.hpp>
 #include <boost/variant/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_mutex.h>
 #include <tbb/spin_rw_mutex.h>
diff --git a/pxr/base/trace/pch.h b/pxr/base/trace/pch.h
index 25f4b5d6cf..e98e183088 100644
--- a/pxr/base/trace/pch.h
+++ b/pxr/base/trace/pch.h
@@ -178,7 +178,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_vector.h>
diff --git a/pxr/base/vt/pch.h b/pxr/base/vt/pch.h
index 75f03bee27..3924c8f020 100644
--- a/pxr/base/vt/pch.h
+++ b/pxr/base/vt/pch.h
@@ -171,7 +171,6 @@
 #include <boost/type_traits/is_same.hpp>
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_unordered_map.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git a/pxr/base/work/pch.h b/pxr/base/work/pch.h
index 228b18d0d8..79030be79e 100644
--- a/pxr/base/work/pch.h
+++ b/pxr/base/work/pch.h
@@ -110,7 +110,6 @@
 #include <boost/type_traits/is_enum.hpp>
 #include <boost/type_traits/is_same.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_vector.h>
diff --git a/pxr/imaging/garch/pch.h b/pxr/imaging/garch/pch.h
index 7ef3bd8afd..7d13f55560 100644
--- a/pxr/imaging/garch/pch.h
+++ b/pxr/imaging/garch/pch.h
@@ -145,7 +145,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_rw_mutex.h>
 #ifdef PXR_PYTHON_SUPPORT_ENABLED
diff --git a/pxr/imaging/glf/pch.h b/pxr/imaging/glf/pch.h
index 9a7e85a6c4..9e396e34bf 100644
--- a/pxr/imaging/glf/pch.h
+++ b/pxr/imaging/glf/pch.h
@@ -199,7 +199,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/hd/pch.h b/pxr/imaging/hd/pch.h
index 604861b7b1..fe94789a2e 100644
--- a/pxr/imaging/hd/pch.h
+++ b/pxr/imaging/hd/pch.h
@@ -152,7 +152,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/hdGp/pch.h b/pxr/imaging/hdGp/pch.h
index bf09080c29..ad94cf86e1 100644
--- a/pxr/imaging/hdGp/pch.h
+++ b/pxr/imaging/hdGp/pch.h
@@ -120,7 +120,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git a/pxr/imaging/hdMtlx/pch.h b/pxr/imaging/hdMtlx/pch.h
index bf8ff6a368..dd22c8c14c 100644
--- a/pxr/imaging/hdMtlx/pch.h
+++ b/pxr/imaging/hdMtlx/pch.h
@@ -139,7 +139,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/hdSt/pch.h b/pxr/imaging/hdSt/pch.h
index 196960f7b7..d4377da1cc 100644
--- a/pxr/imaging/hdSt/pch.h
+++ b/pxr/imaging/hdSt/pch.h
@@ -170,7 +170,6 @@
 #include <opensubdiv/osd/cpuVertexBuffer.h>
 #include <opensubdiv/osd/mesh.h>
 #include <opensubdiv/version.h>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/hdar/pch.h b/pxr/imaging/hdar/pch.h
index 56d867c1ce..f34080f5cf 100644
--- a/pxr/imaging/hdar/pch.h
+++ b/pxr/imaging/hdar/pch.h
@@ -131,7 +131,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git a/pxr/imaging/hdsi/pch.h b/pxr/imaging/hdsi/pch.h
index 1662d7e8b3..1f7c8223ba 100644
--- a/pxr/imaging/hdsi/pch.h
+++ b/pxr/imaging/hdsi/pch.h
@@ -119,7 +119,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/concurrent_queue.h>
 #ifdef PXR_PYTHON_SUPPORT_ENABLED
 #include "pxr/base/tf/pySafePython.h"
diff --git a/pxr/imaging/hdx/pch.h b/pxr/imaging/hdx/pch.h
index 33ddb1b5da..8fcf02aace 100644
--- a/pxr/imaging/hdx/pch.h
+++ b/pxr/imaging/hdx/pch.h
@@ -152,7 +152,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/hgiMetal/pch.h b/pxr/imaging/hgiMetal/pch.h
index 877bc45ee5..dd9f067dd3 100644
--- a/pxr/imaging/hgiMetal/pch.h
+++ b/pxr/imaging/hgiMetal/pch.h
@@ -141,7 +141,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git a/pxr/imaging/plugin/hdEmbree/pch.h b/pxr/imaging/plugin/hdEmbree/pch.h
index 7710229804..733d83b218 100644
--- a/pxr/imaging/plugin/hdEmbree/pch.h
+++ b/pxr/imaging/plugin/hdEmbree/pch.h
@@ -154,7 +154,6 @@
 #include <embree3/rtcore.h>
 #include <embree3/rtcore_geometry.h>
 #include <embree3/rtcore_ray.h>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/imaging/plugin/hdStorm/pch.h b/pxr/imaging/plugin/hdStorm/pch.h
index 33c5124a97..081338138a 100644
--- a/pxr/imaging/plugin/hdStorm/pch.h
+++ b/pxr/imaging/plugin/hdStorm/pch.h
@@ -141,7 +141,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git a/pxr/imaging/plugin/hioOiio/pch.h b/pxr/imaging/plugin/hioOiio/pch.h
index 9a7e85a6c4..9e396e34bf 100644
--- a/pxr/imaging/plugin/hioOiio/pch.h
+++ b/pxr/imaging/plugin/hioOiio/pch.h
@@ -199,7 +199,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usd/ar/pch.h b/pxr/usd/ar/pch.h
index b3333376f4..4f60d1b768 100644
--- a/pxr/usd/ar/pch.h
+++ b/pxr/usd/ar/pch.h
@@ -166,7 +166,6 @@
 #include <boost/type_traits/is_same.hpp>
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_rw_mutex.h>
diff --git a/pxr/usd/ndr/pch.h b/pxr/usd/ndr/pch.h
index 897ad796bf..8aefd88ee2 100644
--- a/pxr/usd/ndr/pch.h
+++ b/pxr/usd/ndr/pch.h
@@ -198,7 +198,6 @@
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git a/pxr/usd/plugin/usdAbc/pch.h b/pxr/usd/plugin/usdAbc/pch.h
index f5c7e6fb6c..33cc2cacb4 100644
--- a/pxr/usd/plugin/usdAbc/pch.h
+++ b/pxr/usd/plugin/usdAbc/pch.h
@@ -206,7 +206,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/plugin/usdDraco/pch.h b/pxr/usd/plugin/usdDraco/pch.h
index aff99924d4..ce6d0d1149 100644
--- a/pxr/usd/plugin/usdDraco/pch.h
+++ b/pxr/usd/plugin/usdDraco/pch.h
@@ -169,7 +169,6 @@
 #include <draco/compression/encode.h>
 #include <draco/mesh/mesh.h>
 #include <draco/mesh/mesh_misc_functions.h>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usd/pch.h b/pxr/usd/usd/pch.h
index d360999d4b..f708a4d9ed 100644
--- a/pxr/usd/usd/pch.h
+++ b/pxr/usd/usd/pch.h
@@ -227,7 +227,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/utility/in_place_factory.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
diff --git a/pxr/usd/usdHydra/pch.h b/pxr/usd/usdHydra/pch.h
index 5ba9df4c20..61ffecdf05 100644
--- a/pxr/usd/usdHydra/pch.h
+++ b/pxr/usd/usdHydra/pch.h
@@ -162,7 +162,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdLux/pch.h b/pxr/usd/usdLux/pch.h
index 8fe34cb954..e503ef1049 100644
--- a/pxr/usd/usdLux/pch.h
+++ b/pxr/usd/usdLux/pch.h
@@ -177,7 +177,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdMedia/pch.h b/pxr/usd/usdMedia/pch.h
index 7802ec3e2d..8388208cd4 100644
--- a/pxr/usd/usdMedia/pch.h
+++ b/pxr/usd/usdMedia/pch.h
@@ -170,7 +170,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdMtlx/pch.h b/pxr/usd/usdMtlx/pch.h
index 5eba44e7ed..88f7872389 100644
--- a/pxr/usd/usdMtlx/pch.h
+++ b/pxr/usd/usdMtlx/pch.h
@@ -193,7 +193,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git a/pxr/usd/usdPhysics/pch.h b/pxr/usd/usdPhysics/pch.h
index 824c5b0f93..1a5fd65073 100644
--- a/pxr/usd/usdPhysics/pch.h
+++ b/pxr/usd/usdPhysics/pch.h
@@ -181,7 +181,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usd/usdProc/pch.h b/pxr/usd/usdProc/pch.h
index f40455a1ca..fc95220bdf 100644
--- a/pxr/usd/usdProc/pch.h
+++ b/pxr/usd/usdProc/pch.h
@@ -165,7 +165,6 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdRender/pch.h b/pxr/usd/usdRender/pch.h
index 7802ec3e2d..8388208cd4 100644
--- a/pxr/usd/usdRender/pch.h
+++ b/pxr/usd/usdRender/pch.h
@@ -170,7 +170,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdRi/pch.h b/pxr/usd/usdRi/pch.h
index 905d2a1236..ba6c609881 100644
--- a/pxr/usd/usdRi/pch.h
+++ b/pxr/usd/usdRi/pch.h
@@ -173,7 +173,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdShade/pch.h b/pxr/usd/usdShade/pch.h
index 698ab0ca65..8e0433d34b 100644
--- a/pxr/usd/usdShade/pch.h
+++ b/pxr/usd/usdShade/pch.h
@@ -179,7 +179,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usd/usdSkel/pch.h b/pxr/usd/usdSkel/pch.h
index a4205ac46d..63975be9db 100644
--- a/pxr/usd/usdSkel/pch.h
+++ b/pxr/usd/usdSkel/pch.h
@@ -180,7 +180,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usd/usdUI/pch.h b/pxr/usd/usdUI/pch.h
index 47666439a2..ef31dc083d 100644
--- a/pxr/usd/usdUI/pch.h
+++ b/pxr/usd/usdUI/pch.h
@@ -168,7 +168,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usd/usdUtils/pch.h b/pxr/usd/usdUtils/pch.h
index 3a108ee5ef..e76753154e 100644
--- a/pxr/usd/usdUtils/pch.h
+++ b/pxr/usd/usdUtils/pch.h
@@ -215,7 +215,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usd/usdVol/pch.h b/pxr/usd/usdVol/pch.h
index 7802ec3e2d..8388208cd4 100644
--- a/pxr/usd/usdVol/pch.h
+++ b/pxr/usd/usdVol/pch.h
@@ -170,7 +170,6 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>

From a7818dbb41a3de454b351879708b2430e77ae8e6 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:26 +0200
Subject: [PATCH 05/14] oneTBB: change tbb::tbb_thread to std::thread

---
 pxr/base/tf/testenv/error.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/pxr/base/tf/testenv/error.cpp b/pxr/base/tf/testenv/error.cpp
index e8eed44a4d..606b2a9437 100644
--- a/pxr/base/tf/testenv/error.cpp
+++ b/pxr/base/tf/testenv/error.cpp
@@ -29,7 +29,7 @@
 
 #include "pxr/base/arch/functionLite.h"
 
-#include <tbb/tbb_thread.h>
+#include <thread>
 
 #define FILENAME   "error.cpp"
 
@@ -195,7 +195,7 @@ Test_TfErrorThreadTransport()
     printf("Creating TfErrorMark\n");
     TfErrorMark m;
     printf("Launching thread\n");
-    tbb::tbb_thread t([&transport]() { _ThreadTask(&transport); });
+    std::thread t([&transport]() { _ThreadTask(&transport); });
     TF_AXIOM(m.IsClean());
     t.join();
     printf("Thread completed, posting error.\n");

From e3809bb66807e6833a16199e823b610bd4d80fdb Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:24 +0200
Subject: [PATCH 06/14] oneTBB: change tbb::mutex to std::mutex

---
 pxr/usd/usd/clipCache.cpp | 22 ++++++++++------------
 pxr/usd/usd/clipCache.h   |  4 ++--
 2 files changed, 12 insertions(+), 14 deletions(-)

diff --git a/pxr/usd/usd/clipCache.cpp b/pxr/usd/usd/clipCache.cpp
index c582e1d8be..b8215378ed 100644
--- a/pxr/usd/usd/clipCache.cpp
+++ b/pxr/usd/usd/clipCache.cpp
@@ -218,10 +218,9 @@ Usd_ClipCache::PopulateClipsForPrim(
     const bool primHasClips = !allClips.empty();
     if (primHasClips) {
         TRACE_SCOPE("Usd_ClipCache::PopulateClipsForPrim (primHasClips)");
-        tbb::mutex::scoped_lock lock;
-        if (_concurrentPopulationContext) {
-            lock.acquire(_concurrentPopulationContext->_mutex);
-        }
+        std::unique_lock<std::mutex> lock = (_concurrentPopulationContext) ?
+            std::unique_lock<std::mutex>(_concurrentPopulationContext->_mutex) :
+            std::unique_lock<std::mutex>();
 
         // Find nearest ancestor with clips specified.
         const std::vector<Usd_ClipSetRefPtr>* ancestralClips = nullptr;
@@ -260,10 +259,10 @@ Usd_ClipCache::PopulateClipsForPrim(
 SdfLayerHandleSet
 Usd_ClipCache::GetUsedLayers() const
 {
-    tbb::mutex::scoped_lock lock;
-    if (_concurrentPopulationContext) {
-        lock.acquire(_concurrentPopulationContext->_mutex);
-    }
+    std::unique_lock<std::mutex> lock = (_concurrentPopulationContext) ?
+        std::unique_lock<std::mutex>(_concurrentPopulationContext->_mutex) :
+        std::unique_lock<std::mutex>();
+
     SdfLayerHandleSet layers;
     for (_ClipTable::iterator::value_type const &clipsListIter : _table){
         for (Usd_ClipSetRefPtr const &clipSet : clipsListIter.second){
@@ -342,10 +341,9 @@ const std::vector<Usd_ClipSetRefPtr>&
 Usd_ClipCache::GetClipsForPrim(const SdfPath& path) const
 {
     TRACE_FUNCTION();
-    tbb::mutex::scoped_lock lock;
-    if (_concurrentPopulationContext) {
-        lock.acquire(_concurrentPopulationContext->_mutex);
-    }
+    std::unique_lock<std::mutex> lock = (_concurrentPopulationContext) ?
+        std::unique_lock<std::mutex>(_concurrentPopulationContext->_mutex) :
+        std::unique_lock<std::mutex>();
     return _GetClipsForPrim_NoLock(path);
 }
 
diff --git a/pxr/usd/usd/clipCache.h b/pxr/usd/usd/clipCache.h
index 2bff0833aa..fbe2ea72dc 100644
--- a/pxr/usd/usd/clipCache.h
+++ b/pxr/usd/usd/clipCache.h
@@ -30,7 +30,7 @@
 #include "pxr/usd/usd/clipSet.h"
 #include "pxr/usd/sdf/pathTable.h"
 
-#include <tbb/mutex.h>
+#include <mutex>
 #include <vector>
 
 PXR_NAMESPACE_OPEN_SCOPE
@@ -61,7 +61,7 @@ class Usd_ClipCache
         explicit ConcurrentPopulationContext(Usd_ClipCache &cache);
         ~ConcurrentPopulationContext();
         Usd_ClipCache &_cache;
-        tbb::mutex _mutex;
+        std::mutex _mutex;
     };
 
     /// Populate the cache with clips for \p prim. Returns true if clips

From 74e0473d6426788b67c545b99812787531a03327 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:27 +0200
Subject: [PATCH 07/14] oneTBB: explicitly specify hasher

---
 pxr/usd/usd/crateFile.h | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/pxr/usd/usd/crateFile.h b/pxr/usd/usd/crateFile.h
index 67b1aa385f..38f65c6886 100644
--- a/pxr/usd/usd/crateFile.h
+++ b/pxr/usd/usd/crateFile.h
@@ -349,12 +349,15 @@ class CrateFile
                 bool operator!=(ZeroCopySource const &other) const {
                     return !(*this == other);
                 }
-                friend size_t tbb_hasher(ZeroCopySource const &z) {
-                    return TfHash::Combine(
-                        reinterpret_cast<uintptr_t>(z._addr),
-                        z._numBytes
-                    );
-                }
+
+                struct Hash {
+                    inline size_t operator()(const ZeroCopySource& z) const {
+                        return TfHash::Combine(
+                            reinterpret_cast<uintptr_t>(z._addr),
+                            z._numBytes
+                        );
+                    }
+                };
                 
                 // Return true if the refcount is nonzero.
                 bool IsInUse() const { return _refCount; }
@@ -422,7 +425,7 @@ class CrateFile
             ArchConstFileMapping _mapping;
             char const *_start;
             int64_t _length;
-            tbb::concurrent_unordered_set<ZeroCopySource> _outstandingRanges;
+            tbb::concurrent_unordered_set<ZeroCopySource, ZeroCopySource::Hash> _outstandingRanges;
         };
 
     public:

From 0e7845215d72822e6d4e69e7d302e64061340bbf Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:28 +0200
Subject: [PATCH 08/14] oneTBB: replace TBB utility functions for placement new

---
 pxr/base/trace/concurrentList.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/pxr/base/trace/concurrentList.h b/pxr/base/trace/concurrentList.h
index 0337933a31..01886a1b93 100644
--- a/pxr/base/trace/concurrentList.h
+++ b/pxr/base/trace/concurrentList.h
@@ -111,7 +111,7 @@ class TraceConcurrentList {
         while (curNode) {
             Node* nodeToDelete = curNode;
             curNode = curNode->next;
-            _alloc.destroy(nodeToDelete);
+            nodeToDelete->~Node();
             _alloc.deallocate(nodeToDelete, 1);
         }
     }
@@ -130,7 +130,7 @@ class TraceConcurrentList {
     /// the newly created item.
     iterator Insert() {
         Node* newNode = _alloc.allocate(1);
-        _alloc.construct(newNode);
+        new(newNode) Node();
 
         // Add the node to the linked list in an atomic manner.
         do {

From b2dc9d7e43fb24d0ebc075e1f09fb9958c19b106 Mon Sep 17 00:00:00 2001
From: Alex Fuller <boberfly@gmail.com>
Date: Wed, 17 May 2023 16:27:47 +0200
Subject: [PATCH 09/14] oneTBB: tbb::atomic to std::atomic in usdImagining

---
 pxr/usdImaging/plugin/usdShaders/pch.h        |  1 -
 pxr/usdImaging/usdAppUtils/pch.h              |  1 -
 pxr/usdImaging/usdImaging/pch.h               |  1 -
 .../usdImaging/resolvedAttributeCache.h       | 24 +++++++++++++++----
 pxr/usdImaging/usdImagingGL/pch.h             |  1 -
 pxr/usdImaging/usdProcImaging/pch.h           |  1 -
 pxr/usdImaging/usdRiPxrImaging/pch.h          |  1 -
 pxr/usdImaging/usdSkelImaging/pch.h           |  1 -
 pxr/usdImaging/usdVolImaging/pch.h            |  1 -
 pxr/usdImaging/usdviewq/pch.h                 |  1 -
 10 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/pxr/usdImaging/plugin/usdShaders/pch.h b/pxr/usdImaging/plugin/usdShaders/pch.h
index 2037e25b8b..c5836624f4 100644
--- a/pxr/usdImaging/plugin/usdShaders/pch.h
+++ b/pxr/usdImaging/plugin/usdShaders/pch.h
@@ -160,7 +160,6 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usdImaging/usdAppUtils/pch.h b/pxr/usdImaging/usdAppUtils/pch.h
index 70b9602d5e..f403f45009 100644
--- a/pxr/usdImaging/usdAppUtils/pch.h
+++ b/pxr/usdImaging/usdAppUtils/pch.h
@@ -173,7 +173,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git a/pxr/usdImaging/usdImaging/pch.h b/pxr/usdImaging/usdImaging/pch.h
index 35ea5620ec..0419c53efa 100644
--- a/pxr/usdImaging/usdImaging/pch.h
+++ b/pxr/usdImaging/usdImaging/pch.h
@@ -173,7 +173,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usdImaging/usdImaging/resolvedAttributeCache.h b/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
index 3e75f6c63d..f3b4c1c872 100644
--- a/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
+++ b/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
@@ -283,22 +283,36 @@ class UsdImaging_ResolvedAttributeCache
     // non-time varying data, entries may exist in the cache with invalid
     // values. The version is used to determine validity.
     struct _Entry {
-        _Entry()
+        _Entry() noexcept
             : value(Strategy::MakeDefault())
             , version(_GetInitialEntryVersion()) 
         { }
 
         _Entry(const query_type & query_,
                const value_type& value_,
-               unsigned version_)
+               unsigned version_) noexcept
             : query(query_)
             , value(value_)
             , version(version_)
         { }
 
+        _Entry(const _Entry &other) noexcept
+            : query(other.query)
+            , value(other.value)
+        {
+            version.store(other.version.load());
+        }
+
+        _Entry(_Entry &&other) noexcept
+            : query(std::move(other.query))
+            , value(std::move(other.value))
+        {
+            version.store(other.version.load());
+        }
+
         query_type query;
         value_type value;
-        tbb::atomic<unsigned> version;
+        std::atomic<unsigned> version;
     };
 
     // Returns the version number for a valid cache entry
@@ -338,7 +352,7 @@ class UsdImaging_ResolvedAttributeCache
 
     // A serial number indicating the valid state of entries in the cache. When
     // an entry has an equal or greater value, the entry is valid.
-    tbb::atomic<unsigned> _cacheVersion;
+    std::atomic<unsigned> _cacheVersion;
 
     // Value overrides for a set of descendents.
     ValueOverridesMap _valueOverrides;
@@ -357,7 +371,7 @@ UsdImaging_ResolvedAttributeCache<Strategy,ImplData>::_SetCacheEntryForPrim(
     // Note: _cacheVersion is not allowed to change during cache access.
     unsigned v = entry->version;
     if (v < _cacheVersion 
-        && entry->version.compare_and_swap(_cacheVersion, v) == v)
+        && entry->version.compare_exchange_strong(v, _cacheVersion.load()))
     {
         entry->value = value;
         entry->version = _GetValidVersion();
diff --git a/pxr/usdImaging/usdImagingGL/pch.h b/pxr/usdImaging/usdImagingGL/pch.h
index b9dfa7e416..78b92909e3 100644
--- a/pxr/usdImaging/usdImagingGL/pch.h
+++ b/pxr/usdImaging/usdImagingGL/pch.h
@@ -186,7 +186,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git a/pxr/usdImaging/usdProcImaging/pch.h b/pxr/usdImaging/usdProcImaging/pch.h
index 32358e284a..95900985f9 100644
--- a/pxr/usdImaging/usdProcImaging/pch.h
+++ b/pxr/usdImaging/usdProcImaging/pch.h
@@ -161,7 +161,6 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usdImaging/usdRiPxrImaging/pch.h b/pxr/usdImaging/usdRiPxrImaging/pch.h
index 6ad2d403bb..09a7a06cc8 100644
--- a/pxr/usdImaging/usdRiPxrImaging/pch.h
+++ b/pxr/usdImaging/usdRiPxrImaging/pch.h
@@ -169,7 +169,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git a/pxr/usdImaging/usdSkelImaging/pch.h b/pxr/usdImaging/usdSkelImaging/pch.h
index 69caaac23b..7086fc4124 100644
--- a/pxr/usdImaging/usdSkelImaging/pch.h
+++ b/pxr/usdImaging/usdSkelImaging/pch.h
@@ -169,7 +169,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git a/pxr/usdImaging/usdVolImaging/pch.h b/pxr/usdImaging/usdVolImaging/pch.h
index 0fd54d571b..b286bc7592 100644
--- a/pxr/usdImaging/usdVolImaging/pch.h
+++ b/pxr/usdImaging/usdVolImaging/pch.h
@@ -167,7 +167,6 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git a/pxr/usdImaging/usdviewq/pch.h b/pxr/usdImaging/usdviewq/pch.h
index 2b6f4d7826..d14b76bf75 100644
--- a/pxr/usdImaging/usdviewq/pch.h
+++ b/pxr/usdImaging/usdviewq/pch.h
@@ -164,7 +164,6 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
-#include <tbb/atomic.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>

From 3e27a5ae5c52ae861c43b1eca8ac6777d1287296 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Fri, 23 Jun 2023 18:00:18 +0200
Subject: [PATCH 10/14] oneTBB: use non-const iterator for
 tbb::concurrent_unordered_map

Older TBB versions incorrectly allowed these to be const.
---
 pxr/imaging/hd/dependencyForwardingSceneIndex.cpp  | 2 +-
 pxr/usdImaging/usdImaging/resolvedAttributeCache.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/pxr/imaging/hd/dependencyForwardingSceneIndex.cpp b/pxr/imaging/hd/dependencyForwardingSceneIndex.cpp
index 0dcdcac98e..e22d89ba3a 100644
--- a/pxr/imaging/hd/dependencyForwardingSceneIndex.cpp
+++ b/pxr/imaging/hd/dependencyForwardingSceneIndex.cpp
@@ -211,7 +211,7 @@ HdDependencyForwardingSceneIndex::_PrimDirtied(
 void 
 HdDependencyForwardingSceneIndex::_ClearDependencies(const SdfPath &primPath)
 {
-    _AffectedPrimToDependsOnPathsEntryMap::const_iterator it =
+    _AffectedPrimToDependsOnPathsEntryMap::iterator it =
         _affectedPrimToDependsOnPathsMap.find(primPath);
     if (it == _affectedPrimToDependsOnPathsMap.end()) {
         return;
diff --git a/pxr/usdImaging/usdImaging/resolvedAttributeCache.h b/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
index f3b4c1c872..c645579cc9 100644
--- a/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
+++ b/pxr/usdImaging/usdImaging/resolvedAttributeCache.h
@@ -391,7 +391,7 @@ typename UsdImaging_ResolvedAttributeCache<Strategy, ImplData>::_Entry*
 UsdImaging_ResolvedAttributeCache<Strategy, ImplData>::_GetCacheEntryForPrim(
     const UsdPrim &prim) const
 {
-    typename _CacheMap::const_iterator it = _cache.find(prim);
+    typename _CacheMap::iterator it = _cache.find(prim);
     if (it != _cache.end()) {
         return &it->second;
     }

From 7f0a56835134f21e8b76ce05c23e0ef545c2f5f6 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:30 +0200
Subject: [PATCH 11/14] oneTBB: support thread limits

This now modifies global_control::max_allowed_parallelism instead of
task_scheduler_init, which leads to changes in API behavior.

* Increasing number of threads beyond the number of cores now additionally
  requires creating a task_arena with higher max concurrency.
* All application threads are affected when setting the concurrency limit,
  not just the current thread.
* The winning call to set the number of threads may now be different due to
  global_control always changing the number, while with task_scheduler_init
  the first created instance determines the number of threads.

Also, in the existing implementation task_scheduler_init is never freed, not on
shutdown or on changing the concurrently limit back to the default. This seems
unideal, but the new code does the same to keep the same behavior.
---
 .../work/testenv/testWorkThreadLimits.cpp     | 59 ++++++++++++++-----
 pxr/base/work/threadLimits.cpp                | 43 ++++++++++++--
 2 files changed, 83 insertions(+), 19 deletions(-)

diff --git a/pxr/base/work/testenv/testWorkThreadLimits.cpp b/pxr/base/work/testenv/testWorkThreadLimits.cpp
index 414bba2c02..4c833199ab 100644
--- a/pxr/base/work/testenv/testWorkThreadLimits.cpp
+++ b/pxr/base/work/testenv/testWorkThreadLimits.cpp
@@ -38,6 +38,10 @@
 #include <set>
 #include <thread>
 
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+#include <tbb/global_control.h>
+#endif
+
 using namespace std::placeholders;
 
 PXR_NAMESPACE_USING_DIRECTIVE
@@ -56,16 +60,41 @@ _CountThreads(size_t begin, size_t end)
     _uniqueThreads->insert(std::this_thread::get_id());
 }
 
+static unsigned
+_GetConcurrencyLimit()
+{
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    // For oneTBB, get limit in an arena with max concurrency as
+    // WorkSetConcurrencyLimit by itself no longer increases the concurrency
+    // beyond the number of cores by itself.
+    unsigned limit;
+    tbb::task_arena arena(tbb::global_control::active_value(tbb::global_control::max_allowed_parallelism));
+    arena.execute([&]() {
+        limit = WorkGetConcurrencyLimit();
+    });
+    return limit;
+#else
+  return WorkGetConcurrencyLimit();
+#endif
+}
+
 static size_t
 _ExpectedLimit(const int envVal, const size_t n)
 {
     // If envVal is non-zero, it wins over n!
     // envVal may also be a negative number, which means all but that many
     // cores.
-    return envVal ? 
+    const size_t val = envVal ?
         (envVal < 0 ?
             std::max<int>(1, envVal+WorkGetPhysicalConcurrencyLimit()) : envVal)
         : n;
+
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    // oneTBB has an internal limit of 256 + 1 threads.
+    return std::min<size_t>(val, 257);
+#else
+    return val;
+#endif
 }
 
 static void
@@ -101,41 +130,41 @@ _TestArguments(const int envVal)
     // Set to maximum concurrency, which should remain within envVal.
     const int numCores = WorkGetPhysicalConcurrencyLimit();
     WorkSetConcurrencyLimitArgument(numCores);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, numCores));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, numCores));
 
     // n = 0, means "no change"
     WorkSetConcurrencyLimitArgument(0);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, numCores));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, numCores));
 
     // n = 1 means no threading
     WorkSetConcurrencyLimitArgument(1);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
 
     // n = 3 means 3
     WorkSetConcurrencyLimitArgument(3);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, 3));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, 3));
 
     // n = 1000 means 1000
     WorkSetConcurrencyLimitArgument(1000);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, 1000));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, 1000));
 
     // n = -1 means numCores - 1, with a minimum of 1
     WorkSetConcurrencyLimitArgument(-1);
-    TF_AXIOM(WorkGetConcurrencyLimit() == 
+    TF_AXIOM(_GetConcurrencyLimit() ==
              _ExpectedLimit(envVal, std::max(1, numCores-1)));
 
     // n = -3 means numCores - 3, with a minimum of 1
     WorkSetConcurrencyLimitArgument(-3);
-    TF_AXIOM(WorkGetConcurrencyLimit() == 
+    TF_AXIOM(_GetConcurrencyLimit() ==
              _ExpectedLimit(envVal, std::max(1, numCores-3)));
 
     // n = -numCores means 1 (no threading)
     WorkSetConcurrencyLimitArgument(-numCores);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
 
     // n = -numCores*10 means 1 (no threading)
     WorkSetConcurrencyLimitArgument(-numCores*10);
-    TF_AXIOM(WorkGetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
+    TF_AXIOM(_GetConcurrencyLimit() == _ExpectedLimit(envVal, 1));
 }
 
 struct _RawTBBCounter
@@ -218,35 +247,35 @@ main(int argc, char **argv)
     // Test with full concurrency.
     std::cout << "Testing full concurrency...\n";
     WorkSetMaximumConcurrencyLimit();
-    TF_AXIOM(WorkGetConcurrencyLimit() == 
+    TF_AXIOM(_GetConcurrencyLimit() ==
         _ExpectedLimit(envVal, WorkGetPhysicalConcurrencyLimit()));
     _TestThreadLimit(envVal, WorkGetPhysicalConcurrencyLimit());
 
     // Test with no concurrency.
     std::cout << "Testing turning off concurrency...\n";
     WorkSetConcurrencyLimit(1);
-    TF_AXIOM(WorkGetConcurrencyLimit() == 
+    TF_AXIOM(_GetConcurrencyLimit() ==
         _ExpectedLimit(envVal, 1));
     _TestThreadLimit(envVal, 1);
 
     // Test with 2 threads.
     std::cout << "Testing with 2 threads...\n";
     WorkSetConcurrencyLimit(2);
-    TF_AXIOM(WorkGetConcurrencyLimit() == 
+    TF_AXIOM(_GetConcurrencyLimit() ==
         _ExpectedLimit(envVal, 2));
     _TestThreadLimit(envVal, 2);
 
     // Test with 4 threads.
     std::cout << "Testing with 4 threads...\n";
     WorkSetConcurrencyLimit(4);
-    TF_AXIOM(WorkGetConcurrencyLimit() ==
+    TF_AXIOM(_GetConcurrencyLimit() ==
         _ExpectedLimit(envVal, 4));
     _TestThreadLimit(envVal, 4);
 
     // Test with 1000 threads.
     std::cout << "Testing with 1000 threads...\n";
     WorkSetConcurrencyLimit(1000);
-    TF_AXIOM(WorkGetConcurrencyLimit() ==
+    TF_AXIOM(_GetConcurrencyLimit() ==
         _ExpectedLimit(envVal, 1000));
     _TestThreadLimit(envVal, 1000);
 
diff --git a/pxr/base/work/threadLimits.cpp b/pxr/base/work/threadLimits.cpp
index bc629b8124..ad6bae8aea 100644
--- a/pxr/base/work/threadLimits.cpp
+++ b/pxr/base/work/threadLimits.cpp
@@ -29,9 +29,18 @@
 
 #include "pxr/base/tf/envSetting.h"
 
-#include <tbb/task_scheduler_init.h>
+// Blocked range is not used in this file, but this header happens to pull in
+// the TBB version header in a way that works in all TBB versions.
+#include <tbb/blocked_range.h>
 #include <tbb/task_arena.h>
 
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+#include <tbb/global_control.h>
+#include <tbb/info.h>
+#else
+#include <tbb/task_scheduler_init.h>
+#endif
+
 #include <algorithm>
 #include <atomic>
 
@@ -58,16 +67,25 @@ TF_DEFINE_ENV_SETTING(
 
 PXR_NAMESPACE_OPEN_SCOPE
 
-// We create a task_scheduler_init instance at static initialization time if
-// PXR_WORK_THREAD_LIMIT is set to a nonzero value.  Otherwise this stays NULL.
-static tbb::task_scheduler_init *_tbbTaskSchedInit;
+// We create a global_control or task_scheduler_init instance at static
+// initialization time if PXR_WORK_THREAD_LIMIT is set to a nonzero value.
+// Otherwise this stays NULL.
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+static tbb::global_control *_tbbGlobalControl = nullptr;
+#else
+static tbb::task_scheduler_init *_tbbTaskSchedInit = nullptr;
+#endif
 
 unsigned
 WorkGetPhysicalConcurrencyLimit()
 {
     // Use TBB here, since it pays attention to the affinity mask on Linux and
     // Windows.
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    return tbb::info::default_concurrency();
+#else
     return tbb::task_scheduler_init::default_num_threads();
+#endif
 }
 
 // This function always returns an actual thread count >= 1.
@@ -123,7 +141,11 @@ Work_InitializeThreading()
     // previously initialized by the hosting environment (e.g. if we are running
     // as a plugin to another application.)
     if (settingVal) {
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+        _tbbGlobalControl = new tbb::global_control(tbb::global_control::max_allowed_parallelism, threadLimit);
+#else
         _tbbTaskSchedInit = new tbb::task_scheduler_init(threadLimit);
+#endif
     }
 }
 static int _forceInitialization = (Work_InitializeThreading(), 0);
@@ -153,6 +175,11 @@ WorkSetConcurrencyLimit(unsigned n)
         threadLimit = WorkGetConcurrencyLimit();
     }
 
+
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    delete _tbbGlobalControl;
+    _tbbGlobalControl = new tbb::global_control(tbb::global_control::max_allowed_parallelism, threadLimit);
+#else
     // Note that we need to do some performance testing and decide if it's
     // better here to simply delete the task_scheduler_init object instead
     // of re-initializing it.  If we decide that it's better to re-initialize
@@ -168,6 +195,7 @@ WorkSetConcurrencyLimit(unsigned n)
     } else {
         _tbbTaskSchedInit = new tbb::task_scheduler_init(threadLimit);
     }
+#endif
 }
 
 void 
@@ -185,7 +213,14 @@ WorkSetConcurrencyLimitArgument(int n)
 unsigned
 WorkGetConcurrencyLimit()
 {
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    // The effective concurrency requires taking into account both the
+    // task_arena and internal thread pool size set by global_control.
+    // https://github.com/oneapi-src/oneTBB/issues/405
+    return std::min<unsigned>(tbb::global_control::active_value(tbb::global_control::max_allowed_parallelism), tbb::this_task_arena::max_concurrency());
+#else
     return tbb::this_task_arena::max_concurrency();
+#endif
 }
 
 bool

From f91dc6d3798a080335a869a8fe1077264e67e3e6 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:31 +0200
Subject: [PATCH 12/14] oneTBB: support work dispatcher

To make concurrent wait thread safe this is accessing the internals of TBB,
since the TBB wait implementation has a comment saying it is not thread safe.
---
 pxr/base/work/dispatcher.cpp | 23 ++++++++++++--
 pxr/base/work/dispatcher.h   | 61 +++++++++++++++++++++++++++++++++---
 2 files changed, 77 insertions(+), 7 deletions(-)

diff --git a/pxr/base/work/dispatcher.cpp b/pxr/base/work/dispatcher.cpp
index adba7dff31..66ca5181ae 100644
--- a/pxr/base/work/dispatcher.cpp
+++ b/pxr/base/work/dispatcher.cpp
@@ -32,27 +32,42 @@ WorkDispatcher::WorkDispatcher()
         tbb::task_group_context::isolated,
         tbb::task_group_context::concurrent_wait | 
         tbb::task_group_context::default_traits)
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+      , _taskGroup(_context)
+#endif
 {
     _waitCleanupFlag.clear();
-    
+
+#if TBB_INTERFACE_VERSION_MAJOR < 12
     // The concurrent_wait flag used with the task_group_context ensures
     // the ref count will remain at 1 after all predecessor tasks are
     // completed, so we don't need to keep resetting it in Wait().
     _rootTask = new(tbb::task::allocate_root(_context)) tbb::empty_task;
     _rootTask->set_ref_count(1);
+#endif
 }
 
-WorkDispatcher::~WorkDispatcher()
+WorkDispatcher::~WorkDispatcher() noexcept
 {
     Wait();
+
+#if TBB_INTERFACE_VERSION_MAJOR < 12
     tbb::task::destroy(*_rootTask);
+#endif
 }
 
 void
 WorkDispatcher::Wait()
 {
     // Wait for tasks to complete.
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    // The native task_group::wait() has a comment saying its call to the
+    // context reset method is not thread safe. So we bypass that implementation
+    // and do our own synchronization to ensure it is called once.
+    tbb::detail::d1::wait(_taskGroup.get_internal_wait_context(), _context);
+#else
     _rootTask->wait_for_all();
+#endif
 
     // If we take the flag from false -> true, we do the cleanup.
     if (_waitCleanupFlag.test_and_set() == false) {
@@ -73,7 +88,11 @@ WorkDispatcher::Wait()
 void
 WorkDispatcher::Cancel()
 {
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    _taskGroup.cancel();
+#else
     _context.cancel_group_execution();
+#endif
 }
 
 /* static */
diff --git a/pxr/base/work/dispatcher.h b/pxr/base/work/dispatcher.h
index 2c499d6ab5..62eb7132d1 100644
--- a/pxr/base/work/dispatcher.h
+++ b/pxr/base/work/dispatcher.h
@@ -33,8 +33,15 @@
 #include "pxr/base/tf/errorMark.h"
 #include "pxr/base/tf/errorTransport.h"
 
+// Blocked range is not used in this file, but this header happens to pull in
+// the TBB version header in a way that works in all TBB versions.
+#include <tbb/blocked_range.h>
 #include <tbb/concurrent_vector.h>
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+#include <tbb/task_group.h>
+#else
 #include <tbb/task.h>
+#endif
 
 #include <functional>
 #include <type_traits>
@@ -79,7 +86,7 @@ class WorkDispatcher
     WORK_API WorkDispatcher();
 
     /// Wait() for any pending tasks to complete, then destroy the dispatcher.
-    WORK_API ~WorkDispatcher();
+    WORK_API ~WorkDispatcher() noexcept; // noexcept needed for tbb::task_group
 
     WorkDispatcher(WorkDispatcher const &) = delete;
     WorkDispatcher &operator=(WorkDispatcher const &) = delete;
@@ -103,7 +110,11 @@ class WorkDispatcher
 
     template <class Callable>
     inline void Run(Callable &&c) {
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+        _taskGroup.run(std::move(_InvokerTask<typename std::remove_reference<Callable>::type>(std::move(c), &_errors)));
+#else
         _rootTask->spawn(_MakeInvokerTask(std::forward<Callable>(c)));
+#endif
     }
 
     template <class Callable, class A0, class ... Args>
@@ -136,12 +147,38 @@ class WorkDispatcher
     // Function invoker helper that wraps the invocation with an ErrorMark so we
     // can transmit errors that occur back to the thread that Wait() s for tasks
     // to complete.
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
     template <class Fn>
-    struct _InvokerTask : public tbb::task {
+    struct _InvokerTask {
         explicit _InvokerTask(Fn &&fn, _ErrorTransports *err) 
-            : _fn(std::move(fn)), _errors(err) {}
+            : _fn(std::make_unique<Fn>(std::move(fn))), _errors(err) {}
 
         explicit _InvokerTask(Fn const &fn, _ErrorTransports *err) 
+            : _fn(std::make_unique<Fn>(std::move(fn))), _errors(err) {}
+
+        // Ensure only moves happen, no copies or assignments.
+        _InvokerTask(_InvokerTask &&other) = default;
+        _InvokerTask(const _InvokerTask &other) = delete;
+        _InvokerTask &operator=(const _InvokerTask &other) = delete;
+        _InvokerTask &operator=(_InvokerTask &&other) = delete;
+
+        void operator()() const {
+            TfErrorMark m;
+            (*_fn)();
+            if (!m.IsClean())
+                WorkDispatcher::_TransportErrors(m, _errors);
+        }
+    private:
+        std::unique_ptr<Fn> _fn;
+        _ErrorTransports *_errors;
+    };
+#else
+    template <class Fn>
+    struct _InvokerTask : public tbb::task {
+        explicit _InvokerTask(Fn &&fn, _ErrorTransports *err)
+            : _fn(std::move(fn)), _errors(err) {}
+
+        explicit _InvokerTask(Fn const &fn, _ErrorTransports *err)
             : _fn(fn), _errors(err) {}
 
         virtual tbb::task* execute() {
@@ -164,16 +201,30 @@ class WorkDispatcher
             _InvokerTask<typename std::remove_reference<Fn>::type>(
                 std::forward<Fn>(fn), &_errors);
     }
+#endif
 
     // Helper function that removes errors from \p m and stores them in a new
     // entry in \p errors.
     WORK_API static void
     _TransportErrors(const TfErrorMark &m, _ErrorTransports *errors);
 
-    // Task group context and associated root task that allows us to cancel
-    // tasks invoked directly by this dispatcher.
+    // Task group context to run tasks in.
     tbb::task_group_context _context;
+#if TBB_INTERFACE_VERSION_MAJOR >= 12
+    // Custom task group that lets us implement thread safe concurrent wait.
+    class _TaskGroup : public tbb::task_group {
+    public:
+        _TaskGroup(tbb::task_group_context& ctx) : tbb::task_group(ctx) {}
+        tbb::detail::d1::wait_context& get_internal_wait_context() {
+            return m_wait_ctx;
+        }
+    };
+
+    _TaskGroup _taskGroup;
+#else
+    // Root task that allows us to cancel tasks invoked directly by this dispatcher.
     tbb::empty_task* _rootTask;
+#endif
 
     // The error transports we use to transmit errors in other threads back to
     // this thread.

From 6d8b2c00973101d947477bb2a9239d9567a2f5a4 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Mon, 2 Oct 2023 13:51:45 +0200
Subject: [PATCH 13/14] Fix missing include, that previously came in indirectly

---
 pxr/base/work/testenv/testWorkLoops.cpp  | 1 +
 pxr/base/work/testenv/testWorkReduce.cpp | 1 +
 2 files changed, 2 insertions(+)

diff --git a/pxr/base/work/testenv/testWorkLoops.cpp b/pxr/base/work/testenv/testWorkLoops.cpp
index e349218787..5fcdbf5f4a 100644
--- a/pxr/base/work/testenv/testWorkLoops.cpp
+++ b/pxr/base/work/testenv/testWorkLoops.cpp
@@ -35,6 +35,7 @@
 #include <functional>
 
 #include <cstdio>
+#include <cstring>
 #include <numeric>
 #include <iostream>
 #include <vector>
diff --git a/pxr/base/work/testenv/testWorkReduce.cpp b/pxr/base/work/testenv/testWorkReduce.cpp
index 10f94e4806..d4a6ccc14d 100644
--- a/pxr/base/work/testenv/testWorkReduce.cpp
+++ b/pxr/base/work/testenv/testWorkReduce.cpp
@@ -35,6 +35,7 @@
 #include <functional>
 
 #include <cstdio>
+#include <cstring>
 #include <iostream>
 #include <vector>
 

From d1b193e2bf2d05b16d5d15d32994392a2205f911 Mon Sep 17 00:00:00 2001
From: Brecht Van Lommel <brecht@blender.org>
Date: Thu, 18 May 2023 00:51:32 +0200
Subject: [PATCH 14/14] Add --onetbb option to build_usd.py, to build with TBB
 2021

And update FindTBB to support it. This also changes OpenVDB 7 to 10 when
using oneTBB since earlier versions do not support it.
---
 build_scripts/build_usd.py  | 47 +++++++++++++++++++++++++++----------
 cmake/modules/FindTBB.cmake | 20 ++++++++++++----
 2 files changed, 50 insertions(+), 17 deletions(-)

diff --git a/build_scripts/build_usd.py b/build_scripts/build_usd.py
index 14e2c7a507..c8418bba62 100644
--- a/build_scripts/build_usd.py
+++ b/build_scripts/build_usd.py
@@ -939,13 +939,19 @@ def InstallBoost(context, force, buildArgs):
 else:
     TBB_URL = "https://github.com/oneapi-src/oneTBB/archive/refs/tags/v2020.3.zip"
 
+TBB_2021_URL = "https://github.com/oneapi-src/oneTBB/archive/refs/tags/v2021.9.0.zip"
+
 def InstallTBB(context, force, buildArgs):
-    if Windows():
-        InstallTBB_Windows(context, force, buildArgs)
-    elif MacOS():
-        InstallTBB_MacOS(context, force, buildArgs)
+    if context.tbbVersion == "2021":
+        with CurrentWorkingDirectory(DownloadURL(TBB_2021_URL, context, force)):
+            RunCMake(context, force, buildArgs)
     else:
-        InstallTBB_Linux(context, force, buildArgs)
+        if Windows():
+            InstallTBB_Windows(context, force, buildArgs)
+        elif MacOS():
+            InstallTBB_MacOS(context, force, buildArgs)
+        else:
+            InstallTBB_Linux(context, force, buildArgs)
 
 def InstallTBB_Windows(context, force, buildArgs):
     with CurrentWorkingDirectory(DownloadURL(TBB_URL, context, force, 
@@ -1196,17 +1202,20 @@ def InstallBLOSC(context, force, buildArgs):
 # OpenVDB
 
 OPENVDB_URL = "https://github.com/AcademySoftwareFoundation/openvdb/archive/refs/tags/v9.1.0.zip"
-
-# OpenVDB v9.1.0 requires TBB 2019.0 or above, but this script installs
-# TBB 2018 on macOS Intel systems for reasons documented above. So we
-# keep OpenVDB at the version specified for the VFX Reference Platform
-# CY2021, which is the last version that supported 2018.
-OPENVDB_INTEL_URL = "https://github.com/AcademySoftwareFoundation/openvdb/archive/refs/tags/v8.2.0.zip"
+OPENVDB_8_URL = "https://github.com/AcademySoftwareFoundation/openvdb/archive/refs/tags/v8.2.0.zip"
+OPENVDB_10_URL = "https://github.com/AcademySoftwareFoundation/openvdb/archive/refs/tags/v10.0.1.zip"
 
 def InstallOpenVDB(context, force, buildArgs):
     openvdb_url = OPENVDB_URL
-    if MacOS() and not apple_utils.IsTargetArm(context):
-        openvdb_url = OPENVDB_INTEL_URL
+    # OpenVDB 10 is the first release to support oneTBB.
+    if context.tbbVersion == "2021":
+        openvdb_url = OPENVDB_10_URL
+    # OpenVDB v9.1.0 requires TBB 2019.0 or above, but this script installs
+    # TBB 2018 on macOS Intel systems for reasons documented above. So we
+    # keep OpenVDB at the version specified for the VFX Reference Platform
+    # CY2021, which is the last version that supported 2018.
+    elif MacOS() and not apple_utils.IsTargetArm(context):
+            openvdb_url = OPENVDB_8_URL
 
     with CurrentWorkingDirectory(DownloadURL(openvdb_url, context, force)):
         extraArgs = [
@@ -1930,6 +1939,13 @@ def InstallUSD(context, force, buildArgs):
                       action="store_false",
                       help="Disable OpenVDB support in imaging (default)")
 subgroup = group.add_mutually_exclusive_group()
+subgroup.add_argument("--onetbb", dest="enable_onetbb", action="store_true", 
+                      default=False, 
+                      help="Use new oneAPI TBB version")
+subgroup.add_argument("--no-onetbb", dest="enable_onetbb", 
+                      action="store_false",
+                      help="Use old TBB version (default)")
+subgroup = group.add_mutually_exclusive_group()
 subgroup.add_argument("--usdview", dest="build_usdview",
                       action="store_true", default=True,
                       help="Build usdview (default)")
@@ -2102,6 +2118,9 @@ def __init__(self, args):
         self.buildTutorials = args.build_tutorials
         self.buildTools = args.build_tools
 
+        # - TBB
+        self.tbbVersion = "2021" if args.enable_onetbb else "2019"
+
         # - Imaging
         self.buildImaging = (args.build_imaging == IMAGING or
                              args.build_imaging == USD_IMAGING)
@@ -2366,6 +2385,7 @@ def _JoinVersion(v):
     Python support              {buildPython}
       Python Debug:             {debugPython}
       Python docs:              {buildPythonDocs}
+    TBB version:                {tbbVersion}
     Documentation               {buildDocs}
     Tests                       {buildTests}
     Examples                    {buildExamples}
@@ -2427,6 +2447,7 @@ def FormatBuildArguments(buildArgs):
     buildPython=("On" if context.buildPython else "Off"),
     debugPython=("On" if context.debugPython else "Off"),
     buildPythonDocs=("On" if context.buildPythonDocs else "Off"),
+    tbbVersion=context.tbbVersion,
     buildDocs=("On" if context.buildDocs else "Off"),
     buildTests=("On" if context.buildTests else "Off"),
     buildExamples=("On" if context.buildExamples else "Off"),
diff --git a/cmake/modules/FindTBB.cmake b/cmake/modules/FindTBB.cmake
index 9bf69a0229..b00da7fb48 100644
--- a/cmake/modules/FindTBB.cmake
+++ b/cmake/modules/FindTBB.cmake
@@ -197,7 +197,12 @@ if(NOT TBB_FOUND)
   ##################################
 
   if(TBB_INCLUDE_DIRS)
-    file(READ "${TBB_INCLUDE_DIRS}/tbb/tbb_stddef.h" _tbb_version_file)
+    # Use new oneTBB version header if it exists.
+    if(EXISTS "${TBB_INCLUDE_DIRS}/oneapi/tbb/version.h")
+      file(READ "${TBB_INCLUDE_DIRS}/oneapi/tbb/version.h" _tbb_version_file)
+    else()
+      file(READ "${TBB_INCLUDE_DIRS}/tbb/tbb_stddef.h" _tbb_version_file)
+    endif()
     string(REGEX REPLACE ".*#define TBB_VERSION_MAJOR ([0-9]+).*" "\\1"
         TBB_VERSION_MAJOR "${_tbb_version_file}")
     string(REGEX REPLACE ".*#define TBB_VERSION_MINOR ([0-9]+).*" "\\1"
@@ -211,15 +216,22 @@ if(NOT TBB_FOUND)
   # Find TBB components
   ##################################
 
+  # oneTBB on Windows has interface version in the name.
+  if(WIN32 AND TBB_INTERFACE_VERSION GREATER_EQUAL 12000)
+    set(_tbb_library_name tbb12)
+  else()
+    set(_tbb_library_name tbb)
+  endif()
+
   if(TBB_VERSION VERSION_LESS 4.3)
-    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc tbb)
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc ${_tbb_library_name})
   else()
-    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc_proxy tbbmalloc tbb)
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc_proxy tbbmalloc ${_tbb_library_name})
   endif()
 
   # Find each component
   foreach(_comp ${TBB_SEARCH_COMPOMPONENTS})
-    if(";${TBB_FIND_COMPONENTS};tbb;" MATCHES ";${_comp};")
+    if(";${TBB_FIND_COMPONENTS};" MATCHES ";${_comp};")
 
       # Search for the libraries
       find_library(TBB_${_comp}_LIBRARY_RELEASE ${_comp}
