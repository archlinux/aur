
# https://github.com/chromium/chromium/commit/45a8ef1c39114b2f3d048635a7dbe3b25c24c9e9
Eliminate GLImage

---
diff --git a/gpu/command_buffer/service/abstract_texture.h b/gpu/command_buffer/service/abstract_texture.h
index ad70c4e..9e97de2 100644
--- a/gpu/command_buffer/service/abstract_texture.h
+++ b/gpu/command_buffer/service/abstract_texture.h
@@ -16,10 +16,11 @@ typedef int GLsizei;
 typedef int GLint;
 typedef unsigned int GLuint;
 
+namespace gl {
+class GLImage;
+}  // namespace gl
+
 namespace gpu {
-
-class GLImageNativePixmap;
-
 namespace gles2 {
 
 // An AbstractTexture enables access to GL textures from the GPU process, for
@@ -63,7 +64,7 @@ class GPU_GLES2_EXPORT AbstractTexture {
   // It is not required to SetCleared() if one binds an image.
   //
   // The context must be current.
-  virtual void SetBoundImage(GLImageNativePixmap* image) = 0;
+  virtual void SetBoundImage(gl::GLImage* image) = 0;
 #endif
 
   // Marks the texture as cleared, to help prevent sending an uninitialized
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc b/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc
index 9d32c07..0b18b06 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc
@@ -274,7 +274,7 @@ TEST_P(GLES2DecoderTest, TestImageBindingForDecoderManagement) {
                                           1,                    /* depth */
                                           0,                    /* border */
                                           GL_RGBA, GL_UNSIGNED_BYTE);
-  scoped_refptr<GLImageNativePixmap> image(
+  scoped_refptr<gl::GLImage> image(
       GLImageNativePixmap::CreateForTesting(gfx::Size(256, 256)));
 
   abstract_texture->SetBoundImage(image.get());
@@ -316,7 +316,7 @@ TEST_P(GLES2DecoderTest, CreateAbstractTexture) {
   EXPECT_EQ(texture->min_filter(), static_cast<GLenum>(GL_LINEAR));
 
   // Attach an image and see if it works.
-  scoped_refptr<GLImageNativePixmap> image(
+  scoped_refptr<gl::GLImage> image(
       GLImageNativePixmap::CreateForTesting(gfx::Size()));
 
   abstract_texture->SetBoundImage(image.get());
diff --git a/gpu/command_buffer/service/passthrough_abstract_texture_impl.cc b/gpu/command_buffer/service/passthrough_abstract_texture_impl.cc
index b1c43a4..ddcd80c 100644
--- a/gpu/command_buffer/service/passthrough_abstract_texture_impl.cc
+++ b/gpu/command_buffer/service/passthrough_abstract_texture_impl.cc
@@ -48,7 +48,7 @@ void PassthroughAbstractTextureImpl::SetParameteri(GLenum pname, GLint param) {
 }
 
 #if BUILDFLAG(IS_OZONE)
-void PassthroughAbstractTextureImpl::SetBoundImage(GLImageNativePixmap* image) {
+void PassthroughAbstractTextureImpl::SetBoundImage(gl::GLImage* image) {
   if (!texture_passthrough_) {
     return;
   }
diff --git a/gpu/command_buffer/service/passthrough_abstract_texture_impl.h b/gpu/command_buffer/service/passthrough_abstract_texture_impl.h
index 94b0d1e..ed2c1cb 100644
--- a/gpu/command_buffer/service/passthrough_abstract_texture_impl.h
+++ b/gpu/command_buffer/service/passthrough_abstract_texture_impl.h
@@ -32,7 +32,7 @@ class GPU_GLES2_EXPORT PassthroughAbstractTextureImpl : public AbstractTexture {
   TextureBase* GetTextureBase() const override;
   void SetParameteri(GLenum pname, GLint param) override;
 #if BUILDFLAG(IS_OZONE)
-  void SetBoundImage(GLImageNativePixmap* image) override;
+  void SetBoundImage(gl::GLImage* image) override;
 #endif
 
   void SetCleared() override;
diff --git a/gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h b/gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h
index 264c742..cb1659a 100644
--- a/gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h
+++ b/gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h
@@ -7,10 +7,10 @@
 
 #include <stdint.h>
 
-#include "base/memory/ref_counted.h"
 #include "gpu/gpu_gles2_export.h"
 #include "ui/gfx/native_pixmap.h"
 #include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_image.h"
 
 namespace media {
 class V4L2SliceVideoDecodeAccelerator;
@@ -24,11 +24,9 @@ namespace gpu {
 
 namespace gles2 {
 class GLES2DecoderImpl;
-class GLES2DecoderPassthroughImpl;
 }
 
-class GPU_GLES2_EXPORT GLImageNativePixmap
-    : public base::RefCounted<GLImageNativePixmap> {
+class GPU_GLES2_EXPORT GLImageNativePixmap : public gl::GLImage {
  private:
   // Create an EGLImage from a given NativePixmap and bind |texture_id| to
   // |target| following by binding the image to |target|.
@@ -63,12 +61,10 @@ class GPU_GLES2_EXPORT GLImageNativePixmap
 
  private:
   friend class gles2::GLES2DecoderImpl;
-  friend class gles2::GLES2DecoderPassthroughImpl;
   friend class media::V4L2SliceVideoDecodeAccelerator;
-  friend class base::RefCounted<GLImageNativePixmap>;
 
   explicit GLImageNativePixmap(const gfx::Size& size);
-  ~GLImageNativePixmap();
+  ~GLImageNativePixmap() override;
 
   // Create a NativePixmapGLBinding from a given NativePixmap. Returns true iff
   // the binding was successfully created.
diff --git a/gpu/command_buffer/service/texture_manager.cc b/gpu/command_buffer/service/texture_manager.cc
index e5a2943..5094cdb 100644
--- a/gpu/command_buffer/service/texture_manager.cc
+++ b/gpu/command_buffer/service/texture_manager.cc
@@ -38,7 +38,7 @@
 #include "ui/gl/trace_util.h"
 
 #if BUILDFLAG(IS_OZONE)
-#include "gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h"
+#include "ui/gl/gl_image.h"
 #endif
 
 using base::trace_event::MemoryAllocatorDump;
@@ -570,7 +570,7 @@ void TexturePassthrough::MarkContextLost() {
 #if BUILDFLAG(IS_OZONE)
 void TexturePassthrough::SetLevelImage(GLenum target,
                                        GLint level,
-                                       GLImageNativePixmap* image) {
+                                       gl::GLImage* image) {
   SetLevelImageInternal(target, level, image, owned_service_id_);
 }
 #endif
@@ -624,10 +624,11 @@ bool TexturePassthrough::LevelInfoExists(GLenum target,
 }
 
 #if BUILDFLAG(IS_OZONE)
-void TexturePassthrough::SetLevelImageInternal(GLenum target,
-                                               GLint level,
-                                               GLImageNativePixmap* image,
-                                               GLuint service_id) {
+void TexturePassthrough::SetLevelImageInternal(
+    GLenum target,
+    GLint level,
+    gl::GLImage* image,
+    GLuint service_id) {
   LevelInfo* level_info = GetLevelInfo(target, level);
   level_info->image = image;
 
@@ -1886,7 +1887,7 @@ bool Texture::ClearLevel(DecoderContext* decoder, GLenum target, GLint level) {
 #if BUILDFLAG(IS_OZONE)
 void Texture::SetLevelImageInternal(GLenum target,
                                     GLint level,
-                                    GLImageNativePixmap* image,
+                                    gl::GLImage* image,
                                     ImageState state) {
   DCHECK(image ? state != ImageState::NOIMAGE : state == ImageState::NOIMAGE);
 
@@ -1907,7 +1908,7 @@ void Texture::SetLevelImageInternal(GLenum target,
 
 void Texture::SetBoundLevelImage(GLenum target,
                                  GLint level,
-                                 GLImageNativePixmap* image) {
+                                 gl::GLImage* image) {
   SetStreamTextureServiceId(0);
   SetLevelImageInternal(target, level, image, ImageState::BOUND);
 }
@@ -2576,7 +2577,7 @@ GLsizei TextureManager::ComputeMipMapCount(GLenum target,
 void TextureManager::SetBoundLevelImage(TextureRef* ref,
                                         GLenum target,
                                         GLint level,
-                                        GLImageNativePixmap* image) {
+                                        gl::GLImage* image) {
   DCHECK(ref);
   ref->texture()->SetBoundLevelImage(target, level, image);
 }
diff --git a/gpu/command_buffer/service/texture_manager.h b/gpu/command_buffer/service/texture_manager.h
index 6eb8a46..a3c219d 100644
--- a/gpu/command_buffer/service/texture_manager.h
+++ b/gpu/command_buffer/service/texture_manager.h
@@ -31,12 +31,12 @@
 #include "ui/gfx/geometry/rect.h"
 
 namespace gl {
+class GLImage;
 class ProgressReporter;
 }
 
 namespace gpu {
 class DecoderContext;
-class GLImageNativePixmap;
 class ServiceDiscardableManager;
 
 namespace gles2 {
@@ -80,7 +80,7 @@ class GPU_GLES2_EXPORT TexturePassthrough final
   void MarkContextLost();
 
 #if BUILDFLAG(IS_OZONE)
-  void SetLevelImage(GLenum target, GLint level, GLImageNativePixmap* image);
+  void SetLevelImage(GLenum target, GLint level, gl::GLImage* image);
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
@@ -107,7 +107,7 @@ class GPU_GLES2_EXPORT TexturePassthrough final
 #if BUILDFLAG(IS_OZONE)
   void SetLevelImageInternal(GLenum target,
                              GLint level,
-                             GLImageNativePixmap* image,
+                             gl::GLImage* image,
                              GLuint service_id);
 #endif
 
@@ -137,7 +137,7 @@ class GPU_GLES2_EXPORT TexturePassthrough final
     GLenum type = 0;
 
 #if BUILDFLAG(IS_OZONE)
-    scoped_refptr<GLImageNativePixmap> image;
+    scoped_refptr<gl::GLImage> image;
 #endif
   };
 
@@ -186,7 +186,7 @@ class GPU_GLES2_EXPORT Texture final : public TextureBase {
     GLenum format = 0;
     GLenum type = 0;
 #if BUILDFLAG(IS_OZONE)
-    scoped_refptr<GLImageNativePixmap> image;
+    scoped_refptr<gl::GLImage> image;
 #endif
     uint32_t estimated_size = 0;
     bool internal_workaround = false;
@@ -317,9 +317,7 @@ class GPU_GLES2_EXPORT Texture final : public TextureBase {
   // GLImage was previously set with BindToServiceId(), this will reset
   // |service_id_| back to |owned_service_id_|, removing the service id override
   // set by the BindToServiceId.
-  void SetBoundLevelImage(GLenum target,
-                          GLint level,
-                          GLImageNativePixmap* image);
+  void SetBoundLevelImage(GLenum target, GLint level, gl::GLImage* image);
 
   // Unset the image for a particular level. After this call, GetLevelImage()
   // will return nullptr.
@@ -515,7 +513,7 @@ class GPU_GLES2_EXPORT Texture final : public TextureBase {
   // Helper for Set*LevelImage.
   void SetLevelImageInternal(GLenum target,
                              GLint level,
-                             GLImageNativePixmap* image,
+                             gl::GLImage* image,
                              ImageState state);
 #endif
 
@@ -1108,7 +1106,7 @@ class GPU_GLES2_EXPORT TextureManager
   void SetBoundLevelImage(TextureRef* ref,
                           GLenum target,
                           GLint level,
-                          GLImageNativePixmap* image);
+                          gl::GLImage* image);
 
   void UnsetLevelImage(TextureRef* ref, GLenum target, GLint level);
 #endif
diff --git a/gpu/command_buffer/service/texture_manager_unittest.cc b/gpu/command_buffer/service/texture_manager_unittest.cc
index 234187b..a20f11d 100644
--- a/gpu/command_buffer/service/texture_manager_unittest.cc
+++ b/gpu/command_buffer/service/texture_manager_unittest.cc
@@ -2047,7 +2047,7 @@ TEST_P(ProduceConsumeTextureTest, ProduceConsumeTextureWithImage) {
   Texture* texture = texture_ref_->texture();
   EXPECT_EQ(static_cast<GLenum>(target), texture->target());
 #if BUILDFLAG(IS_OZONE)
-  scoped_refptr<GLImageNativePixmap> image(
+  scoped_refptr<gl::GLImage> image(
       GLImageNativePixmap::CreateForTesting(gfx::Size()));
 #endif
   manager_->SetLevelInfo(texture_ref_.get(), target, 0, GL_RGBA, 0, 0, 1, 0,
@@ -2358,7 +2358,7 @@ TEST_F(SharedTextureTest, Images) {
   EXPECT_FALSE(ref2->texture()->HasImages());
   EXPECT_FALSE(texture_manager1_->HaveImages());
   EXPECT_FALSE(texture_manager2_->HaveImages());
-  scoped_refptr<GLImageNativePixmap> image1(
+  scoped_refptr<gl::GLImage> image1(
       GLImageNativePixmap::CreateForTesting(gfx::Size()));
   texture_manager1_->SetBoundLevelImage(ref1.get(), GL_TEXTURE_2D, 1,
                                         image1.get());
@@ -2366,7 +2366,7 @@ TEST_F(SharedTextureTest, Images) {
   EXPECT_TRUE(ref2->texture()->HasImages());
   EXPECT_TRUE(texture_manager1_->HaveImages());
   EXPECT_TRUE(texture_manager2_->HaveImages());
-  scoped_refptr<GLImageNativePixmap> image2(
+  scoped_refptr<gl::GLImage> image2(
       GLImageNativePixmap::CreateForTesting(gfx::Size()));
   texture_manager1_->SetBoundLevelImage(ref1.get(), GL_TEXTURE_2D, 1,
                                         image2.get());
diff --git a/gpu/command_buffer/service/validating_abstract_texture_impl.cc b/gpu/command_buffer/service/validating_abstract_texture_impl.cc
index 7151e30..686450d 100644
--- a/gpu/command_buffer/service/validating_abstract_texture_impl.cc
+++ b/gpu/command_buffer/service/validating_abstract_texture_impl.cc
@@ -52,7 +52,7 @@ void ValidatingAbstractTextureImpl::SetParameteri(GLenum pname, GLint param) {
 }
 
 #if BUILDFLAG(IS_OZONE)
-void ValidatingAbstractTextureImpl::SetBoundImage(GLImageNativePixmap* image) {
+void ValidatingAbstractTextureImpl::SetBoundImage(gl::GLImage* image) {
   if (!texture_ref_) {
     return;
   }
diff --git a/gpu/command_buffer/service/validating_abstract_texture_impl.h b/gpu/command_buffer/service/validating_abstract_texture_impl.h
index 40a22dd..33a8c66 100644
--- a/gpu/command_buffer/service/validating_abstract_texture_impl.h
+++ b/gpu/command_buffer/service/validating_abstract_texture_impl.h
@@ -37,7 +37,7 @@ class GPU_GLES2_EXPORT ValidatingAbstractTextureImpl : public AbstractTexture {
   TextureBase* GetTextureBase() const override;
   void SetParameteri(GLenum pname, GLint param) override;
 #if BUILDFLAG(IS_OZONE)
-  void SetBoundImage(GLImageNativePixmap* image) override;
+  void SetBoundImage(gl::GLImage* image) override;
 #endif
 
   void SetCleared() override;
diff --git a/media/gpu/command_buffer_helper.cc b/media/gpu/command_buffer_helper.cc
index 4bea5f7..ac384f9 100644
--- a/media/gpu/command_buffer_helper.cc
+++ b/media/gpu/command_buffer_helper.cc
@@ -198,8 +198,7 @@ class CommandBufferHelperImpl
   }
 
 #if BUILDFLAG(IS_OZONE)
-  bool BindClientManagedImage(GLuint service_id,
-                              gpu::GLImageNativePixmap* image) override {
+  bool BindClientManagedImage(GLuint service_id, gl::GLImage* image) override {
     DVLOG(2) << __func__ << "(" << service_id << ")";
     DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
diff --git a/media/gpu/command_buffer_helper.h b/media/gpu/command_buffer_helper.h
index 6ef0311..a25db47 100644
--- a/media/gpu/command_buffer_helper.h
+++ b/media/gpu/command_buffer_helper.h
@@ -29,12 +29,9 @@ class TextureBase;
 
 namespace gl {
 class GLContext;
+class GLImage;
 }  // namespace gl
 
-namespace gpu {
-class GLImageNativePixmap;
-}
-
 namespace media {
 
 class PictureBufferManagerImpl;
@@ -137,7 +134,7 @@ class MEDIA_GPU_EXPORT CommandBufferHelper
   //
   // BindTexImage() will *not* be called when the texture is used.
   virtual bool BindClientManagedImage(GLuint service_id,
-                                      gpu::GLImageNativePixmap* image) = 0;
+                                      gl::GLImage* image) = 0;
 #endif
 
   // Add a callback to be called when our stub is destroyed. This callback
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.h b/media/gpu/gpu_video_decode_accelerator_factory.h
index cdcb782..521e770 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.h
+++ b/media/gpu/gpu_video_decode_accelerator_factory.h
@@ -21,10 +21,10 @@
 
 namespace gl {
 class GLContext;
+class GLImage;
 }
 
 namespace gpu {
-class GLImageNativePixmap;
 struct GpuPreferences;
 
 namespace gles2 {
@@ -57,10 +57,10 @@ class MEDIA_GPU_EXPORT GpuVideoDecodeAcceleratorFactory {
   // Bind |image| to |client_texture_id| given |texture_target|, marking the
   // texture as not needing binding by the decoder.
   // Return true on success, false otherwise.
-  using BindGLImageCallback = base::RepeatingCallback<bool(
-      uint32_t client_texture_id,
-      uint32_t texture_target,
-      const scoped_refptr<gpu::GLImageNativePixmap>& image)>;
+  using BindGLImageCallback =
+      base::RepeatingCallback<bool(uint32_t client_texture_id,
+                                   uint32_t texture_target,
+                                   const scoped_refptr<gl::GLImage>& image)>;
 #endif
 
   // Return a ContextGroup*, if one is available.
diff --git a/media/gpu/gpu_video_decode_accelerator_helpers.h b/media/gpu/gpu_video_decode_accelerator_helpers.h
index c9f56e8..b1e96ab 100644
--- a/media/gpu/gpu_video_decode_accelerator_helpers.h
+++ b/media/gpu/gpu_video_decode_accelerator_helpers.h
@@ -13,11 +13,10 @@
 
 namespace gl {
 class GLContext;
+class GLImage;
 }
 
 namespace gpu {
-class GLImageNativePixmap;
-
 namespace gles2 {
 class AbstractTexture;
 class ContextGroup;
@@ -46,10 +45,10 @@ using MakeGLContextCurrentCallback = base::RepeatingCallback<bool(void)>;
 // Bind |image| to |client_texture_id| given |texture_target|, marking the
 // texture as not needing binding by the decoder.
 // Return true on success, false otherwise.
-using BindGLImageCallback = base::RepeatingCallback<bool(
-    uint32_t client_texture_id,
-    uint32_t texture_target,
-    const scoped_refptr<gpu::GLImageNativePixmap>& image)>;
+using BindGLImageCallback =
+    base::RepeatingCallback<bool(uint32_t client_texture_id,
+                                 uint32_t texture_target,
+                                 const scoped_refptr<gl::GLImage>& image)>;
 #endif
 
 // Return a ContextGroup*, if one is available.
@@ -86,10 +85,10 @@ struct MEDIA_GPU_EXPORT GpuVideoDecodeGLClient {
   // Bind |image| to |client_texture_id| given |texture_target|, marking the
   // texture as not needing binding by the decoder.
   // Return true on success, false otherwise.
-  using BindGLImageCallback = base::RepeatingCallback<bool(
-      uint32_t client_texture_id,
-      uint32_t texture_target,
-      const scoped_refptr<gpu::GLImageNativePixmap>& image)>;
+  using BindGLImageCallback =
+      base::RepeatingCallback<bool(uint32_t client_texture_id,
+                                   uint32_t texture_target,
+                                   const scoped_refptr<gl::GLImage>& image)>;
 #endif
 
   // Return a ContextGroup*, if one is available.
diff --git a/media/gpu/ipc/service/vda_video_decoder.cc b/media/gpu/ipc/service/vda_video_decoder.cc
index 3615ac3..9f523e5 100644
--- a/media/gpu/ipc/service/vda_video_decoder.cc
+++ b/media/gpu/ipc/service/vda_video_decoder.cc
@@ -17,7 +17,6 @@
 #include "base/task/single_thread_task_runner.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
-#include "gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h"
 #include "gpu/config/gpu_driver_bug_workarounds.h"
 #include "gpu/config/gpu_info.h"
 #include "gpu/config/gpu_preferences.h"
@@ -34,6 +33,7 @@
 #include "media/gpu/gpu_video_decode_accelerator_factory.h"
 #include "media/video/picture.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gl/gl_image.h"
 
 namespace media {
 
@@ -63,7 +63,7 @@ bool BindClientManagedImage(
     scoped_refptr<CommandBufferHelper> command_buffer_helper,
     uint32_t client_texture_id,
     uint32_t texture_target,
-    const scoped_refptr<gpu::GLImageNativePixmap>& image) {
+    const scoped_refptr<gl::GLImage>& image) {
   return command_buffer_helper->BindClientManagedImage(client_texture_id,
                                                        image.get());
 }
diff --git a/media/gpu/test/fake_command_buffer_helper.cc b/media/gpu/test/fake_command_buffer_helper.cc
index 9313b4b..d9e1c4a 100644
--- a/media/gpu/test/fake_command_buffer_helper.cc
+++ b/media/gpu/test/fake_command_buffer_helper.cc
@@ -154,9 +154,8 @@ void FakeCommandBufferHelper::SetCleared(GLuint service_id) {
 }
 
 #if BUILDFLAG(IS_OZONE)
-bool FakeCommandBufferHelper::BindClientManagedImage(
-    GLuint service_id,
-    gpu::GLImageNativePixmap* image) {
+bool FakeCommandBufferHelper::BindClientManagedImage(GLuint service_id,
+                                                     gl::GLImage* image) {
   DVLOG(2) << __func__ << "(" << service_id << ")";
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK(service_ids_.count(service_id));
diff --git a/media/gpu/test/fake_command_buffer_helper.h b/media/gpu/test/fake_command_buffer_helper.h
index 8bbd991..75157ba 100644
--- a/media/gpu/test/fake_command_buffer_helper.h
+++ b/media/gpu/test/fake_command_buffer_helper.h
@@ -66,8 +66,7 @@ class FakeCommandBufferHelper : public CommandBufferHelper {
   void DestroyTexture(GLuint service_id) override;
   void SetCleared(GLuint service_id) override;
 #if BUILDFLAG(IS_OZONE)
-  bool BindClientManagedImage(GLuint service_id,
-                              gpu::GLImageNativePixmap* image) override;
+  bool BindClientManagedImage(GLuint service_id, gl::GLImage* image) override;
 #endif
   gpu::Mailbox CreateLegacyMailbox(GLuint service_id) override;
   void AddWillDestroyStubCB(WillDestroyStubCB callback) override;
diff --git a/ui/gl/BUILD.gn b/ui/gl/BUILD.gn
index bea950f..e1df9ac 100644
--- a/ui/gl/BUILD.gn
+++ b/ui/gl/BUILD.gn
@@ -147,6 +147,10 @@ component("gl") {
     ]
   }
 
+  if (!is_android) {
+    sources += [ "gl_image.h" ]
+  }
+
   configs += [ "//build/config:precompiled_headers" ]
   defines = [ "GL_IMPLEMENTATION" ]
   if (enable_gpu_service_logging) {
diff --git a/ui/gl/gl_image.h b/ui/gl/gl_image.h
new file mode 100644
index 0000000..e2b89c5
--- /dev/null
+++ b/ui/gl/gl_image.h
@@ -0,0 +1,44 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GL_GL_IMAGE_H_
+#define UI_GL_GL_IMAGE_H_
+
+#include "base/memory/ref_counted.h"
+#include "ui/gl/gl_export.h"
+
+namespace gpu::gles2 {
+class GLES2DecoderImpl;
+class GLES2DecoderPassthroughImpl;
+}  // namespace gpu::gles2
+
+namespace gl {
+
+// Encapsulates an image that can be bound and/or copied to a texture, hiding
+// platform specific management.
+class GL_EXPORT GLImage : public base::RefCounted<GLImage> {
+ public:
+  GLImage(const GLImage&) = delete;
+  GLImage& operator=(const GLImage&) = delete;
+
+ protected:
+  // NOTE: We are in the process of eliminating client usage of GLImage. As part
+  // of this effort, we have moved its public interface to be protected with
+  // friend'ing of existing users. DO NOT ADD MORE client usage - instead, reach
+  // out to shared-image-team@ with your use case.
+  // See crbug.com/1382031.
+  GLImage() = default;
+
+  virtual ~GLImage() = default;
+
+ private:
+  friend class gpu::gles2::GLES2DecoderImpl;
+  friend class gpu::gles2::GLES2DecoderPassthroughImpl;
+
+  friend class base::RefCounted<GLImage>;
+};
+
+}  // namespace gl
+
+#endif  // UI_GL_GL_IMAGE_H_
diff --git a/ui/ozone/gl/DEPS b/ui/ozone/gl/DEPS
index eb7d2a6..e6142e8 100644
--- a/ui/ozone/gl/DEPS
+++ b/ui/ozone/gl/DEPS
@@ -1,8 +1,5 @@
 specific_include_rules = {
-  # NOTE: See comment in ./BUILD.gn with respect to these dependencies.
-  "gl_image_test_template\.h": [
-    "+gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h",
-  ],
+  # NOTE: See comment in ./BUILD.gn with respect to this dependency.
   "gl_image_ozone_native_pixmap_unittest\.cc": [
     "+gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h",
   ],
diff --git a/ui/ozone/gl/gl_image_ozone_native_pixmap_unittest.cc b/ui/ozone/gl/gl_image_ozone_native_pixmap_unittest.cc
index 53c7328..ab33073 100644
--- a/ui/ozone/gl/gl_image_ozone_native_pixmap_unittest.cc
+++ b/ui/ozone/gl/gl_image_ozone_native_pixmap_unittest.cc
@@ -52,9 +52,8 @@ class GLImageNativePixmapTestDelegate : public GLImageTestDelegateBase {
     return false;
   }
 
-  scoped_refptr<gpu::GLImageNativePixmap> CreateSolidColorImage(
-      const gfx::Size& size,
-      const uint8_t color[4]) {
+  scoped_refptr<GLImage> CreateSolidColorImage(const gfx::Size& size,
+                                               const uint8_t color[4]) {
     ui::SurfaceFactoryOzone* surface_factory =
         ui::OzonePlatform::GetInstance()->GetSurfaceFactoryOzone();
     scoped_refptr<gfx::NativePixmap> pixmap =
diff --git a/ui/ozone/gl/gl_image_test_template.h b/ui/ozone/gl/gl_image_test_template.h
index fdeb6d3..f2fd5d2 100644
--- a/ui/ozone/gl/gl_image_test_template.h
+++ b/ui/ozone/gl/gl_image_test_template.h
@@ -11,7 +11,6 @@
 #include "base/memory/raw_ptr.h"
 #include "base/strings/stringize_macros.h"
 #include "build/build_config.h"
-#include "gpu/command_buffer/service/shared_image/gl_image_native_pixmap.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "ui/gfx/buffer_format_util.h"
@@ -20,6 +19,7 @@
 #include "ui/gl/gl_context.h"
 #include "ui/gl/gl_display.h"
 #include "ui/gl/gl_helper.h"
+#include "ui/gl/gl_image.h"
 #include "ui/gl/gl_surface.h"
 #include "ui/gl/gl_version_info.h"
 #include "ui/gl/init/gl_factory.h"
@@ -107,13 +107,13 @@ TYPED_TEST_P_WITH_EXPANSION(GLImageTest, MAYBE_Create) {
 
   // Create a small solid color green image of preferred format. This must
   // succeed in order for a GLImage to be conformant.
-  scoped_refptr<gpu::GLImageNativePixmap> small_image =
+  scoped_refptr<GLImage> small_image =
       this->delegate_.CreateSolidColorImage(small_image_size, image_color);
   ASSERT_TRUE(small_image);
 
   // Create a large solid color green image of preferred format. This must
   // succeed in order for a GLImage to be conformant.
-  scoped_refptr<gpu::GLImageNativePixmap> large_image =
+  scoped_refptr<GLImage> large_image =
       this->delegate_.CreateSolidColorImage(large_image_size, image_color);
   ASSERT_TRUE(large_image);
 }
@@ -138,7 +138,7 @@ TYPED_TEST_P_WITH_EXPANSION(GLImageOddSizeTest, MAYBE_Create) {
 
   // Create an odd-sized solid color green image of preferred format. This must
   // succeed in order for a GLImage to be conformant.
-  scoped_refptr<gpu::GLImageNativePixmap> odd_image =
+  scoped_refptr<GLImage> odd_image =
       this->delegate_.CreateSolidColorImage(odd_image_size, image_color);
   ASSERT_TRUE(odd_image);
 }
