diff --git a/clang-tools-extra/clangd/Hover.cpp b/clang-tools-extra/clangd/Hover.cpp
index ef3523211..a0c74c84a 100644
--- a/clang-tools-extra/clangd/Hover.cpp
+++ b/clang-tools-extra/clangd/Hover.cpp
@@ -993,6 +993,113 @@ bool isHardLineBreakAfter(llvm::StringRef Line, llvm::StringRef Rest) {
   return punctuationIndicatesLineBreak(Line) || isHardLineBreakIndicator(Rest);
 }
 
+static auto getRecordOfMethodDecl(const CXXMethodDecl *Method) {
+  const auto *Record = Method->getParent();
+  if (Record)
+    Record = Record->getDefinition();
+  // FIXME: Depend type may not affect vtable. Check on mixins?
+  if (!Record || Record->isInvalidDecl() || Record->isDependentType())
+    return static_cast<const CXXRecordDecl *>(nullptr);
+  return Record;
+}
+static uint64_t getVirtualCXXMethodsCount(const CXXRecordDecl *Record) {
+  uint64_t Count = 0;
+  for (const auto &Base :
+       Record->bases()) { // FIXME: Calc only for first or last base
+    const auto *BaseRecord = Base.getType()->getAsCXXRecordDecl();
+    if (BaseRecord)
+      Count += getVirtualCXXMethodsCount(BaseRecord);
+    break;
+  }
+  static auto IsOverride = [](const CXXMethodDecl *Method,
+                              const CXXRecordDecl *Record) {
+    if (Method->size_overridden_methods() == 0)
+      return false;
+    for (const auto *MD : Method->overridden_methods()) {
+      const auto *RD = getRecordOfMethodDecl(MD);
+      if (RD && Record->isDerivedFrom(RD))
+        return true;
+    }
+    return false;
+  };
+  const auto MSABI =
+      Record->getASTContext().getTargetInfo().getCXXABI().isMicrosoft();
+  for (const auto *MD : Record->methods()) {
+    if (!MD->isVirtual() || IsOverride(MD, Record))
+      continue;
+    if (!MSABI && Record->getDestructor() == MD)
+      Count++;
+    Count++;
+  }
+  return Count;
+}
+static constexpr auto InvalidVirtualCXXMethodId =
+    std::numeric_limits<uint64_t>::max();
+static uint64_t findVirtualCXXMethodId(const CXXMethodDecl *Method,
+                                       const CXXRecordDecl *Record = nullptr) {
+  if (!Method->isVirtual())
+    return InvalidVirtualCXXMethodId; // FIXME: Find id from override.
+  if (!Record) {
+    Record = getRecordOfMethodDecl(Method);
+    if (!Record)
+      return InvalidVirtualCXXMethodId;
+  }
+  const auto MSABI =
+      Record->getASTContext().getTargetInfo().getCXXABI().isMicrosoft();
+  if (Record->getNumBases() == 0) {
+    uint64_t Id = 0;
+    for (const auto *MD : Record->methods()) {
+      if (!MD->isVirtual())
+        continue;
+      if (MD == Method)
+        return Id;
+      if (!MSABI && Record->getDestructor() == MD)
+        Id++;
+      Id++;
+    }
+  } else {
+    static auto GetBaseMethod = [](const CXXMethodDecl *Method,
+                                   const CXXRecordDecl *Record) {
+      const CXXMethodDecl *Base = Method;
+      if (Method->size_overridden_methods() == 0)
+        return Base;
+      for (const auto *MD : Method->overridden_methods()) {
+        const auto *RD = getRecordOfMethodDecl(MD);
+        if (RD && Record->isDerivedFrom(RD)) {
+          Record = RD;
+          Base = MD;
+        }
+      }
+      return Base;
+    };
+
+    const auto *BaseMethod = GetBaseMethod(Method, Record);
+    if (BaseMethod != Method) {
+      const auto *Record = BaseMethod->getThisType()->getAsCXXRecordDecl();
+      return findVirtualCXXMethodId(BaseMethod, Record);
+    }
+    for (const auto &Base :
+         Record->bases()) { // FIXME: Calc only for first or last base
+      const auto *BaseRecord = Base.getType()->getAsCXXRecordDecl();
+      if (!BaseRecord)
+        continue;
+      uint64_t Id = getVirtualCXXMethodsCount(BaseRecord);
+      for (const auto *MD : Record->methods()) {
+        const auto *BaseMethod = GetBaseMethod(MD, Record);
+        if (!MD->isVirtual() || BaseMethod != MD)
+          continue;
+        if (MD == Method)
+          return Id;
+        if (!MSABI && Record->getDestructor() == MD)
+          Id++;
+        Id++;
+      }
+      break;
+    }
+  }
+  return InvalidVirtualCXXMethodId;
+}
+
 void addLayoutInfo(const NamedDecl &ND, HoverInfo &HI) {
   if (ND.isInvalidDecl())
     return;
@@ -1039,6 +1146,17 @@ void addLayoutInfo(const NamedDecl &ND, HoverInfo &HI) {
     }
     return;
   }
+
+  if (const auto *MD = llvm::dyn_cast<CXXMethodDecl>(&ND)) {
+    if (MD->isVirtual()) {
+      auto Id = findVirtualCXXMethodId(MD);
+      if (Id != InvalidVirtualCXXMethodId) {
+        const auto PointerSize = Ctx.getTargetInfo().getPointerWidth(LangAS::Default);
+        HI.Offset = Id * PointerSize;
+        HI.Size = PointerSize;
+      }
+    }
+  }
 }
 
 HoverInfo::PassType::PassMode getPassMode(QualType ParmType) {
@@ -1074,10 +1192,9 @@ void maybeAddCalleeArgInfo(const SelectionTree::Node *N, HoverInfo &HI,
 
   // For non-function-call-like operators (e.g. operator+, operator<<) it's
   // not immediately obvious what the "passed as" would refer to and, given
-  // fixed function signature, the value would be very low anyway, so we choose
-  // to not support that.
-  // Both variadic functions and operator() (especially relevant for lambdas)
-  // should be supported in the future.
+  // fixed function signature, the value would be very low anyway, so we
+  // choose to not support that. Both variadic functions and operator()
+  // (especially relevant for lambdas) should be supported in the future.
   if (!FD || FD->isOverloadedOperator() || FD->isVariadic())
     return;
 
@@ -1102,8 +1219,8 @@ void maybeAddCalleeArgInfo(const SelectionTree::Node *N, HoverInfo &HI,
     return;
 
   // If we found a matching argument, also figure out if it's a
-  // [const-]reference. For this we need to walk up the AST from the arg itself
-  // to CallExpr and check all implicit casts, constructor calls, etc.
+  // [const-]reference. For this we need to walk up the AST from the arg
+  // itself to CallExpr and check all implicit casts, constructor calls, etc.
   if (const auto *E = N->ASTNode.get<Expr>()) {
     if (E->getType().isConstQualified())
       PassType.PassBy = HoverInfo::PassType::ConstRef;
@@ -1138,8 +1255,8 @@ void maybeAddCalleeArgInfo(const SelectionTree::Node *N, HoverInfo &HI,
       }
     } else if (const auto *CtorCall =
                    CastNode->ASTNode.get<CXXConstructExpr>()) {
-      // We want to be smart about copy constructors. They should not show up as
-      // type conversion, but instead as passing by value.
+      // We want to be smart about copy constructors. They should not show up
+      // as type conversion, but instead as passing by value.
       if (CtorCall->getConstructor()->isCopyConstructor())
         PassType.PassBy = HoverInfo::PassType::Value;
       else
