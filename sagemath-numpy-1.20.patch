diff --git a/src/doc/en/thematic_tutorials/numerical_sage/f2py_examples.rst b/src/doc/en/thematic_tutorials/numerical_sage/f2py_examples.rst
index 16b35fcab1..43a706a036 100644
--- a/src/doc/en/thematic_tutorials/numerical_sage/f2py_examples.rst
+++ b/src/doc/en/thematic_tutorials/numerical_sage/f2py_examples.rst
@@ -52,7 +52,7 @@ driver code
 .. CODE-BLOCK:: python
 
     import numpy
-    j=numpy.complex(0,1)
+    j=complex(0,1)
     num_points=50
     u=numpy.zeros((num_points,num_points),dtype=float)
     pi_c=float(pi)
diff --git a/src/doc/en/thematic_tutorials/numerical_sage/numpy.rst b/src/doc/en/thematic_tutorials/numerical_sage/numpy.rst
index e50b2ea5d4..6e2bdbfb0c 100644
--- a/src/doc/en/thematic_tutorials/numerical_sage/numpy.rst
+++ b/src/doc/en/thematic_tutorials/numerical_sage/numpy.rst
@@ -235,7 +235,7 @@ from 0 to 2. There is a useful command :meth:`numpy.r_` that is best explained b
 ::
 
     sage: from numpy import r_
-    sage: j=numpy.complex(0,1)
+    sage: j=complex(0,1)
     sage: RealNumber=float
     sage: Integer=int
     sage: n=r_[0.0:5.0]
@@ -280,7 +280,7 @@ an equally spaced grid with `\Delta x = \Delta y = .25` for
 ::
 
     sage: import numpy
-    sage: j=numpy.complex(0,1)
+    sage: j=complex(0,1)
     sage: def f(x,y):
     ....:     return x**2+y**2
     sage: from numpy import meshgrid
diff --git a/src/doc/en/thematic_tutorials/numerical_sage/parallel_laplace_solver.rst b/src/doc/en/thematic_tutorials/numerical_sage/parallel_laplace_solver.rst
index 19a200ec50..388f3556fd 100644
--- a/src/doc/en/thematic_tutorials/numerical_sage/parallel_laplace_solver.rst
+++ b/src/doc/en/thematic_tutorials/numerical_sage/parallel_laplace_solver.rst
@@ -24,7 +24,7 @@ this with the solver we wrote in the section on f2py.
     root=0
     dx=1.0/(num_points-1)
     from numpy import r_
-    j=numpy.complex(0,1)
+    j=complex(0,1)
     rows_per_process=num_points/size
     max_iter=5000
     num_iter=0
diff --git a/src/sage/calculus/interpolators.pyx b/src/sage/calculus/interpolators.pyx
index a62b9e8e19..d920acf8b5 100644
--- a/src/sage/calculus/interpolators.pyx
+++ b/src/sage/calculus/interpolators.pyx
@@ -89,7 +89,7 @@ cdef class PSpline:
         """
         if type(pts[0]) == type((0,0)):
             self.pts = np.array(
-                [np.complex(i[0], i[1]) for i in pts], dtype=np.complex128)
+                [complex(i[0], i[1]) for i in pts], dtype=np.complex128)
         else:
             self.pts = np.array(pts, dtype=np.complex128)
         self.N = len(pts)
@@ -221,7 +221,7 @@ cdef class CCSpline:
         """
         if type(pts[0]) == type((0,0)):
             pts = np.array(
-                [np.complex(pt[0], pt[1]) for pt in pts], dtype=np.complex128)
+                [complex(pt[0], pt[1]) for pt in pts], dtype=np.complex128)
         cdef int N, i, k
         N = len(pts)
         yvec = np.zeros(N, dtype=np.complex128)
diff --git a/src/sage/calculus/riemann.pyx b/src/sage/calculus/riemann.pyx
index 0bbc550712..c8569895dc 100644
--- a/src/sage/calculus/riemann.pyx
+++ b/src/sage/calculus/riemann.pyx
@@ -255,13 +255,13 @@ cdef class Riemann_Map:
             for k in xrange(self.B):
                 for i in xrange(N):
                     fk = fs[k](self.tk[N-i-1])
-                    cps[k, i] = np.complex(1/fk)
-                    dps[k, i] = np.complex(1/fk**2*fprimes[k](self.tk[N-i-1]))
+                    cps[k, i] = complex(1/fk)
+                    dps[k, i] = complex(1/fk**2*fprimes[k](self.tk[N-i-1]))
         else:
             for k in xrange(self.B):
                 for i in xrange(N):
-                    cps[k, i] = np.complex(fs[k](self.tk[i]))
-                    dps[k, i] = np.complex(fprimes[k](self.tk[i]))
+                    cps[k, i] = complex(fs[k](self.tk[i]))
+                    dps[k, i] = complex(fprimes[k](self.tk[i]))
         if self.exterior:
             xmax = (1/cps).real.max()
             xmin = (1/cps).real.min()
@@ -605,8 +605,7 @@ cdef class Riemann_Map:
             (-1.56...e-05+0.989694...j)
             sage: m.riemann_map(0.4)
             (0.73324...+3.2...e-06j)
-            sage: import numpy as np
-            sage: m.riemann_map(np.complex(-3, 0.0001))
+            sage: m.riemann_map(complex(-3, 0.0001))
             (1.405757...e-05+8.06...e-10j)
         """
 
@@ -691,8 +690,7 @@ cdef class Riemann_Map:
             (0.486319...-4.90019052...j)
             sage: m.inverse_riemann_map(0.25 - 0.3*I)
             (0.1653244...-0.180936...j)
-            sage: import numpy as np
-            sage: m.inverse_riemann_map(np.complex(-0.2, 0.5))
+            sage: m.inverse_riemann_map(complex(-0.2, 0.5))
             (-0.156280...+0.321819...j)
         """
         if self.exterior:
@@ -974,7 +972,7 @@ cdef class Riemann_Map:
                 for i in xrange(pts - 1):
                     temp[i] = self.inverse_riemann_map(
                         (i * 1.0) / (pts * 1.0) * exp(I * angle) * linescale)
-                temp[pts - 1] = np.complex(
+                temp[pts - 1] = complex(
                     self.f(s(angle)) if angle <= tmax else self.f(s(angle-TWOPI)))
                 if plotjoined:
                     line_list[k] = list_plot(
diff --git a/src/sage/matrix/constructor.pyx b/src/sage/matrix/constructor.pyx
index 614922292e..c6712f37e3 100644
--- a/src/sage/matrix/constructor.pyx
+++ b/src/sage/matrix/constructor.pyx
@@ -457,7 +457,7 @@ def matrix(*args, **kwds):
     Check conversion from numpy::
 
         sage: import numpy
-        sage: n = numpy.array([[numpy.complex(0,1),numpy.complex(0,2)],[3,4]],complex)
+        sage: n = numpy.array([[complex(0,1),complex(0,2)],[3,4]],complex)
         sage: m = matrix(n); m; m.parent()
         [1.0*I 2.0*I]
         [  3.0   4.0]
diff --git a/src/sage/matrix/special.py b/src/sage/matrix/special.py
index c68a320773..1f249b4da5 100644
--- a/src/sage/matrix/special.py
+++ b/src/sage/matrix/special.py
@@ -713,7 +713,7 @@ def diagonal_matrix(arg0=None, arg1=None, arg2=None, sparse=True):
         sage: A.parent()
         Full MatrixSpace of 3 by 3 sparse matrices over Real Double Field
 
-        sage: j = numpy.complex(0,1)
+        sage: j = complex(0,1)
         sage: entries = numpy.array([2.0+j, 8.1, 3.4+2.6*j]); entries
         array([2. +1.j , 8.1+0.j , 3.4+2.6j])
         sage: A = diagonal_matrix(entries); A
diff --git a/src/sage/modules/free_module_element.pyx b/src/sage/modules/free_module_element.pyx
index 5ccadc90da..4714ae6c51 100644
--- a/src/sage/modules/free_module_element.pyx
+++ b/src/sage/modules/free_module_element.pyx
@@ -359,7 +359,7 @@ def vector(arg0, arg1=None, arg2=None, sparse=None, immutable=False):
         Vector space of dimension 10 over Complex Double Field
         sage: parent(vector(RR, x))
         Vector space of dimension 10 over Real Field with 53 bits of precision
-        sage: v = numpy.random.randn(10) * numpy.complex(0,1)
+        sage: v = numpy.random.randn(10) * complex(0,1)
         sage: w = vector(v)
         sage: parent(w)
         Vector space of dimension 10 over Complex Double Field
@@ -454,11 +454,11 @@ def vector(arg0, arg1=None, arg2=None, sparse=None, immutable=False):
         sage: v.is_immutable()
         True
         sage: import numpy as np
-        sage: w = np.array([1, 2, pi], np.float)
+        sage: w = np.array([1, 2, pi], float)
         sage: v = vector(w, immutable=True)
         sage: v.is_immutable()
         True
-        sage: w = np.array([i, 2, 3], np.complex)
+        sage: w = np.array([i, 2, 3], complex)
         sage: v = vector(w, immutable=True)
         sage: v.is_immutable()
         True
diff --git a/src/sage/plot/arrow.py b/src/sage/plot/arrow.py
index 8eb7a6d08b..0247872298 100644
--- a/src/sage/plot/arrow.py
+++ b/src/sage/plot/arrow.py
@@ -44,7 +44,7 @@ class CurveArrow(GraphicPrimitive):
             vertices += curve
             codes += (len(curve))*[len(curve)+1]
         self.codes = codes
-        self.vertices = np.array(vertices, np.float)
+        self.vertices = np.array(vertices, float)
         GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
diff --git a/src/sage/plot/bezier_path.py b/src/sage/plot/bezier_path.py
index 56da1dcbe4..79a9390c35 100644
--- a/src/sage/plot/bezier_path.py
+++ b/src/sage/plot/bezier_path.py
@@ -66,7 +66,7 @@ class BezierPath(GraphicPrimitive_xydata):
             vertices += curve
             codes += (len(curve)) * [len(curve)+1]
         self.codes = codes
-        self.vertices = np.array(vertices, np.float)
+        self.vertices = np.array(vertices, float)
         GraphicPrimitive_xydata.__init__(self, options)
 
     def _allowed_options(self):
diff --git a/src/sage/plot/complex_plot.pyx b/src/sage/plot/complex_plot.pyx
index e4a8c7fcae..d688b6e499 100644
--- a/src/sage/plot/complex_plot.pyx
+++ b/src/sage/plot/complex_plot.pyx
@@ -100,7 +100,7 @@ def complex_to_rgb(z_values):
 
     imax = len(z_values)
     jmax = len(z_values[0])
-    cdef cnumpy.ndarray[cnumpy.float_t, ndim=3, mode='c'] rgb = numpy.empty(dtype=numpy.float, shape=(imax, jmax, 3))
+    cdef cnumpy.ndarray[cnumpy.float_t, ndim=3, mode='c'] rgb = numpy.empty(dtype=float, shape=(imax, jmax, 3))
 
     sig_on()
     for i from 0 <= i < imax:
diff --git a/src/sage/plot/plot3d/list_plot3d.py b/src/sage/plot/plot3d/list_plot3d.py
index 83c1034762..875165ee97 100644
--- a/src/sage/plot/plot3d/list_plot3d.py
+++ b/src/sage/plot/plot3d/list_plot3d.py
@@ -452,7 +452,7 @@ def list_plot3d_tuples(v, interpolation_type, **kwds):
     if interpolation_type == 'linear':
         T = tri.Triangulation(x, y)
         f = tri.LinearTriInterpolator(T, z)
-        j = numpy.complex(0, 1)
+        j = complex(0, 1)
         from .parametric_surface import ParametricSurface
 
         def g(x, y):
@@ -467,7 +467,7 @@ def list_plot3d_tuples(v, interpolation_type, **kwds):
     if interpolation_type == 'clough' or interpolation_type == 'default':
 
         points = [[x[i], y[i]] for i in range(len(x))]
-        j = numpy.complex(0, 1)
+        j = complex(0, 1)
         f = interpolate.CloughTocher2DInterpolator(points, z)
         from .parametric_surface import ParametricSurface
 
diff --git a/src/sage/rings/integer.pyx b/src/sage/rings/integer.pyx
index 77a3a18913..9ca8ab3153 100644
--- a/src/sage/rings/integer.pyx
+++ b/src/sage/rings/integer.pyx
@@ -628,9 +628,9 @@ cdef class Integer(sage.structure.element.EuclideanDomainElement):
             sage: 12 == numpy.int8('12')
             True
 
-            sage: numpy.float('15') == 15
+            sage: float('15') == 15
             True
-            sage: 15 == numpy.float('15')
+            sage: 15 == float('15')
             True
 
         Test underscores as digit separators (PEP 515,
diff --git a/src/sage/rings/real_mpfi.pyx b/src/sage/rings/real_mpfi.pyx
index 6308866863..a87d9903dd 100644
--- a/src/sage/rings/real_mpfi.pyx
+++ b/src/sage/rings/real_mpfi.pyx
@@ -235,7 +235,7 @@ TESTS::
     True
     sage: numpy.int8('2') == RIF(2)
     True
-    sage: RIF(0,1) < numpy.float('2')
+    sage: RIF(0,1) < float('2')
     Traceback (most recent call last):
     ...
     TypeError: unsupported operand parent(s) for <: ...
diff --git a/src/sage/structure/coerce.pyx b/src/sage/structure/coerce.pyx
index 4e174df8c9..1f6e251386 100644
--- a/src/sage/structure/coerce.pyx
+++ b/src/sage/structure/coerce.pyx
@@ -132,12 +132,12 @@ cpdef py_scalar_parent(py_type):
         sage: py_scalar_parent(numpy.uint64)
         Integer Ring
 
-        sage: py_scalar_parent(numpy.float)
+        sage: py_scalar_parent(float)
         Real Double Field
         sage: py_scalar_parent(numpy.double)
         Real Double Field
 
-        sage: py_scalar_parent(numpy.complex)
+        sage: py_scalar_parent(complex)
         Complex Double Field
 
         sage: import gmpy2
@@ -328,7 +328,7 @@ cpdef bint parent_is_integers(P) except -1:
         True
         sage: parent_is_integers(numpy.uint64)
         True
-        sage: parent_is_integers(numpy.float)
+        sage: parent_is_integers(float)
         False
 
         sage: import gmpy2
@@ -420,8 +420,6 @@ cpdef bint is_numpy_type(t):
         True
         sage: is_numpy_type(numpy.floating)
         True
-        sage: is_numpy_type(numpy.float)  # Alias for Python float
-        False
         sage: is_numpy_type(numpy.ndarray)
         True
         sage: is_numpy_type(numpy.matrix)
@@ -512,9 +510,9 @@ cdef class CoercionModel:
         sage: x * numpy.float32('1.5')
         1.50000000000000*x
         sage: p = x**3 + 2*x - 1
-        sage: p(numpy.float('1.2'))
+        sage: p(float('1.2'))
         3.12800000000000
-        sage: p(numpy.int('2'))
+        sage: p(int('2'))
         11.0000000000000
 
     This used to fail (see :trac:`18076`)::
diff --git a/src/sage/symbolic/function.pyx b/src/sage/symbolic/function.pyx
index 21bdb10ad3..ff3c51c768 100644
--- a/src/sage/symbolic/function.pyx
+++ b/src/sage/symbolic/function.pyx
@@ -540,7 +540,7 @@ cdef class Function(SageObject):
         Check that `real_part` and `imag_part` still works after :trac:`21216`::
 
             sage: import numpy
-            sage: a = numpy.array([1+2*I, -2-3*I], dtype=numpy.complex)
+            sage: a = numpy.array([1+2*I, -2-3*I], dtype=complex)
             sage: real_part(a)
             array([ 1., -2.])
             sage: imag_part(a)
diff --git a/src/sage/symbolic/ring.pyx b/src/sage/symbolic/ring.pyx
index 238414f2b3..692266db00 100644
--- a/src/sage/symbolic/ring.pyx
+++ b/src/sage/symbolic/ring.pyx
@@ -1194,9 +1194,9 @@ cdef class NumpyToSRMorphism(Morphism):
 
     This behavior also applies to standard functions::
 
-        sage: cos(numpy.int('2'))
+        sage: cos(int('2'))
         cos(2)
-        sage: numpy.cos(numpy.int('2'))
+        sage: numpy.cos(int('2'))
         -0.4161468365471424
     """
     cdef _intermediate_ring
