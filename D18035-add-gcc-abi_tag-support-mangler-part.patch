Index: lib/AST/ItaniumMangle.cpp
===================================================================
--- lib/AST/ItaniumMangle.cpp
+++ lib/AST/ItaniumMangle.cpp
@@ -214,6 +214,8 @@
 class CXXNameMangler {
   ItaniumMangleContextImpl &Context;
   raw_ostream &Out;
+  bool NullOut = false;
+  bool DisableDerivedAbiTags = false;
 
   /// The "structor" is the top-level declaration being mangled, if
   /// that's not a template specialization; otherwise it's the pattern
@@ -263,15 +265,176 @@
 
   } FunctionTypeDepth;
 
+  // abi_tag is a gcc attribute, taking one or more strings called "tags".
+  //
+  // The goal is to annotate against which version of a library an object was
+  // build and to be able to provide backwards compatibility ("dual abi").
+  //
+  // For this the emitted mangled names have to be different, while you don't
+  // want the user to have to use different names in the source.
+  //
+  // The abi_tag can be present on Struct, Var and Function  declarations as
+  // "explicit" tag, and on inline Namespace as "implicit" tag. Explicit tags
+  // are always emitted after the unqualified name, and (implicit) tags on
+  // namespace are not.
+  //
+  // For functions and variables there is a set of "implicitly available"
+  // tags. These tags are: all tags from the namespace/structs the name is
+  // embedded in, all tags from any template arguments of the name, and, for
+  // functions, alls tags used anywhere in the <bare-function-type> (i.e.
+  // parameters and sometimes the return type).
+  //
+  // For functions this is basically the list of all tags from the signature
+  // without the unqualified name and usually without the return type of the
+  // function. In `operator Type()` Type is NOT part of that list, as it is
+  // part of the unqualified name!
+  //
+  // Now all tags from the function return type/variable type which are not
+  // "implicitly available" must be added to the explicit list of tags, and
+  // are emitted after the unqualified name.
+  //
+  // Example:
+  // namespace std {
+  //   inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) { }
+  //   inline namespace __cxx11 {
+  //     struct string { };
+  //   }
+  // }
+  //
+  // std::string foo(); // needs abi tag "cxx11" on foo
+  // std::string foo(std::string); // does NOT need abi tag "cxx11" on foo
+  // __attribute__((__abi_tag__("cxx11")))
+  // std::string foo2(std::string); // emit abi tag "cxx11" on foo anyway
+  //
+  // The tags are sorted by name before emitting, and are serialized as
+  //   <abitag> ::= B <"tag" source-name>
+
+  typedef SmallVector<StringRef, 4> AbiTagList;
+
+  // State to gather all implicit and explicit tags used in a mangled name.
+  // Must always have an instance of this while emitting any name to keep
+  // track.
+  //
+  // FIXME: how to handle substituted names? They should add the tags used in
+  // the substitution to the list of available tags.
+  class AbiTagState final {
+    //! All abi tags used implicitly or explicitly
+    std::set<StringRef> UsedAbiTags;
+    //! All explicit abi tags (i.e. not from namespace)
+    std::set<StringRef> EmittedAbiTags;
+
+    AbiTagState *&LinkHead;
+    AbiTagState *Parent{ nullptr };
+
+    bool LinkActive{ false };
+
+  public:
+    explicit AbiTagState(AbiTagState *&linkHead) : LinkHead(linkHead) {
+      Parent = LinkHead;
+      LinkHead = this;
+      LinkActive = true;
+    }
+
+    // no copy, no move
+    AbiTagState(AbiTagState const &) = delete;
+    AbiTagState &operator=(AbiTagState const &) = delete;
+
+    ~AbiTagState() { pop(); }
+
+    void pop() {
+      if (!LinkActive)
+        return;
+
+      assert(LinkHead == this &&
+             "abi tag link head must point to us on destruction");
+      LinkActive = false;
+      if (Parent) {
+        Parent->UsedAbiTags.insert(UsedAbiTags.begin(), UsedAbiTags.end());
+        Parent->EmittedAbiTags.insert(EmittedAbiTags.begin(),
+                                      EmittedAbiTags.end());
+      }
+      LinkHead = Parent;
+    }
+
+    void write(raw_ostream &Out, const NamedDecl *ND,
+               const AbiTagList *AdditionalAbiTags) {
+      ND = cast<NamedDecl>(ND->getCanonicalDecl());
+
+      if (dyn_cast<FunctionDecl>(ND) || dyn_cast<VarDecl>(ND)) {
+        // assert(AdditionalAbiTags && "function and variables need a list of
+        // additional abi tags");
+      } else {
+        assert(
+            !AdditionalAbiTags &&
+            "only function and variables need a list of additional abi tags");
+        if (const auto *NS = dyn_cast<NamespaceDecl>(ND)) {
+          if (const auto *AbiTag = NS->getAttr<AbiTagAttr>()) {
+            for (const auto &Tag : AbiTag->tags()) {
+              UsedAbiTags.insert(Tag);
+            }
+          }
+          // don't emit abi tags for namespaces
+          return;
+        }
+      }
+
+      AbiTagList TagList;
+      if (const auto *AbiTag = ND->getAttr<AbiTagAttr>()) {
+        for (const auto &Tag : AbiTag->tags()) {
+          UsedAbiTags.insert(Tag);
+          // AbiTag->tags() is sorted and has no duplicates
+          TagList.push_back(Tag);
+        }
+      }
+
+      if (AdditionalAbiTags) {
+        for (const auto &Tag : *AdditionalAbiTags) {
+          UsedAbiTags.insert(Tag);
+          if (std::find(TagList.begin(), TagList.end(), Tag) == TagList.end()) {
+            // don't insert duplicates
+            TagList.push_back(Tag);
+          }
+        }
+        // AbiTag->tags() are already sorted; only add if we had additional tags
+        std::sort(TagList.begin(), TagList.end());
+      }
+
+      writeSortedUniqueAbiTags(Out, TagList);
+    }
+
+    const std::set<StringRef> &getUsedAbiTags() const { return UsedAbiTags; }
+    void setUsedAbiTags(const std::set<StringRef> &AbiTags) {
+      UsedAbiTags = AbiTags;
+    }
+
+    const std::set<StringRef> &getEmittedAbiTags() const {
+      return EmittedAbiTags;
+    }
+
+  private:
+    template <typename TagList>
+    void writeSortedUniqueAbiTags(raw_ostream &Out, TagList const &AbiTags) {
+      for (const auto &Tag : AbiTags) {
+        EmittedAbiTags.insert(Tag);
+        Out << "B";
+        Out << Tag.size();
+        Out << Tag;
+      }
+    }
+  };
+
+  AbiTagState *AbiTags = nullptr;
+  AbiTagState AbiTagsRoot{ AbiTags };
+
   llvm::DenseMap<uintptr_t, unsigned> Substitutions;
 
   ASTContext &getASTContext() const { return Context.getASTContext(); }
 
 public:
   CXXNameMangler(ItaniumMangleContextImpl &C, raw_ostream &Out_,
-                 const NamedDecl *D = nullptr)
-    : Context(C), Out(Out_), Structor(getStructor(D)), StructorType(0),
-      SeqID(0) {
+                 const NamedDecl *D = nullptr, bool NullOut_ = false)
+    : Context(C), Out(Out_), NullOut(NullOut_),  Structor(getStructor(D)),
+      StructorType(0), SeqID(0) {
     // These can't be mangled without a ctor type or dtor type.
     assert(!D || (!isa<CXXDestructorDecl>(D) &&
                   !isa<CXXConstructorDecl>(D)));
@@ -285,6 +448,11 @@
     : Context(C), Out(Out_), Structor(getStructor(D)), StructorType(Type),
       SeqID(0) { }
 
+  CXXNameMangler(CXXNameMangler &Outer, llvm::raw_null_ostream &Out_)
+      : Context(Outer.Context), Out(Out_), NullOut(true),
+        Structor(Outer.Structor), StructorType(Outer.StructorType),
+        SeqID(Outer.SeqID) {}
+
 #if MANGLE_CHECKER
   ~CXXNameMangler() {
     if (Out.str()[0] == '\01')
@@ -298,14 +466,18 @@
 #endif
   raw_ostream &getStream() { return Out; }
 
+  void disableDerivedAbiTags() { DisableDerivedAbiTags = true; }
+  static bool shouldHaveAbiTags(ItaniumMangleContextImpl &C, const VarDecl *VD);
+
   void mangle(const NamedDecl *D);
   void mangleCallOffset(int64_t NonVirtual, int64_t Virtual);
   void mangleNumber(const llvm::APSInt &I);
   void mangleNumber(int64_t Number);
   void mangleFloat(const llvm::APFloat &F);
-  void mangleFunctionEncoding(const FunctionDecl *FD);
+  void mangleFunctionEncoding(const FunctionDecl *FD,
+                              bool ExcludeUnqualifiedName = false);
   void mangleSeqID(unsigned SeqID);
-  void mangleName(const NamedDecl *ND);
+  void mangleName(const NamedDecl *ND, bool ExcludeUnqualifiedName = false);
   void mangleType(QualType T);
   void mangleNameOrStandardSubstitution(const NamedDecl *ND);
   
@@ -336,31 +508,53 @@
                             DeclarationName name,
                             unsigned KnownArity = UnknownArity);
 
-  void mangleName(const TemplateDecl *TD,
-                  const TemplateArgument *TemplateArgs,
-                  unsigned NumTemplateArgs);
-  void mangleUnqualifiedName(const NamedDecl *ND) {
-    mangleUnqualifiedName(ND, ND->getDeclName(), UnknownArity);
+  void mangleFunctionEncodingBareType(const FunctionDecl *FD);
+
+  void mangleNameWithAbiTags(const NamedDecl *ND,
+                             const AbiTagList *AdditionalAbiTags,
+                             bool ExcludeUnqualifiedName);
+  void mangleTemplateName(const TemplateDecl *TD,
+                          const AbiTagList *AdditionalAbiTags,
+                          bool ExcludeUnqualifiedName,
+                          const TemplateArgument *TemplateArgs,
+                          unsigned NumTemplateArgs);
+  void mangleUnqualifiedName(const NamedDecl *ND,
+                             const AbiTagList *AdditionalAbiTags) {
+    mangleUnqualifiedName(ND, ND->getDeclName(), UnknownArity,
+                          AdditionalAbiTags);
   }
   void mangleUnqualifiedName(const NamedDecl *ND, DeclarationName Name,
-                             unsigned KnownArity);
-  void mangleUnscopedName(const NamedDecl *ND);
-  void mangleUnscopedTemplateName(const TemplateDecl *ND);
-  void mangleUnscopedTemplateName(TemplateName);
+                             unsigned KnownArity,
+                             const AbiTagList *AdditionalAbiTags);
+  void mangleUnscopedName(const NamedDecl *ND,
+                          const AbiTagList *AdditionalAbiTags);
+  void mangleUnscopedTemplateName(const TemplateDecl *ND,
+                                  const AbiTagList *AdditionalAbiTags);
+  void mangleUnscopedTemplateName(TemplateName,
+                                  const AbiTagList *AdditionalAbiTags);
   void mangleSourceName(const IdentifierInfo *II);
-  void mangleLocalName(const Decl *D);
+  void mangleLocalName(const Decl *D,
+                       const AbiTagList *AdditionalAbiTags,
+                       bool ExcludeUnqualifiedName);
   void mangleBlockForPrefix(const BlockDecl *Block);
   void mangleUnqualifiedBlock(const BlockDecl *Block);
   void mangleLambda(const CXXRecordDecl *Lambda);
   void mangleNestedName(const NamedDecl *ND, const DeclContext *DC,
-                        bool NoFunction=false);
+                        const AbiTagList *AdditionalAbiTags,
+                        bool NoFunction,
+                        bool ExcludeUnqualifiedName);
   void mangleNestedName(const TemplateDecl *TD,
+                        const AbiTagList *AdditionalAbiTags,
+                        bool ExcludeUnqualifiedName,
                         const TemplateArgument *TemplateArgs,
                         unsigned NumTemplateArgs);
   void manglePrefix(NestedNameSpecifier *qualifier);
   void manglePrefix(const DeclContext *DC, bool NoFunction=false);
   void manglePrefix(QualType type);
-  void mangleTemplatePrefix(const TemplateDecl *ND, bool NoFunction=false);
+  void mangleTemplatePrefix(const TemplateDecl *ND,
+                            const AbiTagList *AdditionalAbiTags,
+                            bool NoFunction = false,
+                            bool ExcludeUnqualifiedName = false);
   void mangleTemplatePrefix(TemplateName Template);
   bool mangleUnresolvedTypeOrSimpleId(QualType DestroyedType,
                                       StringRef Prefix = "");
@@ -411,6 +605,15 @@
   void mangleTemplateParameter(unsigned Index);
 
   void mangleFunctionParam(const ParmVarDecl *parm);
+
+  void writeAbiTags(const NamedDecl *ND,
+                    const AbiTagList *AdditionalAbiTags = nullptr);
+
+  std::set<StringRef>
+  getTagsFromPrefixAndTemplateArguments(const NamedDecl *ND);
+
+  AbiTagList makeAdditionalTagsForFunction(const FunctionDecl *FD);
+  AbiTagList makeAdditionalTagsForVariable(const VarDecl *VD);
 };
 
 }
@@ -454,13 +657,22 @@
       while (!DC->isNamespace() && !DC->isTranslationUnit())
         DC = getEffectiveParentContext(DC);
     if (DC->isTranslationUnit() && D->getFormalLinkage() != InternalLinkage &&
+        !CXXNameMangler::shouldHaveAbiTags(*this, VD) &&
         !isa<VarTemplateSpecializationDecl>(D))
       return false;
   }
 
   return true;
 }
 
+void CXXNameMangler::writeAbiTags(const NamedDecl *ND,
+                                  const AbiTagList *AdditionalAbiTags) {
+  assert(AbiTags && "require AbiTagState");
+  if (AbiTags)
+    AbiTags->write(Out, ND,
+                   DisableDerivedAbiTags ? nullptr : AdditionalAbiTags);
+}
+
 void CXXNameMangler::mangle(const NamedDecl *D) {
   // <mangled-name> ::= _Z <encoding>
   //            ::= <data name>
@@ -476,14 +688,31 @@
     mangleName(cast<FieldDecl>(D));
 }
 
-void CXXNameMangler::mangleFunctionEncoding(const FunctionDecl *FD) {
-  // <encoding> ::= <function name> <bare-function-type>
-  mangleName(FD);
-
+void CXXNameMangler::mangleFunctionEncoding(const FunctionDecl *FD,
+                                            bool ExcludeUnqualifiedName) {
   // Don't mangle in the type if this isn't a decl we should typically mangle.
-  if (!Context.shouldMangleDeclName(FD))
+  if (!Context.shouldMangleDeclName(FD)) {
+    mangleNameWithAbiTags(FD, /* AdditionalAbiTags */ nullptr,
+                          ExcludeUnqualifiedName);
     return;
+  }
+
+  // <encoding> ::= <function name> <bare-function-type>
 
+  if (ExcludeUnqualifiedName) {
+    // running makeAdditionalTagsForFunction would loop, don't need it here
+    // anyway
+    mangleNameWithAbiTags(FD, /* AdditionalAbiTags */ nullptr,
+                          ExcludeUnqualifiedName);
+  } else {
+    AbiTagList AdditionalAbiTags = makeAdditionalTagsForFunction(FD);
+    mangleNameWithAbiTags(FD, &AdditionalAbiTags, ExcludeUnqualifiedName);
+  }
+
+  mangleFunctionEncodingBareType(FD);
+}
+
+void CXXNameMangler::mangleFunctionEncodingBareType(const FunctionDecl *FD) {
   if (FD->hasAttr<EnableIfAttr>()) {
     FunctionTypeDepthState Saved = FunctionTypeDepth.push();
     Out << "Ua9enable_ifI";
@@ -587,7 +816,24 @@
   return nullptr;
 }
 
-void CXXNameMangler::mangleName(const NamedDecl *ND) {
+// Must not be run from mangleLocalName for the <entity name> as it would loop
+// otherwise.
+void CXXNameMangler::mangleName(const NamedDecl *ND,
+                                bool ExcludeUnqualifiedName) {
+  if (!ExcludeUnqualifiedName) {
+    if (const VarDecl *VD = dyn_cast<VarDecl>(ND)) {
+      AbiTagList VariableAdditionalAbiTags = makeAdditionalTagsForVariable(VD);
+      mangleNameWithAbiTags(VD, &VariableAdditionalAbiTags,
+                            ExcludeUnqualifiedName);
+      return;
+    }
+  }
+  mangleNameWithAbiTags(ND, nullptr, ExcludeUnqualifiedName);
+}
+
+void CXXNameMangler::mangleNameWithAbiTags(const NamedDecl *ND,
+                                           const AbiTagList *AdditionalAbiTags,
+                                           bool ExcludeUnqualifiedName) {
   //  <name> ::= <nested-name>
   //         ::= <unscoped-name>
   //         ::= <unscoped-template-name> <template-args>
@@ -603,7 +849,7 @@
     while (!DC->isNamespace() && !DC->isTranslationUnit())
       DC = getEffectiveParentContext(DC);
   else if (GetLocalClassDecl(ND)) {
-    mangleLocalName(ND);
+    mangleLocalName(ND, AdditionalAbiTags, ExcludeUnqualifiedName);
     return;
   }
 
@@ -613,76 +859,93 @@
     // Check if we have a template.
     const TemplateArgumentList *TemplateArgs = nullptr;
     if (const TemplateDecl *TD = isTemplate(ND, TemplateArgs)) {
-      mangleUnscopedTemplateName(TD);
+      if (!ExcludeUnqualifiedName)
+        mangleUnscopedTemplateName(TD, AdditionalAbiTags);
       mangleTemplateArgs(*TemplateArgs);
       return;
     }
 
-    mangleUnscopedName(ND);
+    if (!ExcludeUnqualifiedName)
+      mangleUnscopedName(ND, AdditionalAbiTags);
     return;
   }
 
   if (isLocalContainerContext(DC)) {
-    mangleLocalName(ND);
+    mangleLocalName(ND, AdditionalAbiTags, ExcludeUnqualifiedName);
     return;
   }
 
-  mangleNestedName(ND, DC);
+  mangleNestedName(ND, DC, AdditionalAbiTags, /* NoFunction */ false,
+                   ExcludeUnqualifiedName);
 }
-void CXXNameMangler::mangleName(const TemplateDecl *TD,
-                                const TemplateArgument *TemplateArgs,
-                                unsigned NumTemplateArgs) {
+
+void CXXNameMangler::mangleTemplateName(const TemplateDecl *TD,
+                                        const AbiTagList *AdditionalAbiTags,
+                                        bool ExcludeUnqualifiedName,
+                                        const TemplateArgument *TemplateArgs,
+                                        unsigned NumTemplateArgs) {
   const DeclContext *DC = IgnoreLinkageSpecDecls(getEffectiveDeclContext(TD));
 
   if (DC->isTranslationUnit() || isStdNamespace(DC)) {
-    mangleUnscopedTemplateName(TD);
+    if (!ExcludeUnqualifiedName)
+      mangleUnscopedTemplateName(TD, AdditionalAbiTags);
     mangleTemplateArgs(TemplateArgs, NumTemplateArgs);
   } else {
-    mangleNestedName(TD, TemplateArgs, NumTemplateArgs);
+    mangleNestedName(TD, AdditionalAbiTags, ExcludeUnqualifiedName,
+                     TemplateArgs, NumTemplateArgs);
   }
 }
 
-void CXXNameMangler::mangleUnscopedName(const NamedDecl *ND) {
+void CXXNameMangler::mangleUnscopedName(const NamedDecl *ND,
+                                        const AbiTagList *AdditionalAbiTags) {
   //  <unscoped-name> ::= <unqualified-name>
   //                  ::= St <unqualified-name>   # ::std::
 
   if (isStdNamespace(IgnoreLinkageSpecDecls(getEffectiveDeclContext(ND))))
     Out << "St";
 
-  mangleUnqualifiedName(ND);
+  mangleUnqualifiedName(ND, AdditionalAbiTags);
 }
 
-void CXXNameMangler::mangleUnscopedTemplateName(const TemplateDecl *ND) {
+void CXXNameMangler::mangleUnscopedTemplateName(
+    const TemplateDecl *ND, const AbiTagList *AdditionalAbiTags) {
   //     <unscoped-template-name> ::= <unscoped-name>
   //                              ::= <substitution>
   if (mangleSubstitution(ND))
     return;
 
   // <template-template-param> ::= <template-param>
-  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(ND))
+  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(ND)) {
+    assert(!AdditionalAbiTags &&
+           "template template param cannot have abi tags");
     mangleTemplateParameter(TTP->getIndex());
-  else
-    mangleUnscopedName(ND->getTemplatedDecl());
+  } else {
+    mangleUnscopedName(ND->getTemplatedDecl(), AdditionalAbiTags);
+  }
 
   addSubstitution(ND);
 }
 
-void CXXNameMangler::mangleUnscopedTemplateName(TemplateName Template) {
+void CXXNameMangler::mangleUnscopedTemplateName(
+    TemplateName Template, const AbiTagList *AdditionalAbiTags) {
   //     <unscoped-template-name> ::= <unscoped-name>
   //                              ::= <substitution>
   if (TemplateDecl *TD = Template.getAsTemplateDecl())
-    return mangleUnscopedTemplateName(TD);
+    return mangleUnscopedTemplateName(TD, AdditionalAbiTags);
   
   if (mangleSubstitution(Template))
     return;
 
+  assert(!AdditionalAbiTags &&
+         "dependent template name cannot have abi tags");
+
   DependentTemplateName *Dependent = Template.getAsDependentTemplateName();
   assert(Dependent && "Not a dependent template name?");
   if (const IdentifierInfo *Id = Dependent->getIdentifier())
     mangleSourceName(Id);
   else
     mangleOperatorName(Dependent->getOperator(), UnknownArity);
-  
+
   addSubstitution(Template);
 }
 
@@ -841,14 +1104,16 @@
     else
       Out << "sr";
     mangleSourceName(qualifier->getAsNamespace()->getIdentifier());
+    writeAbiTags(qualifier->getAsNamespace());
     break;
   case NestedNameSpecifier::NamespaceAlias:
     if (qualifier->getPrefix())
       mangleUnresolvedPrefix(qualifier->getPrefix(),
                              /*recursive*/ true);
     else
       Out << "sr";
     mangleSourceName(qualifier->getAsNamespaceAlias()->getIdentifier());
+    writeAbiTags(qualifier->getAsNamespaceAlias());
     break;
 
   case NestedNameSpecifier::TypeSpec:
@@ -883,6 +1148,7 @@
       Out << "sr";
 
     mangleSourceName(qualifier->getAsIdentifier());
+    // an Identifier has no type information, so we can't emit abi tags for it
     break;
   }
 
@@ -928,7 +1194,8 @@
 
 void CXXNameMangler::mangleUnqualifiedName(const NamedDecl *ND,
                                            DeclarationName Name,
-                                           unsigned KnownArity) {
+                                           unsigned KnownArity,
+                                           const AbiTagList *AdditionalAbiTags) {
   unsigned Arity = KnownArity;
   //  <unqualified-name> ::= <operator-name>
   //                     ::= <ctor-dtor-name>
@@ -947,6 +1214,7 @@
         Out << 'L';
 
       mangleSourceName(II);
+      writeAbiTags(ND, AdditionalAbiTags);
       break;
     }
 
@@ -986,6 +1254,7 @@
       assert(FD->getIdentifier() && "Data member name isn't an identifier!");
 
       mangleSourceName(FD->getIdentifier());
+      // Not emitting abi tags: internal name anyway
       break;
     }
 
@@ -1006,6 +1275,10 @@
       assert(D->getDeclName().getAsIdentifierInfo() &&
              "Typedef was not named!");
       mangleSourceName(D->getDeclName().getAsIdentifierInfo());
+      assert(!AdditionalAbiTags && "Type cannot have additional abi tags");
+      // explicit abi tags are still possible; take from underlying type, not
+      // from typedef.
+      writeAbiTags(TD, nullptr);
       break;
     }
 
@@ -1015,6 +1288,8 @@
     // <lambda-sig> ::= <parameter-type>+   # Parameter types or 'v' for 'void'.
     if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(TD)) {
       if (Record->isLambda() && Record->getLambdaManglingNumber()) {
+        assert(!AdditionalAbiTags &&
+               "Lambda type cannot have additional abi tags");
         mangleLambda(Record);
         break;
       }
@@ -1026,11 +1301,13 @@
       if (UnnamedMangle > 1)
         Out << UnnamedMangle - 2;
       Out << '_';
+      writeAbiTags(TD, AdditionalAbiTags);
       break;
     }
 
-    // Get a unique id for the anonymous struct.
-    unsigned AnonStructId = Context.getAnonymousStructId(TD);
+    // Get a unique id for the anonymous struct. If it is not a real output
+    // ID doesn't matter so use fake one.
+    unsigned AnonStructId = NullOut ? 0 : Context.getAnonymousStructId(TD);
 
     // Mangle it as a source name in the form
     // [n] $_<id>
@@ -1058,6 +1335,7 @@
       // Otherwise, use the complete constructor name. This is relevant if a
       // class with a constructor is declared within a constructor.
       mangleCXXCtorType(Ctor_Complete);
+    writeAbiTags(ND, AdditionalAbiTags);
     break;
 
   case DeclarationName::CXXDestructorName:
@@ -1069,6 +1347,7 @@
       // Otherwise, use the complete destructor name. This is relevant if a
       // class with a destructor is declared within a destructor.
       mangleCXXDtorType(Dtor_Complete);
+    writeAbiTags(ND, AdditionalAbiTags);
     break;
 
   case DeclarationName::CXXOperatorName:
@@ -1084,6 +1363,7 @@
   case DeclarationName::CXXConversionFunctionName:
   case DeclarationName::CXXLiteralOperatorName:
     mangleOperatorName(Name, Arity);
+    writeAbiTags(ND, AdditionalAbiTags);
     break;
 
   case DeclarationName::CXXUsingDirective:
@@ -1100,7 +1380,9 @@
 
 void CXXNameMangler::mangleNestedName(const NamedDecl *ND,
                                       const DeclContext *DC,
-                                      bool NoFunction) {
+                                      const AbiTagList *AdditionalAbiTags,
+                                      bool NoFunction,
+                                      bool ExcludeUnqualifiedName) {
   // <nested-name> 
   //   ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix> <unqualified-name> E
   //   ::= N [<CV-qualifiers>] [<ref-qualifier>] <template-prefix> 
@@ -1120,30 +1402,36 @@
   // Check if we have a template.
   const TemplateArgumentList *TemplateArgs = nullptr;
   if (const TemplateDecl *TD = isTemplate(ND, TemplateArgs)) {
-    mangleTemplatePrefix(TD, NoFunction);
+    mangleTemplatePrefix(TD, AdditionalAbiTags, NoFunction,
+                         ExcludeUnqualifiedName);
     mangleTemplateArgs(*TemplateArgs);
   }
   else {
     manglePrefix(DC, NoFunction);
-    mangleUnqualifiedName(ND);
+    if (!ExcludeUnqualifiedName)
+      mangleUnqualifiedName(ND, AdditionalAbiTags);
   }
 
   Out << 'E';
 }
 void CXXNameMangler::mangleNestedName(const TemplateDecl *TD,
+                                      const AbiTagList *AdditionalAbiTags,
+                                      bool ExcludeUnqualifiedName,
                                       const TemplateArgument *TemplateArgs,
                                       unsigned NumTemplateArgs) {
   // <nested-name> ::= N [<CV-qualifiers>] <template-prefix> <template-args> E
 
   Out << 'N';
 
-  mangleTemplatePrefix(TD);
+  mangleTemplatePrefix(TD, AdditionalAbiTags, ExcludeUnqualifiedName);
   mangleTemplateArgs(TemplateArgs, NumTemplateArgs);
 
   Out << 'E';
 }
 
-void CXXNameMangler::mangleLocalName(const Decl *D) {
+void CXXNameMangler::mangleLocalName(const Decl *D,
+                                     const AbiTagList *AdditionalAbiTags,
+                                     bool ExcludeUnqualifiedName) {
   // <local-name> := Z <function encoding> E <entity name> [<discriminator>]
   //              := Z <function encoding> E s [<discriminator>]
   // <local-name> := Z <function encoding> E d [ <parameter number> ] 
@@ -1155,15 +1443,26 @@
 
   Out << 'Z';
 
-  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(DC))
-    mangleObjCMethodName(MD);
-  else if (const BlockDecl *BD = dyn_cast<BlockDecl>(DC))
-    mangleBlockForPrefix(BD);
-  else
-    mangleFunctionEncoding(cast<FunctionDecl>(DC));
+  {
+    AbiTagState localAbiTags(AbiTags);
+
+    if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(DC))
+      mangleObjCMethodName(MD);
+    else if (const BlockDecl *BD = dyn_cast<BlockDecl>(DC))
+      mangleBlockForPrefix(BD);
+    else
+      mangleFunctionEncoding(cast<FunctionDecl>(DC));
+
+    // Implicit ABI tags (from namespace) are not available in the following
+    // entity; reset to actually emitted tags, which are available.
+    localAbiTags.setUsedAbiTags(localAbiTags.getEmittedAbiTags());
+  }
 
   Out << 'E';
 
+  // GCC 5.3.0 doesn't emit derived abi tags for but that seems to be a bug
+  // that is fixed in trunk.
+
   if (RD) {
     // The parameter number is omitted for the last parameter, 0 for the 
     // second-to-last parameter, 1 for the third-to-last parameter, etc. The 
@@ -1188,13 +1487,17 @@
     // Mangle the name relative to the closest enclosing function.
     // equality ok because RD derived from ND above
     if (D == RD)  {
-      mangleUnqualifiedName(RD);
+      if (!ExcludeUnqualifiedName)
+        mangleUnqualifiedName(RD, AdditionalAbiTags);
     } else if (const BlockDecl *BD = dyn_cast<BlockDecl>(D)) {
       manglePrefix(getEffectiveDeclContext(BD), true /*NoFunction*/);
-      mangleUnqualifiedBlock(BD);
+      assert(!AdditionalAbiTags && "Block cannot have additional abi tags");
+      if (!ExcludeUnqualifiedName)
+        mangleUnqualifiedBlock(BD);
     } else {
       const NamedDecl *ND = cast<NamedDecl>(D);
-      mangleNestedName(ND, getEffectiveDeclContext(ND), true /*NoFunction*/);
+      mangleNestedName(ND, getEffectiveDeclContext(ND), AdditionalAbiTags,
+                       true /*NoFunction*/, ExcludeUnqualifiedName);
     }
   } else if (const BlockDecl *BD = dyn_cast<BlockDecl>(D)) {
     // Mangle a block in a default parameter; see above explanation for
@@ -1211,30 +1514,37 @@
       }
     }
 
-    mangleUnqualifiedBlock(BD);
+    assert(!AdditionalAbiTags && "Block cannot have additional abi tags");
+    if (!ExcludeUnqualifiedName)
+      mangleUnqualifiedBlock(BD);
   } else {
-    mangleUnqualifiedName(cast<NamedDecl>(D));
-  }
-
-  if (const NamedDecl *ND = dyn_cast<NamedDecl>(RD ? RD : D)) {
-    unsigned disc;
-    if (Context.getNextDiscriminator(ND, disc)) {
-      if (disc < 10)
-        Out << '_' << disc;
-      else
-        Out << "__" << disc << '_';
+    if (!ExcludeUnqualifiedName)
+      mangleUnqualifiedName(cast<NamedDecl>(D), AdditionalAbiTags);
+  }
+
+  if (!ExcludeUnqualifiedName) {
+    if (const NamedDecl *ND = dyn_cast<NamedDecl>(RD ? RD : D)) {
+      unsigned disc;
+      if (Context.getNextDiscriminator(ND, disc)) {
+        if (disc < 10)
+          Out << '_' << disc;
+        else
+          Out << "__" << disc << '_';
+      }
     }
   }
 }
 
 void CXXNameMangler::mangleBlockForPrefix(const BlockDecl *Block) {
   if (GetLocalClassDecl(Block)) {
-    mangleLocalName(Block);
+    mangleLocalName(Block, /* AdditionalAbiTags */ nullptr,
+                    /* ExcludeUnqualifiedName */ false);
     return;
   }
   const DeclContext *DC = getEffectiveDeclContext(Block);
   if (isLocalContainerContext(DC)) {
-    mangleLocalName(Block);
+    mangleLocalName(Block, /* AdditionalAbiTags */ nullptr,
+                    /* ExcludeUnqualifiedName */ false);
     return;
   }
   manglePrefix(getEffectiveDeclContext(Block));
@@ -1245,10 +1555,11 @@
   if (Decl *Context = Block->getBlockManglingContextDecl()) {
     if ((isa<VarDecl>(Context) || isa<FieldDecl>(Context)) &&
         Context->getDeclContext()->isRecord()) {
-      if (const IdentifierInfo *Name
-            = cast<NamedDecl>(Context)->getIdentifier()) {
+      const auto *ND = cast<NamedDecl>(Context);
+      if (const IdentifierInfo *Name = ND->getIdentifier()) {
         mangleSourceName(Name);
-        Out << 'M';            
+        writeAbiTags(ND, /* AdditionalAbiTags */ nullptr);
+        Out << 'M';
       }
     }
   }
@@ -1281,7 +1592,7 @@
       if (const IdentifierInfo *Name
             = cast<NamedDecl>(Context)->getIdentifier()) {
         mangleSourceName(Name);
-        Out << 'M';            
+        Out << 'M';
       }
     }
   }
@@ -1364,11 +1675,11 @@
   // Check if we have a template.
   const TemplateArgumentList *TemplateArgs = nullptr;
   if (const TemplateDecl *TD = isTemplate(ND, TemplateArgs)) {
-    mangleTemplatePrefix(TD);
+    mangleTemplatePrefix(TD, /* AdditionalAbiTags */ nullptr);
     mangleTemplateArgs(*TemplateArgs);
   } else {
     manglePrefix(getEffectiveDeclContext(ND), NoFunction);
-    mangleUnqualifiedName(ND);
+    mangleUnqualifiedName(ND, /* AdditionalAbiTags */ nullptr);
   }
 
   addSubstitution(ND);
@@ -1379,27 +1690,30 @@
   //                   ::= <template-param>
   //                   ::= <substitution>
   if (TemplateDecl *TD = Template.getAsTemplateDecl())
-    return mangleTemplatePrefix(TD);
+    return mangleTemplatePrefix(TD, /* AdditionalAbiTags */ nullptr);
 
   if (QualifiedTemplateName *Qualified = Template.getAsQualifiedTemplateName())
     manglePrefix(Qualified->getQualifier());
-  
+
   if (OverloadedTemplateStorage *Overloaded
                                       = Template.getAsOverloadedTemplate()) {
     mangleUnqualifiedName(nullptr, (*Overloaded->begin())->getDeclName(),
-                          UnknownArity);
+                          UnknownArity,
+                          /* AdditionalAbiTags */ nullptr);
     return;
   }
-   
+
   DependentTemplateName *Dependent = Template.getAsDependentTemplateName();
   assert(Dependent && "Unknown template name kind?");
   if (NestedNameSpecifier *Qualifier = Dependent->getQualifier())
     manglePrefix(Qualifier);
-  mangleUnscopedTemplateName(Template);
+  mangleUnscopedTemplateName(Template, /* AdditionalAbiTags */ nullptr);
 }
 
 void CXXNameMangler::mangleTemplatePrefix(const TemplateDecl *ND,
-                                          bool NoFunction) {
+                                          const AbiTagList *AdditionalAbiTags,
+                                          bool NoFunction,
+                                          bool ExcludeUnqualifiedName) {
   // <template-prefix> ::= <prefix> <template unqualified-name>
   //                   ::= <template-param>
   //                   ::= <substitution>
@@ -1414,7 +1728,8 @@
     mangleTemplateParameter(TTP->getIndex());
   } else {
     manglePrefix(getEffectiveDeclContext(ND), NoFunction);
-    mangleUnqualifiedName(ND->getTemplatedDecl());
+    if (!ExcludeUnqualifiedName)
+      mangleUnqualifiedName(ND->getTemplatedDecl(), AdditionalAbiTags);
   }
 
   addSubstitution(ND);
@@ -1458,6 +1773,7 @@
     // <name> ::= <nested-name>
     mangleUnresolvedPrefix(Dependent->getQualifier());
     mangleSourceName(Dependent->getIdentifier());
+     // writeAbiTags(Dependent);
     break;
   }
 
@@ -1550,16 +1866,19 @@
 
   case Type::Typedef:
     mangleSourceName(cast<TypedefType>(Ty)->getDecl()->getIdentifier());
+    writeAbiTags(cast<TypedefType>(Ty)->getDecl());
     break;
 
   case Type::UnresolvedUsing:
     mangleSourceName(
         cast<UnresolvedUsingType>(Ty)->getDecl()->getIdentifier());
+    writeAbiTags(cast<UnresolvedUsingType>(Ty)->getDecl());
     break;
 
   case Type::Enum:
   case Type::Record:
     mangleSourceName(cast<TagType>(Ty)->getDecl()->getIdentifier());
+    writeAbiTags(cast<TagType>(Ty)->getDecl());
     break;
 
   case Type::TemplateSpecialization: {
@@ -1578,6 +1897,7 @@
         goto unresolvedType;
 
       mangleSourceName(TD->getIdentifier());
+      writeAbiTags(TD);
       break;
     }
 
@@ -1609,16 +1929,19 @@
   case Type::InjectedClassName:
     mangleSourceName(
         cast<InjectedClassNameType>(Ty)->getDecl()->getIdentifier());
+    writeAbiTags(cast<InjectedClassNameType>(Ty)->getDecl());
     break;
 
   case Type::DependentName:
     mangleSourceName(cast<DependentNameType>(Ty)->getIdentifier());
+    // writeAbiTags(cast<DependentNameType>(Ty));
     break;
 
   case Type::DependentTemplateSpecialization: {
     const DependentTemplateSpecializationType *DTST =
         cast<DependentTemplateSpecializationType>(Ty);
     mangleSourceName(DTST->getIdentifier());
+    // writeAbiTags(DTST);
     mangleTemplateArgs(DTST->getArgs(), DTST->getNumArgs());
     break;
   }
@@ -2081,7 +2404,9 @@
   case BuiltinType::Id:
 #include "clang/AST/BuiltinTypes.def"
   case BuiltinType::Dependent:
-    llvm_unreachable("mangling a placeholder type");
+    if (!NullOut)
+      llvm_unreachable("mangling a placeholder type");
+    break;
   case BuiltinType::ObjCId:
     Out << "11objc_object";
     break;
@@ -2641,7 +2966,11 @@
 
 void CXXNameMangler::mangleType(const TemplateSpecializationType *T) {
   if (TemplateDecl *TD = T->getTemplateName().getAsTemplateDecl()) {
-    mangleName(TD, T->getArgs(), T->getNumArgs());
+    // types only have explicit abi tags, no addition tags
+    mangleTemplateName(TD,
+                       /* AdditionalAbiTags */ nullptr,
+                       /* ExcludeUnqualifiedName */ false,
+                       T->getArgs(), T->getNumArgs());
   } else {
     if (mangleSubstitution(QualType(T, 0)))
       return;
@@ -2967,12 +3296,14 @@
   case Expr::PseudoObjectExprClass:
   case Expr::AtomicExprClass:
   {
-    // As bad as this diagnostic is, it's better than crashing.
-    DiagnosticsEngine &Diags = Context.getDiags();
-    unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
-                                     "cannot yet mangle expression type %0");
-    Diags.Report(E->getExprLoc(), DiagID)
-      << E->getStmtClassName() << E->getSourceRange();
+    if (!NullOut) {
+      // As bad as this diagnostic is, it's better than crashing.
+      DiagnosticsEngine &Diags = Context.getDiags();
+      unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
+                                       "cannot yet mangle expression type %0");
+      Diags.Report(E->getExprLoc(), DiagID)
+        << E->getStmtClassName() << E->getSourceRange();
+    }
     break;
   }
 
@@ -4115,6 +4446,97 @@
   Substitutions[Ptr] = SeqID++;
 }
 
+std::set<StringRef>
+CXXNameMangler::getTagsFromPrefixAndTemplateArguments(const NamedDecl *ND) {
+  llvm::raw_null_ostream NullOutStream;
+  CXXNameMangler TrackPrefixAndTemplateArguments(*this, NullOutStream);
+
+  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(ND)) {
+    TrackPrefixAndTemplateArguments.mangleFunctionEncoding(
+        FD, /* ExcludeUnqualifiedName */ true);
+  } else {
+    TrackPrefixAndTemplateArguments.mangleName(
+        ND, /* ExcludeUnqualifiedName */ true);
+  }
+
+  return std::move(
+      TrackPrefixAndTemplateArguments.AbiTagsRoot.getUsedAbiTags());
+}
+
+CXXNameMangler::AbiTagList
+CXXNameMangler::makeAdditionalTagsForFunction(const FunctionDecl *FD) {
+  // when derived abi tags are disabled there is no need to make any list
+  if (DisableDerivedAbiTags)
+    return AbiTagList();
+
+  std::set<StringRef> ImplicitlyAvailableTags =
+      getTagsFromPrefixAndTemplateArguments(FD);
+  std::set<StringRef> ReturnTypeTags;
+
+  {
+    llvm::raw_null_ostream NullOutStream;
+    CXXNameMangler TrackReturnTypeTags(*this, NullOutStream);
+    TrackReturnTypeTags.disableDerivedAbiTags();
+
+    const FunctionProtoType *Proto =
+        cast<FunctionProtoType>(FD->getType()->getAs<FunctionType>());
+    TrackReturnTypeTags.FunctionTypeDepth.enterResultType();
+    TrackReturnTypeTags.mangleType(Proto->getReturnType());
+    TrackReturnTypeTags.FunctionTypeDepth.leaveResultType();
+
+    ReturnTypeTags =
+        std::move(TrackReturnTypeTags.AbiTagsRoot.getUsedAbiTags());
+  }
+
+  AbiTagList AdditionalAbiTags;
+
+  for (const auto &Tag : ReturnTypeTags) {
+    if (ImplicitlyAvailableTags.count(Tag) == 0)
+      AdditionalAbiTags.push_back(Tag);
+  }
+
+  return AdditionalAbiTags;
+}
+
+CXXNameMangler::AbiTagList
+CXXNameMangler::makeAdditionalTagsForVariable(const VarDecl *VD) {
+  // when derived abi tags are disabled there is no need to make any list
+  if (DisableDerivedAbiTags)
+    return AbiTagList();
+
+  std::set<StringRef> ImplicitlyAvailableTags =
+      getTagsFromPrefixAndTemplateArguments(VD);
+  std::set<StringRef> VariableTypeTags;
+
+  {
+    llvm::raw_null_ostream NullOutStream;
+    CXXNameMangler TrackVariableType(*this, NullOutStream);
+    TrackVariableType.disableDerivedAbiTags();
+
+    TrackVariableType.mangleType(VD->getType());
+
+    VariableTypeTags =
+        std::move(TrackVariableType.AbiTagsRoot.getUsedAbiTags());
+  }
+
+  AbiTagList AdditionalAbiTags;
+
+  for (const auto &Tag : VariableTypeTags) {
+    if (ImplicitlyAvailableTags.count(Tag) == 0)
+      AdditionalAbiTags.push_back(Tag);
+  }
+
+  return AdditionalAbiTags;
+}
+
+bool CXXNameMangler::shouldHaveAbiTags(ItaniumMangleContextImpl &C,
+                                       const VarDecl *VD) {
+  llvm::raw_null_ostream NullOutStream;
+  CXXNameMangler TrackAbiTags(C, NullOutStream, nullptr, true);
+  TrackAbiTags.mangle(VD);
+  return TrackAbiTags.AbiTagsRoot.getUsedAbiTags().size();
+}
+
 //
 
 /// Mangles the name of the declaration D and emits that name to the given
@@ -4216,6 +4638,8 @@
   //  <special-name> ::= GV <object name>       # Guard variable for one-time
   //                                            # initialization
   CXXNameMangler Mangler(*this, Out);
+  // GCC 5.3.0 doesn't emit derived abi tags for but that seems to be a bug
+  // that is fixed in trunk.
   Mangler.getStream() << "_ZGV";
   Mangler.mangleName(D);
 }
Index: lib/Sema/SemaDeclAttr.cpp
===================================================================
--- lib/Sema/SemaDeclAttr.cpp
+++ lib/Sema/SemaDeclAttr.cpp
@@ -4667,10 +4667,6 @@
   D->addAttr(::new (S.Context)
              AbiTagAttr(Attr.getRange(), S.Context, Tags.data(), Tags.size(),
                         Attr.getAttributeSpellingListIndex()));
-
-  // FIXME: remove this warning as soon as mangled part is ready.
-  S.Diag(Attr.getRange().getBegin(), diag::warn_attribute_ignored)
-        << Attr.getName();
 }
 
 static void handleARMInterruptAttr(Sema &S, Decl *D,
Index: test/CodeGenCXX/mangle-abi-tag.cpp
===================================================================
--- /dev/null
+++ test/CodeGenCXX/mangle-abi-tag.cpp
@@ -0,0 +1,124 @@
+// RUN: %clang_cc1 %s -emit-llvm -triple %itanium_abi_triple -o - | FileCheck %s
+
+struct __attribute__((abi_tag("A", "B"))) A { };
+
+struct B: A { };
+
+template<class T>
+
+struct C {
+};
+
+struct D { A* p; };
+
+template<class T>
+struct __attribute__((abi_tag("C", "D"))) E {
+};
+
+struct __attribute__((abi_tag("A", "B"))) F { };
+
+A a1;
+// CHECK: @_Z2a1B1AB1B =
+
+__attribute__((abi_tag("C", "D")))
+A a2;
+// CHECK: @_Z2a2B1AB1BB1CB1D =
+
+B a3;
+// CHECK: @a3 =
+
+C<A> a4;
+// CHECK: @_Z2a4B1AB1B =
+
+D a5;
+// CHECK: @a5 =
+
+E<int> a6;
+// CHECK: @_Z2a6B1CB1D =
+
+E<A> a7;
+// CHECK: @_Z2a7B1AB1BB1CB1D =
+
+template<>
+struct E<float> {
+  static float a8;
+};
+float E<float>::a8;
+// CHECK: @_ZN1EB1CB1DIfE2a8E =
+
+template<>
+struct E<F> {
+  static bool a9;
+};
+bool E<F>::a9;
+// CHECK: @_ZN1EB1CB1DI1FB1AB1BE2a9E =
+
+struct __attribute__((abi_tag("A", "B"))) A10 {
+  virtual ~A10() {}
+} a10;
+// vtable
+// CHECK: @_ZTV3A10B1AB1B =
+// typeinfo
+// CHECK: @_ZTI3A10B1AB1B =
+
+// Local variables from f9.
+// f9()::L::foo[abi:C][abi:D]()::a[abi:A][abi:B]
+// CHECK-DAG: @_ZZZ2f9vEN1L3fooB1CB1DEvE1aB1AB1B =
+// guard variable for f9()::L::foo[abi:C][abi:D]()::a[abi:A][abi:B]
+// CHECK-DAG: @_ZGVZZ2f9vEN1L3fooB1CB1DEvE1aB1AB1B =
+
+__attribute__ ((abi_tag("C", "D")))
+void* f1() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f1B1CB1Dv(
+
+__attribute__ ((abi_tag("C", "D")))
+A* f2() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f2B1AB1BB1CB1Dv(
+
+B* f3() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f3v(
+
+C<A>* f4() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f4B1AB1Bv(
+
+D* f5() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f5v(
+
+E<char>* f6() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f6B1CB1Dv(
+
+E<A>* f7() {
+  return 0;
+}
+// CHECK: define {{.*}} @_Z2f7B1AB1BB1CB1Dv(
+
+void f8(E<A>*) {
+}
+// CHECK: define {{.*}} @_Z2f8P1EB1CB1DI1AB1AB1BE(
+
+inline void f9() {
+  struct L {
+    static E<int>* foo() {
+      static A10 a;
+      return 0;
+    }
+  };
+  L::foo();
+}
+void f9_test() {
+  f9();
+}
+// f9()::L::foo[abi:C][abi:D]()
+// CHECK: define linkonce_odr %struct.E* @_ZZ2f9vEN1L3fooB1CB1DEv(
Index: test/SemaCXX/attr-abi-tag-syntax.cpp
===================================================================
--- test/SemaCXX/attr-abi-tag-syntax.cpp
+++ test/SemaCXX/attr-abi-tag-syntax.cpp
@@ -16,28 +16,18 @@
 // expected-warning@-1 {{'abi_tag' attribute on anonymous namespace ignored}}
 
 inline namespace N __attribute__((__abi_tag__)) {}
-// FIXME: remove this warning as soon as attribute fully supported.
-// expected-warning@-2 {{'__abi_tag__' attribute ignored}}
 
 } // namespcace N2
 
 __attribute__((abi_tag("B", "A"))) extern int a1;
-// FIXME: remove this warning as soon as attribute fully supported.
-// expected-warning@-2 {{'abi_tag' attribute ignored}}
 
 __attribute__((abi_tag("A", "B"))) extern int a1;
 // expected-note@-1 {{previous declaration is here}}
-// FIXME: remove this warning as soon as attribute fully supported.
-// expected-warning@-3 {{'abi_tag' attribute ignored}}
 
 __attribute__((abi_tag("A", "C"))) extern int a1;
 // expected-error@-1 {{'abi_tag' C missing in original declaration}}
-// FIXME: remove this warning as soon as attribute fully supported.
-// expected-warning@-3 {{'abi_tag' attribute ignored}}
 
 extern int a2;
 // expected-note@-1 {{previous declaration is here}}
 __attribute__((abi_tag("A")))extern int a2;
 // expected-error@-1 {{cannot add 'abi_tag' attribute in a redeclaration}}
-// FIXME: remove this warning as soon as attribute fully supported.
-// expected-warning@-3 {{'abi_tag' attribute ignored}}
Index: test/SemaCXX/attr-abi-tag.cpp
===================================================================
--- /dev/null
+++ test/SemaCXX/attr-abi-tag.cpp
@@ -0,0 +1,13 @@
+// RUN: %clang_cc1 -x c++ -std=c++11 -triple x86_64-unknown-linux -emit-llvm < %s | FileCheck %s
+
+// CHECK: @_Z5Func1B6Names1v()
+inline namespace Names1 __attribute__((__abi_tag__)) {
+    class C1 {};
+}
+C1 Func1() { return C1(); }
+
+// CHECK: @_Z5Func2B4Tag1B4Tag2v()
+inline namespace Names2 __attribute__((__abi_tag__("Tag1", "Tag2"))) {
+    class C2 {};
+}
+C2 Func2() { return C2(); }
