commit ad7c51f24e2f4bcbef09edcb4fb6c266b565aa12
Author: Eggz <egnappah@gmail.com>
Date:   Fri Jan 26 21:24:36 2024 +0100

    AMD Pstate Driver Core Performance Boost
    
    Signed-off-by: Eggz <egnappah@gmail.com>

diff --git a/Documentation/admin-guide/pm/amd-pstate.rst b/Documentation/admin-guide/pm/amd-pstate.rst
index 1cf40f69278c..6c05f321ed0f 100644
--- a/Documentation/admin-guide/pm/amd-pstate.rst
+++ b/Documentation/admin-guide/pm/amd-pstate.rst
@@ -385,6 +385,18 @@ control its functionality at the system level.  They are located in the
         to the operation mode represented by that string - or to be
         unregistered in the "disable" case.
 
+``cpb_boost``
+        Specifies whether core performance boost is requested to be enabled or disabled
+        If core performance boost is disabled while a core is in a boosted P-state, the
+        core automatically transitions to the highest performance non-boosted P-state.
+        AMD Core Performance Boost(CPB) is controlled by this new attribute file which
+        allow user to change all cores frequency boosting state. It supports both
+        ``active mode`` and ``passive mode`` control with below value write to it.
+
+        "0" Disable Core performance Boosting
+        "1" Enable  Core performance Boosting
+
+
 ``cpupower`` tool support for ``amd-pstate``
 ===============================================
 
diff --git a/drivers/cpufreq/amd-pstate.c b/drivers/cpufreq/amd-pstate.c
index 1f6186475715..f91434b33ed1 100644
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@ -65,6 +65,19 @@ static struct cpufreq_driver amd_pstate_epp_driver;
 static int cppc_state = AMD_PSTATE_UNDEFINED;
 static bool cppc_enabled;
 
+/**
+ * struct global_params - Global parameters, mostly tunable via sysfs.
+ * @cpb_boost:         Whether or not to use boost CPU P-states.
+ * @cpb_supported:     Whether or not CPU boost P-states are available
+ *                     based on the MSR_K7_HWCR bit[25] state
+ */
+struct global_params {
+       bool cpb_boost;
+       bool cpb_supported;
+};
+
+static struct global_params global;
+
 /*
  * AMD Energy Preference Performance (EPP)
  * The EPP is used in the CCLK DPM controller to drive
@@ -431,6 +444,7 @@ static void amd_pstate_update(struct amd_cpudata *cpudata, u32 min_perf,
 			      u32 des_perf, u32 max_perf, bool fast_switch, int gov_flags)
 {
 	u64 prev = READ_ONCE(cpudata->cppc_req_cached);
+        u64 nominal_perf = READ_ONCE(cpudata->nominal_perf);
 	u64 value = prev;
 
 	min_perf = clamp_t(unsigned long, min_perf, cpudata->min_limit_perf,
@@ -450,6 +464,11 @@ static void amd_pstate_update(struct amd_cpudata *cpudata, u32 min_perf,
 	value &= ~AMD_CPPC_DES_PERF(~0L);
 	value |= AMD_CPPC_DES_PERF(des_perf);
 
+        /* limit the max perf when core performance boost feature is disabled */
+        if (!global.cpb_boost)
+                max_perf = min_t(unsigned long, nominal_perf, max_perf);
+
+
 	value &= ~AMD_CPPC_MAX_PERF(~0L);
 	value |= AMD_CPPC_MAX_PERF(max_perf);
 
@@ -616,6 +635,11 @@ static int amd_get_max_freq(struct amd_cpudata *cpudata)
 	nominal_perf = READ_ONCE(cpudata->nominal_perf);
 	max_perf = READ_ONCE(cpudata->highest_perf);
 
+        /* when boost is off, the highest perf will be limited to nominal_perf */
+        if (!global.cpb_boost)
+                max_perf = nominal_perf;
+
+
 	boost_ratio = div_u64(max_perf << SCHED_CAPACITY_SHIFT,
 			      nominal_perf);
 
@@ -662,43 +686,29 @@ static int amd_get_lowest_nonlinear_freq(struct amd_cpudata *cpudata)
 	return lowest_nonlinear_freq * 1000;
 }
 
-static int amd_pstate_set_boost(struct cpufreq_policy *policy, int state)
+static int amd_pstate_boost_init(struct amd_cpudata *cpudata)
 {
-	struct amd_cpudata *cpudata = policy->driver_data;
-	int ret;
+        u64 boost_state, boost_val;
+        int ret;
 
-	if (!cpudata->boost_supported) {
-		pr_err("Boost mode is not supported by this processor or SBIOS\n");
-		return -EINVAL;
-	}
 
-	if (state)
-		policy->cpuinfo.max_freq = cpudata->max_freq;
-	else
-		policy->cpuinfo.max_freq = cpudata->nominal_freq;
+        ret = rdmsrl_on_cpu(cpudata->cpu, MSR_K7_HWCR, &boost_val);
+        if (ret) {
+                pr_err_once("failed to read initial CPU boost state!\n");
+                return ret;
+        }
 
-	policy->max = policy->cpuinfo.max_freq;
 
-	ret = freq_qos_update_request(&cpudata->req[1],
-				      policy->cpuinfo.max_freq);
-	if (ret < 0)
-		return ret;
+        boost_state = (boost_val >> 25) & 0x1;
+        if (!boost_state) {
+                global.cpb_supported = true;
+                global.cpb_boost = true;
+        } else {
+                global.cpb_supported = false;
+                global.cpb_boost = false;
+        }
 
-	return 0;
-}
-
-static void amd_pstate_boost_init(struct amd_cpudata *cpudata)
-{
-	u32 highest_perf, nominal_perf;
-
-	highest_perf = READ_ONCE(cpudata->highest_perf);
-	nominal_perf = READ_ONCE(cpudata->nominal_perf);
-
-	if (highest_perf <= nominal_perf)
-		return;
-
-	cpudata->boost_supported = true;
-	current_pstate_driver->boost_enabled = true;
+        return ret;
 }
 
 static void amd_perf_ctl_reset(unsigned int cpu)
@@ -731,6 +741,11 @@ static int amd_pstate_cpu_init(struct cpufreq_policy *policy)
 	if (ret)
 		goto free_cpudata1;
 
+        /* initialize cpu cores boot state */
+        amd_pstate_boost_init(cpudata);
+
+
+
 	min_freq = amd_get_min_freq(cpudata);
 	max_freq = amd_get_max_freq(cpudata);
 	nominal_freq = amd_get_nominal_freq(cpudata);
@@ -782,7 +797,6 @@ static int amd_pstate_cpu_init(struct cpufreq_policy *policy)
 
 	policy->driver_data = cpudata;
 
-	amd_pstate_boost_init(cpudata);
 	if (!current_pstate_driver->adjust_perf)
 		current_pstate_driver->adjust_perf = amd_pstate_adjust_perf;
 
@@ -809,23 +823,61 @@ static int amd_pstate_cpu_exit(struct cpufreq_policy *policy)
 
 static int amd_pstate_cpu_resume(struct cpufreq_policy *policy)
 {
+        struct cppc_perf_ctrls perf_ctrls;
+        struct amd_cpudata *cpudata = policy->driver_data;
+        u64 value, max_perf;
 	int ret;
 
-	ret = amd_pstate_enable(true);
-	if (ret)
-		pr_err("failed to enable amd-pstate during resume, return %d\n", ret);
+        if (cpudata->suspended) {
+               mutex_lock(&amd_pstate_driver_lock);
 
-	return ret;
+               ret = amd_pstate_enable(true);
+               if (ret) {
+                       pr_err("failed to enable amd-pstate during resume, return %d\n", ret);
+                       mutex_unlock(&amd_pstate_driver_lock);
+                       return ret;
+               }
+
+               value = READ_ONCE(cpudata->cppc_req_cached);
+               max_perf = READ_ONCE(cpudata->highest_perf);
+
+               if (boot_cpu_has(X86_FEATURE_CPPC)) {
+                       wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+               } else {
+                       perf_ctrls.max_perf = max_perf;
+                       cppc_set_perf(cpudata->cpu, &perf_ctrls);
+               }
+
+               cpudata->suspended = false;
+               mutex_unlock(&amd_pstate_driver_lock);
+       }
+
+       return 0;
 }
 
 static int amd_pstate_cpu_suspend(struct cpufreq_policy *policy)
 {
+        struct amd_cpudata *cpudata = policy->driver_data;
 	int ret;
 
+        /* avoid suspending when EPP is not enabled */
+        if (cppc_state != AMD_PSTATE_PASSIVE)
+                return 0;
+
+        mutex_lock(&amd_pstate_driver_lock);
+
+        /* set this flag to avoid calling core offline function
+         * when system is suspending, use this flag to skip offline function
+         * called
+         */
+        cpudata->suspended = true;
+
 	ret = amd_pstate_enable(false);
 	if (ret)
 		pr_err("failed to disable amd-pstate during suspend, return %d\n", ret);
 
+        mutex_unlock(&amd_pstate_driver_lock);
+
 	return ret;
 }
 
@@ -1074,6 +1126,102 @@ static ssize_t status_store(struct device *a, struct device_attribute *b,
 	return ret < 0 ? ret : count;
 }
 
+static int amd_cpu_boost_update(struct amd_cpudata *cpudata, u32 on)
+{
+        struct cpufreq_policy *policy = cpufreq_cpu_acquire(cpudata->cpu);
+        struct cppc_perf_ctrls perf_ctrls;
+        u32 highest_perf, nominal_perf;
+        int ret;
+
+        if (!policy)
+                return -ENODATA;
+
+        highest_perf = READ_ONCE(cpudata->highest_perf);
+        nominal_perf = READ_ONCE(cpudata->nominal_perf);
+
+        if (boot_cpu_has(X86_FEATURE_CPPC)) {
+                u64 value = READ_ONCE(cpudata->cppc_req_cached);
+
+                value &= ~GENMASK_ULL(7, 0);
+                value |= on ? highest_perf : nominal_perf;
+                WRITE_ONCE(cpudata->cppc_req_cached, value);
+
+                wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+
+        } else {
+                perf_ctrls.max_perf = on ? highest_perf : nominal_perf;
+                ret = cppc_set_epp_perf(cpudata->cpu, &perf_ctrls, 1);
+                if (ret) {
+                        pr_debug("failed to set energy perf value (%d)\n", ret);
+                        return ret;
+                }
+        }
+
+        if (on)
+                policy->cpuinfo.max_freq = cpudata->max_freq;
+        else
+                policy->cpuinfo.max_freq = cpudata->nominal_freq;
+
+        policy->max = policy->cpuinfo.max_freq;
+
+        if (cppc_state == AMD_PSTATE_PASSIVE) {
+                ret = freq_qos_update_request(&cpudata->req[1],
+                                      policy->cpuinfo.max_freq);
+        }
+
+        cpufreq_cpu_release(policy);
+
+        return ret;
+}
+
+static ssize_t cpb_boost_show(struct device *dev,
+                           struct device_attribute *attr, char *buf)
+{
+        return sysfs_emit(buf, "%u\n", global.cpb_boost);
+}
+
+static ssize_t cpb_boost_store(struct device *dev, struct device_attribute *b,
+                            const char *buf, size_t count)
+{
+        bool new_state;
+        ssize_t ret;
+        int cpu;
+
+        mutex_lock(&amd_pstate_driver_lock);
+        if (!global.cpb_supported) {
+                pr_err("Boost mode is not supported by this processor or SBIOS\n");
+                return -EINVAL;
+        }
+
+        ret = kstrtobool(buf, &new_state);
+        if (ret)
+                return -EINVAL;
+
+        global.cpb_boost = !!new_state;
+
+        for_each_possible_cpu(cpu) {
+
+                struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+                struct amd_cpudata *cpudata = policy->driver_data;
+
+                if (!cpudata) {
+                        pr_err("cpudata is NULL\n");
+                        ret = -ENODATA;
+                        cpufreq_cpu_put(policy);
+                        goto err_exit;
+                }
+
+                amd_cpu_boost_update(cpudata, global.cpb_boost);
+                refresh_frequency_limits(policy);
+                cpufreq_cpu_put(policy);
+        }
+
+err_exit:
+        mutex_unlock(&amd_pstate_driver_lock);
+        return ret < 0 ? ret : count;
+}
+
+
 cpufreq_freq_attr_ro(amd_pstate_max_freq);
 cpufreq_freq_attr_ro(amd_pstate_lowest_nonlinear_freq);
 
@@ -1081,6 +1229,7 @@ cpufreq_freq_attr_ro(amd_pstate_highest_perf);
 cpufreq_freq_attr_rw(energy_performance_preference);
 cpufreq_freq_attr_ro(energy_performance_available_preferences);
 static DEVICE_ATTR_RW(status);
+static DEVICE_ATTR_RW(cpb_boost);
 
 static struct freq_attr *amd_pstate_attr[] = {
 	&amd_pstate_max_freq,
@@ -1100,6 +1249,7 @@ static struct freq_attr *amd_pstate_epp_attr[] = {
 
 static struct attribute *pstate_global_attributes[] = {
 	&dev_attr_status.attr,
+        &dev_attr_cpb_boost.attr,
 	NULL
 };
 
@@ -1155,6 +1305,9 @@ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
 	if (ret)
 		goto free_cpudata1;
 
+        /* initialize cpu cores boot state */
+        amd_pstate_boost_init(cpudata);
+
 	min_freq = amd_get_min_freq(cpudata);
 	max_freq = amd_get_max_freq(cpudata);
 	nominal_freq = amd_get_nominal_freq(cpudata);
@@ -1205,7 +1358,6 @@ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
 			return ret;
 		WRITE_ONCE(cpudata->cppc_cap1_cached, value);
 	}
-	amd_pstate_boost_init(cpudata);
 
 	return 0;
 
@@ -1394,7 +1546,7 @@ static int amd_pstate_epp_suspend(struct cpufreq_policy *policy)
 	if (cppc_state != AMD_PSTATE_ACTIVE)
 		return 0;
 
-	/* set this flag to avoid setting core offline*/
+	/* set this flag to avoid setting core offline */
 	cpudata->suspended = true;
 
 	/* disable CPPC in lowlevel firmware */
@@ -1432,7 +1584,6 @@ static struct cpufreq_driver amd_pstate_driver = {
 	.exit		= amd_pstate_cpu_exit,
 	.suspend	= amd_pstate_cpu_suspend,
 	.resume		= amd_pstate_cpu_resume,
-	.set_boost	= amd_pstate_set_boost,
 	.name		= "amd-pstate",
 	.attr		= amd_pstate_attr,
 };
diff --git a/include/linux/amd-pstate.h b/include/linux/amd-pstate.h
index 6ad02ad9c7b4..a1f31ecdc5bd 100644
--- a/include/linux/amd-pstate.h
+++ b/include/linux/amd-pstate.h
@@ -84,7 +84,6 @@ struct amd_cpudata {
 	struct amd_aperf_mperf prev;
 
 	u64	freq;
-	bool	boost_supported;
 
 	/* EPP feature related attributes*/
 	s16	epp_policy;
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
