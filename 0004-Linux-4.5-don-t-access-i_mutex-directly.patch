From 60b36c98188a786f1ba71f0e2b0a1b8f7ff0ba2c Mon Sep 17 00:00:00 2001
From: Benjamin Kaduk <kaduk@mit.edu>
Date: Sun, 1 May 2016 19:48:40 -0400
Subject: [PATCH 4/5] Linux 4.5: don't access i_mutex directly

Linux commit 5955102c, in preparation for future work, introduced
wrapper functions to lock/unlock inode mutexes.  This is to
prepare for converting it to a read-write semaphore, so that
lookup can be done with only the shared lock held.

Adopt the afs_linux_*lock_inode() functions accordingly, and
convert afs_linux_fsync() to using those wrappers, since the
FOP_FSYNC_TAKES_RANGE case appears to be the current case.

Amusingly, afs_linux_*lock_inode() already have a branch to
handle the case when inode serialization is protected by a
semaphore; it seems that this is going to come full-circle.

Change-Id: Ia5a194acc559de21808655ef066151a0a3826364
---
 acinclude.m4                 | 3 +++
 src/afs/LINUX/osi_compat.h   | 8 ++++++--
 src/afs/LINUX/osi_vnodeops.c | 4 ++--
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/acinclude.m4 b/acinclude.m4
index aca1316..aa682ea 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -1041,6 +1041,9 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_FUNC([inode_nohighmem],
 				     [#include <linux/fs.h>],
 				     [inode_nohighmem(NULL);])
+		 AC_CHECK_LINUX_FUNC([inode_lock],
+				     [#include <linux/fs.h>],
+				     [inode_lock(NULL);])
 
 		 dnl Consequences - things which get set as a result of the
 		 dnl                above tests
diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 4d484c1..5268e7e 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -427,7 +427,9 @@ afs_init_sb_export_ops(struct super_block *sb) {
 
 static inline void
 afs_linux_lock_inode(struct inode *ip) {
-#ifdef STRUCT_INODE_HAS_I_MUTEX
+#if defined(HAVE_LINUX_INODE_LOCK)
+    inode_lock(ip);
+#elif defined(STRUCT_INODE_HAS_I_MUTEX)
     mutex_lock(&ip->i_mutex);
 #else
     down(&ip->i_sem);
@@ -436,7 +438,9 @@ afs_linux_lock_inode(struct inode *ip) {
 
 static inline void
 afs_linux_unlock_inode(struct inode *ip) {
-#ifdef STRUCT_INODE_HAS_I_MUTEX
+#if defined(HAVE_LINUX_INODE_LOCK)
+    inode_unlock(ip);
+#elif defined(STRUCT_INODE_HAS_I_MUTEX)
     mutex_unlock(&ip->i_mutex);
 #else
     up(&ip->i_sem);
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 00b41ef..2696b48 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -571,13 +571,13 @@ afs_linux_fsync(struct file *fp, int datasync)
     cred_t *credp = crref();
 
 #if defined(FOP_FSYNC_TAKES_RANGE)
-    mutex_lock(&ip->i_mutex);
+    afs_linux_lock_inode(ip);
 #endif
     AFS_GLOCK();
     code = afs_fsync(VTOAFS(ip), credp);
     AFS_GUNLOCK();
 #if defined(FOP_FSYNC_TAKES_RANGE)
-    mutex_unlock(&ip->i_mutex);
+    afs_linux_unlock_inode(ip);
 #endif
     crfree(credp);
     return afs_convert_code(code);
-- 
2.8.3

