#!/usr/bin/env bash

## Title:       timertab
## Description: An easy way to manage all of your systemd timers
## Author:      Andrew Lamarra
## Created:     2/8/2017
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#######################################################################

set -e
echo

# Make sure systemd is installed
command -v systemctl >/dev/null 2>&1 || { echo -e \
"I require Systemd, but it's not installed.  Aborting.\n" >&2; exit 1; }

function disp_usage {
    echo -e "Usage:  $0 [-u|--user] COMMAND [ARGUMENT...]"
    echo -e "For more help:  $0 help\n"
    exit 1
}

# If no commands are supplied, display usage & exit
if [[ $# -eq 0 ]] || [[ $# -eq 1 && ("$1" == "-u" || "$1" == "--user") ]]; then
    disp_usage
fi

# Make sure the user isn't using too many commands
if [[ ( "$1" != "-u" && "$1" != "--user" ) && $# -gt 2 ]]; then
    echo -e "Only use one option at a time\n"
    disp_usage
elif [[ ( "$1" == "-u" || "$1" == "--user" ) && $# -gt 3 ]]; then
    echo -e "Only use one option at a time (not including the user option)\n"
    disp_usage
fi

# Set the path for when the --user option is specified
USER_PATH="$HOME/.config/systemd/user/"

function disp_help {
    echo "Usage: $0 [-u|--user] COMMAND [ARGUMENT...]"
    echo 'Manage your Systemd Timers'
    echo 'Only use one command at a time'
    echo
    echo '  -u, --user         Deal only with user timers (not run as root)'
    echo
    echo 'COMMANDS:'
    echo '  help               Display this help dialog'
    echo '  list               List the current timers'
    echo '  new [NAME...]      Create a new timer'
    echo '  enable [NAME...]   Enable timer'
    echo '  start [NAME...]    Start timer'
    echo '  stop [NAME...]     Stop timer'
    echo '  disable [NAME...]  Disable timer'
    echo '  remove [NAME...]   Remove (delete) timer and/or associated service files'
    echo '  modify [NAME...]   Opens the .timer file for editing in vi'
    echo '  convert            Convert a cron job into a Systemd timer'
    echo
    exit 0
}

function timer_options {
    echo 'AccuracySec='
    echo '    Specify the accuracy the timer shall elapse with. Defaults to 1min.'
    echo
    echo 'RandomizedDelaySec='
    echo '    Delay the timer by a randomly selected, evenly distributed amount of time'
    echo '    between 0 and the specified time value. Defaults to 0, indicating that no'
    echo '    randomized delay shall be applied.'
    echo
    echo 'Persistent=(true|false)'
    echo '    If true, the time when the service was last triggered is stored on disk.'
    echo '    The service unit is triggered immediately if the next run is missed.'
    echo '    This is useful to catch up on missed runs of the service when the machine'
    echo '    was off. Only use with OnCalendar= (realtime timers). Defaults to false.'
    echo
    echo 'WakeSystem=(true|false)'
    echo '    If true, an elapsing timer will cause the system to resume from suspend,'
    echo '    should it be suspended and if the system supports this. Defaults to false.'
    echo
    echo 'RemainAfterElapse=(true|false)'
    echo '    If true, an elapsed timer will stay loaded, and its state remains queriable.'
    echo '    If false, an elapsed timer unit that cannot elapse anymore is unloaded.'
    echo '    Turning this off is particularly useful for transient timer units that shall'
    echo '    disappear after they first elapse. Defaults to true.'
    echo
}

function time_syntax {
    echo 'VALUE [UNIT]'
    echo '    If no time unit is specified, seconds are assumed.'
    echo
    echo 'Possible units:'
    echo '    usec, us'
    echo '    msec, ms'
    echo '    seconds, second, sec, s'
    echo '    minutes, minute, min, m'
    echo '    hours, hour, hr, h'
    echo '    days, day, d'
    echo '    weeks, week, w'
    echo '    months, month, M (defined as 30.44 days)'
    echo '    years, year, y (defined as 365.25 days)'
    echo 'Examples:'
    echo '    2 h'
    echo '    2hours'
    echo '    48hr'
    echo '    1y 12month'
    echo '    55s500ms'
    echo '    300ms20s 5day'
    echo
}

function calendar_syntax {
    echo 'Examples for valid timestamps and their normalized form:'
    echo
    echo '  Sat,Thu,Mon..Wed,Sat..Sun → Mon..Thu,Sat,Sun *-*-* 00:00:00'
    echo '      Mon,Sun 12-*-* 2,1:23 → Mon,Sun 2012-*-* 01,02:23:00'
    echo '                    Wed *-1 → Wed *-*-01 00:00:00'
    echo '           Wed..Wed,Wed *-1 → Wed *-*-01 00:00:00'
    echo '                 Wed, 17:48 → Wed *-*-* 17:48:00'
    echo 'Wed..Sat,Tue 12-10-15 1:2:3 → Tue..Sat 2012-10-15 01:02:03'
    echo '                *-*-7 0:0:0 → *-*-07 00:00:00'
    echo '                      10-15 → *-10-15 00:00:00'
    echo '        monday *-12-* 17:00 → Mon *-12-* 17:00:00'
    echo '  Mon,Fri *-*-3,1,2 *:30:45 → Mon,Fri *-*-01,02,03 *:30:45'
    echo '       12,14,13,12:20,10,30 → *-*-* 12,13,14:10,20,30:00'
    echo '            12..14:10,20,30 → *-*-* 12,13,14:10,20,30:00'
    echo '  mon,fri *-1/2-1,3 *:30:45 → Mon,Fri *-01/2-01,03 *:30:45'
    echo '             03-05 08:05:40 → *-03-05 08:05:40'
    echo '                   08:05:40 → *-*-* 08:05:40'
    echo '                      05:40 → *-*-* 05:40:00'
    echo '     Sat,Sun 12-05 08:05:40 → Sat,Sun *-12-05 08:05:40'
    echo '           Sat,Sun 08:05:40 → Sat,Sun *-*-* 08:05:40'
    echo '           2003-03-05 05:40 → 2003-03-05 05:40:00'
    echo ' 05:40:23.4200004/3.1700005 → 05:40:23.420000/3.170001'
    echo '             2003-02..04-05 → 2003-02,03,04-05 00:00:00'
    echo '       2003-03-05 05:40 UTC → 2003-03-05 05:40:00 UTC'
    echo '                 2003-03-05 → 2003-03-05 00:00:00'
    echo '                      03-05 → *-03-05 00:00:00'
    echo '                     hourly → *-*-* *:00:00'
    echo '                      daily → *-*-* 00:00:00'
    echo '                  daily UTC → *-*-* 00:00:00 UTC'
    echo '                    monthly → *-*-01 00:00:00'
    echo '                     weekly → Mon *-*-* 00:00:00'
    echo '                     yearly → *-01-01 00:00:00'
    echo '                   annually → *-01-01 00:00:00'
    echo '                      *:2/3 → *-*-* *:02/3:00'
    echo
}

function list_timers {
    if [[ -n "$user" ]]; then # If the user option is set
        systemctl --user list-timers --all
    else
        systemctl list-timers --all
    fi
    echo
    exit 0
}

function get_name {
    name="$1"
    # Prompt user for the name of the timer
    if [[ -z "$1" ]]; then
        read -rp "Name of timer: " name
        echo
    fi

    # Add the .timer extension if the user didn't specify it
    if [[ $(echo "$name" | rev | cut -d '.' -f 1 | rev) != "timer" ]]; then
        timer_prefix="$name"
        name="$name.timer"
    else
        timer_prefix=$(echo "$name" | rev | cut -d '.' -f 2- | rev)
    fi
}

function get_srvc_name {
    # Prompt user for the name of the service
    read -rp "Name of service: " srvc_name
    echo

    # Add the .service extension if the user didn't specify it
    if [[ $(echo "$srvc_name" | rev | cut -d '.' -f 1 | rev) != "service" ]]; then
        srvc_prefix="$srvc_name"
        srvc_name="$srvc_name.service"
    else
        srvc_prefix=$(echo "$srvc_name" | rev | cut -d '.' -f 2- | rev)
    fi
}

function get_path {
    # Set the path variable
    if [[ -n "$user" ]]; then # If the user option is set
        path=$USER_PATH
    else
        read -rp "Path to the timer: (/etc/systemd/system/) " path
        if [[ "$path" == '' ]]; then
            path="/etc/systemd/system/"
        # If the user left off the slash at the end, then add it
        elif [[ "${path: -1}" != '/' ]]; then
            path="$path/"
        fi
        echo
    fi
}

function get_srvc_path {
    # Set the srvc_path variable
    if [[ -n "$user" ]]; then # If the user option is set
        srvc_path=$USER_PATH
    else
        read -rp "Path to the service: (/etc/systemd/system/) " srvc_path
        if [[ "$srvc_path" == '' ]]; then
            srvc_path="/etc/systemd/system/"
        # If the user didn't add a slash at the end, add it for them
        elif [[ "${srvc_path: -1}" != '/' ]]; then
            srvc_path="$srvc_path/"
        fi
        echo
    fi
}

function create_service_file {
    echo -e "[Unit]\nDescription=$Description\n" > "$srvc_file"
    echo -e "[Service]\nExecStart=$ExecStart\n" >> "$srvc_file"
    echo -e "[Install]\nWantedBy=default.target" >> "$srvc_file"

    # '\e[1;37m' = Bold White
    # '\e[0m' = Text Reset
    echo -e "\n\e[1;37mThe following service file has been created:\e[0m $srvc_file\n"
}

function new_timer {
    get_name "$1"
    get_path

    # Create the directory, if necessary
    if [[ -n "$user" ]]; then mkdir -p $path; fi

    echo -e "Let's create a new timer called \"$name\"\n"
    timer_file="$path$name"

    # Prompt the user to see if we need to set the Unit= option.
    while [[ "$existing" != 'y' && "$existing" != 'n' ]]; do
        read -rp "Will this timer control an existing service? (y/N) " existing
        existing="$(echo "$existing" | tr '[:upper:]' '[:lower:]')"
        if [[ "$existing" == '' ]]; then existing="n"; fi
        echo
    done

    # If yes, then gather more information
    if [[ $existing == 'y' ]]; then
        get_srvc_name
        get_srvc_path
        srvc_file="$srvc_path$srvc_name"

        # If the service file doesn't exist, give the user a second chance
        if [[ ! -e "$srvc_file" ]]; then
            echo "That service file does not exist in the specified path ($srvc_path)"
            read -rp "Would you like to provide a different name & path? (Y/n) " ans
            ans="$(echo "$ans" | tr '[:upper:]' '[:lower:]')"
            if [[ "$ans" == '' || "$ans" == 'y' ]]; then
                get_srvc_name
                get_srvc_path
                srvc_file="$srvc_path$srvc_name"
            fi
            if [[ ! -e "$srvc_file" ]]; then
                echo -e "\nWell, the service file ($srvc_file) does not exist."
                echo "Let's continue for now, but the timer will not work."
            fi
        fi

    # If no, then just set the appropriate variables
    elif [[ "$existing" == 'n' ]]; then
        srvc_prefix="$timer_prefix"
        srvc_name="$timer_prefix.service"
        srvc_path="$path"
        srvc_file="$srvc_path$srvc_name"
    fi

    # Creating the timer file & adding the description
    # '\e[4;37m' = Underline White
    # '\e[0m' = Text Reset
    echo -e "\n\e[4;37mLet's create the timer file\e[0m\n"
    read -rp "<$name> Description: " Description
    echo -e "[Unit]\nDescription=$Description\n\n[Timer]" > "$timer_file"

    # What type of timer will this be?
    echo -e '\nRealtime timers will activate at a specific time or day.'
    echo 'Monotonic timers will activate at specific intervals.'
    echo
    echo 'Create a realtime or monotonic timer?'
    PS3='Make a selection: '
    options=("Realtime" "Monotonic")
    select type in "${options[@]}"
    do
        case $type in
            "Realtime") break;;
            "Monotonic") break;;
            *) echo "Invalid option";;
        esac
    done
    echo

    # Setting timer frequencies
    if [[ $type == "Monotonic" ]]; then
        echo '(simply enter "s" without quotes to display the syntax)'
        read -rp 'How long should the timer wait after boot before being activated? ' OnBootSec

        while [[ "$OnBootSec" == "s" ]]; do
            echo
            time_syntax
            read -rp 'How long should the timer wait after boot before being activated? ' OnBootSec
        done
        echo
        read -rp 'How frequently should the timer be activated after that? ' OnUnitActiveSec
        echo

        # Add this information to the timer file
        echo -e "OnBootSec=$OnBootSec\nOnUnitActiveSec=$OnUnitActiveSec" >> "$timer_file"
    elif [[ $type == "Realtime" ]]; then
        echo '(simply enter "s" without quotes to display the syntax)'
        read -rp 'Enter the calendar event expression: ' OnCalendar

        if [[ "$OnCalendar" == "s" ]]; then
            echo
            calendar_syntax
            read -rp 'Enter the calendar event expression: ' OnCalendar
        fi
        echo -e "OnCalendar=$OnCalendar" >> "$timer_file"
        echo
    fi

    # Prompt user for additional options for the timer
    echo 'Additional timer options:'
    PS3='Make a selection: '
    options=("AccuracySec=" "RandomizedDelaySec=" "Persistent=" "WakeSystem="
        "RemainAfterElapse=" "Display options help" "Done adding options")
    select opts in "${options[@]}"
    do
        case $opts in
            "AccuracySec=") read -rp 'Specify accuracy: (VALUE [UNIT]) ' AccuracySec; echo;;
            "RandomizedDelaySec=") read -rp 'Randomized delay: (VALUE [UNIT]) ' RandomizedDelaySec; echo;;
            "Persistent=") Persistent=true; echo -e 'Adding Persistent=true\n';;
            "WakeSystem=") WakeSystem=true; echo -e 'Adding WakeSystem=true\n';;
            "RemainAfterElapse=") RemainAfterElapse=false; echo -e 'Adding RemainAfterElapse=false\n';;
            "Display options help") echo; timer_options;;
            "Done adding options") break;;
            *) echo -e "Invalid option\n";;
        esac
    done

    if [[ -n "$AccuracySec" ]]; then echo "AccuracySec=$AccuracySec" >> "$timer_file"; fi
    if [[ -n "$RandomizedDelaySec" ]]; then echo "RandomizedDelaySec=$RandomizedDelaySec" >> "$timer_file"; fi
    if [[ -n "$Persistent" ]]; then echo "Persistent=$Persistent" >> "$timer_file"; fi
    if [[ -n "$WakeSystem" ]]; then echo "WakeSystem=$WakeSystem" >> "$timer_file"; fi
    if [[ -n "$RemainAfterElapse" ]]; then echo "RemainAfterElapse=$RemainAfterElapse" >> "$timer_file"; fi

    # The Unit= option is only used if the service being activated
    # is not the same name as the timer
    if [[ "$srvc_prefix" != "$timer_prefix" ]]; then
        echo "Unit=$srvc_file" >> "$timer_file"
    fi

    # Add the [Install] section
    # '\e[1;37m' = Bold White
    # '\e[0m' = Text Reset
    echo -e '\n[Install]\nWantedBy=timers.target' >> "$timer_file"
    echo -e "\n\e[1;37mThe following timer file has been created:\e[0m $timer_file\n"

    if [[ "$existing" == 'n' ]]; then
        # Creating the service file
        # '\e[4;37m' = Underline White
        # '\e[0m' = Text Reset
        echo -e "\n\e[4;37mLet's create the service file\e[0m\n"

        read -rp "<$srvc_name> Description: " Description
        read -rp 'What command/script should the service run? (absolute path only) ' ExecStart

        create_service_file
    fi

    exit 0
}

function enable_timer {
    get_name "$1"

    # Try enabling the timer
    if [[ -n "$user" ]]; then # If the user option is set
        systemctl --user enable "$name"
    else
        systemctl enable "$name"
    fi
    echo -e "$name has been enabled\n"

    exit 0
}

function start_timer {
    get_name "$1"

    # Try starting the timer
    if [[ -n "$user" ]]; then # If the user option is set
        systemctl --user start "$name"
    else
        systemctl start "$name"
    fi
    echo -e "$name has been started\n"

    exit 0
}

function stop_timer {
    get_name "$1"

    # Try stopping the timer
    if [[ -n "$user" ]]; then # If the user option is set
        systemctl --user stop "$name"
    else
        systemctl stop "$name"
    fi
    echo -e "$name has been stopped\n"

    exit 0
}

function disable_timer {
    get_name "$1"
    get_path
    timer_file="$path$name"

    # Check if the timer exists
    if [[ ! -e "$timer_file" ]]; then
        echo -e "That timer ($timer_file) does not exist\n"
        exit 1
    else # If so, then disable it
        if [[ -n "$user" ]]; then # If the user option is set
            systemctl --user disable "$name"
        else
            systemctl disable "$name"
        fi
        echo -e "$name has been disabled\n"
    fi

    exit 0
}

function remove_timer {
    get_name "$1"
    get_path
    timer_file="$path$name"

    # Prompt to remove associated service file
    while [[ $ans != 'y' ]] && [[ $ans != 'n' ]]; do
        read -rp "Remove the associated service file of the same name? (y/N) " ans
        ans=$(echo "$ans" | tr '[:upper:]' '[:lower:]')
        if [[ "$ans" == '' ]]; then ans="n"; fi
    done

    rm "$timer_file"
    echo -e "\n$name has been removed from $path"

    if [[ "$ans" == "y" ]]; then
        prefix=$(echo "$name" | rev | cut -d '.' -f 2- | rev) # Removing extension
        rm "$path$prefix.service"
        echo "$prefix.service has been removed from $path"
    fi

    echo
    exit 0
}

function modify_timer {
    get_name "$1"
    get_path

    # Open the .timer file in the default editor specified by $EDITOR.
    # If that variable is not set, open in vi
    "${EDITOR:-vi}" "$path$name"

    exit 0
}

function convert {
    # Save the contents of crontab to a variable
    # If no crontab exists, then exit the script
    if ! crons=$(crontab -l); then echo; exit 1; fi

    # Strip the crontab file to just the list of cron jobs
    crons=$(echo "$crons" | grep '[^[:blank:]]' | grep -v '^#' | tr '\t' ' ')

    # Save each line to an array called 'lines'
    IFS=$'\r\n' GLOBIGNORE='*' command eval 'lines=($(echo "$crons"))'

    # Display each cron job
    for i in "${!lines[@]}"
    do
        echo "$(( i + 1 )).  ${lines[$i]}"
    done
    #echo "$(($i + 2)).  All"
    echo

    # Prompt the user for which job to convert to a timer
    while [[ "$job" -lt 1 || "$job" -gt ${#lines[@]} ]]; do
        read -rp 'Select which cron job to convert to a timer: ' job
    done
    echo

    #for i in "${lines[@]}"; do    For ALL cron jobs
    job=$(( job - 1 ))   # Because array elements start at 0
    # min hour dom month dow
    min=$(echo "${lines[$job]}" | cut -d ' ' -f 1)
    hour=$(echo "${lines[$job]}" | cut -d ' ' -f 2)
    dom=$(echo "${lines[$job]}" | cut -d ' ' -f 3)
    month=$(echo "${lines[$job]}" | cut -d ' ' -f 4)
    dow=$(echo "${lines[$job]}" | cut -d ' ' -f 5)
    ExecStart=$(echo "${lines[$job]}" | cut -d ' ' -f 6-)

    if [[ "$dow" == "*" ]]; then
        dow=''
    else
        # Convert the integers used by Cron to the DoW abbreviations used in Timers (and add a space at the end)
        dow="$(echo $dow | sed -e 's/0/Sun/g;s/1/Mon/g;s/2/Tue/g;s/3/Wed/g;s/4/Thu/g;s/5/Fri/g;s/6/Sat/g;s/-/../g') "
    fi

    # If a single digit was used, add a zero before it
    if [[ "${#min}" -eq 1 && "$min" != "*" ]]; then min="0$min"; fi
    if [[ "${#hour}" -eq 1 && "$hour" != "*" ]]; then hour="0$hour"; fi
    if [[ "${#dom}" -eq 1 && "$dom" != "*" ]]; then dom="0$dom"; fi
    if [[ "${#month}" -eq 1 && "$month" != "*" ]]; then month="0$month"; fi

    OnCalendar="$dow*-$month-$dom $hour:$min:00"

    # extract the name of the command to use as the name of the timer
    timer_prefix=$(echo "$ExecStart" | cut -d ' ' -f 1 | rev | cut -d '/' -f 1 | rev)
    name="$timer_prefix.timer"

    # Set the path variable
    if [[ -n "$user" ]]; then # If the user option is set
        path=$USER_PATH
    else
        path="/etc/systemd/system/"
    fi
    timer_file="$path$name"
    Description='This timer file has been automatically generated from a cron job using the timertab program'

    # Creating the timer file
    echo -e "[Unit]\nDescription=$Description\n" > "$timer_file"
    echo -e "[Timer]\nOnCalendar=$OnCalendar\n" >> "$timer_file"
    echo -e "[Install]\nWantedBy=timers.target" >> "$timer_file"
    echo -en "\n\e[1;37mThe following timer file has been created:\e[0m $timer_file"

    # Setting some variables & creating the service file
    srvc_file="$path$timer_prefix.service"
    Description='This service file has been automatically generated from a cron job using the timertab program'
    create_service_file

    exit 0
}

# Parsing the command & argument
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -u|--user ) user='--user';;
        -h|--help|help ) disp_help;;
        list ) list_timers;;
        new ) new_timer "$2"; shift;;
        enable ) enable_timer "$2"; shift;;
        start ) start_timer "$2"; shift;;
        stop ) stop_timer "$2"; shift;;
        disable ) disable_timer "$2"; shift;;
        remove ) remove_timer "$2"; shift;;
        modify ) modify_timer "$2"; shift;;
        convert ) convert "$2"; shift;;
        * ) disp_usage;;
    esac
    shift
done

# Features to implement:
#   - Allow user to convert all cron jobs into timers at once
#   - Convert function can prompt user if they'd like to create a detailed timer
#     (prompting for things like the name instead of assuming it)

# Known issues:
#   - Unable to convert user cron jobs to root level timers
#     Workaround:
#     Do the conversion with --user, and move the files to /etc/systemd/system/
