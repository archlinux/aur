diff --git a/clang-tools-extra/clangd/Hover.cpp b/clang-tools-extra/clangd/Hover.cpp
index f7e01f4ccf32..4162f2b98501 100644
--- a/clang-tools-extra/clangd/Hover.cpp
+++ b/clang-tools-extra/clangd/Hover.cpp
@@ -185,8 +185,11 @@ HoverInfo::PrintedType printType(QualType QT, ASTContext &ASTCtx,
   if (!QT.isNull() && Cfg.Hover.ShowAKA) {
     bool ShouldAKA = false;
     QualType DesugaredTy = clang::desugarForDiagnostic(ASTCtx, QT, ShouldAKA);
-    if (ShouldAKA)
+    if (ShouldAKA) {
       Result.AKA = DesugaredTy.getAsString(PP);
+      if (Result.Type.length() > 16 && Result.AKA->length() < Result.Type.length())
+        std::swap(*Result.AKA, Result.Type);
+    }
   }
   return Result;
 }
@@ -1425,6 +1428,114 @@ static std::string formatOffset(uint64_t OffsetInBits) {
   return Offset;
 }
 
+// If the backtick at `Offset` starts a probable quoted range, return the range
+// (including the quotes).
+static std::optional<llvm::StringRef>
+getBacktickQuoteRange(llvm::StringRef Line, unsigned Offset,
+                      llvm::StringRef Quote = "`") {
+  assert(Line.substr(Offset, Quote.size()) == Quote);
+
+  // The open-quote is usually preceded by whitespace.
+  llvm::StringRef Prefix = Line.substr(0, Offset);
+  constexpr llvm::StringLiteral BeforeStartChars = " \t(=";
+  if (!Prefix.empty() && !BeforeStartChars.contains(Prefix.back()))
+    return std::nullopt;
+
+  // The quoted string must be nonempty and usually has no leading/trailing ws.
+  auto Next = Line.find(Quote, Offset + Quote.size());
+  if (Next == llvm::StringRef::npos)
+    return std::nullopt;
+  llvm::StringRef Contents = Line.slice(Offset + Quote.size(), Next);
+  if (Contents.empty() || isWhitespace(Contents.front()) ||
+      isWhitespace(Contents.back()))
+    return std::nullopt;
+
+  // The close-quote is usually followed by whitespace or punctuation.
+  llvm::StringRef Suffix = Line.substr(Next + Quote.size());
+  constexpr llvm::StringLiteral AfterEndChars = " \t)=.,;:";
+  if (!Suffix.empty() && !AfterEndChars.contains(Suffix.front()))
+    return std::nullopt;
+
+  return Line.slice(Offset, Next + Quote.size());
+}
+
+static void parseDocumentationLine(llvm::StringRef Line, markup::Paragraph &Out) {
+  // Probably this is appendText(Line), but scan for something interesting.
+  for (unsigned I = 0; I < Line.size(); ++I) {
+    switch (Line[I]) {
+    case '`':
+      if (auto Range = getBacktickQuoteRange(Line, I)) {
+        Out.appendText(Line.substr(0, I));
+        Out.appendCode(Range->trim("`"), /*Preserve=*/true);
+        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+      }
+      break;
+    case '\\':
+      Out.appendText(Line.substr(0, I));
+      Out.appendText(Line.substr(I + 1, 1));
+      return parseDocumentationLine(Line.substr(I + 2), Out);
+    case '*':
+      if (Line[I + 1] == '*') {
+        if (auto Range = getBacktickQuoteRange(Line, I, "**")) {
+          Out.appendText(Line.substr(0, I));
+          Out.appendBoldText(Range->trim("**"));
+          return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+        }
+      }
+      if (auto Range = getBacktickQuoteRange(Line, I, "*")) {
+        Out.appendText(Line.substr(0, I));
+        Out.appendItalicText(Range->trim("*"));
+        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+      }
+      break;
+    }
+  }
+  Out.appendText(Line).appendSpace();
+}
+
+static void
+presentParams(std::string ParagraphName,
+              const std::optional<std::vector<HoverInfo::Param>> &Params,
+              const llvm::SmallVector<ParameterDocumentationOwned> &ParamDocs,
+              markup::Document &Output) {
+  if (!Params || Params->empty())
+    return;
+
+  Output.addParagraph().appendText(ParagraphName + ": ");
+  markup::BulletList &L = Output.addBulletList();
+
+  for (const auto &Param : *Params) {
+    auto &Paragraph = L.addItem().addParagraph();
+
+    if (!Param.Name) {
+      Paragraph.appendCode(llvm::to_string(Param));
+      continue;
+    }
+
+    std::size_t From = 0;
+    while ((*Param.Name)[From] == '_')
+      ++From;
+    auto Name = llvm::StringRef(*Param.Name).substr(From);
+
+    if (Param.Default)
+      Paragraph.appendCode(Name.str() + " = " + *Param.Default);
+    else
+      Paragraph.appendCode(Name);
+    Paragraph.appendText(": ");
+
+    auto *ParamDoc = std::find_if(
+        ParamDocs.begin(), ParamDocs.end(),
+        [Param](const auto &ParamDoc) { return Param.Name == ParamDoc.Name; });
+    if (ParamDoc != ParamDocs.end())
+      parseDocumentationLine(ParamDoc->Description, Paragraph);
+
+    if (Param.Type)
+      Paragraph.appendText(" (")
+          .appendCode(llvm::to_string(*Param.Type))
+          .appendText(")");
+  }
+}
+
 markup::Document HoverInfo::present() const {
   markup::Document Output;
 
@@ -1460,6 +1571,9 @@ markup::Document HoverInfo::present() const {
   if (!Documentation.Brief.empty())
     parseDocumentation(Documentation.Brief, Output);
 
+  presentParams("Template parameters", TemplateParameters,
+                Documentation.TemplateParameters, Output);
+
   // Print Types on their own lines to reduce chances of getting line-wrapped by
   // editor, as they might be long.
   if (ReturnType) {
@@ -1468,44 +1582,20 @@ markup::Document HoverInfo::present() const {
     // Parameters:
     // - `bool param1`
     // - `int param2 = 5`
-    auto &P = Output.addParagraph().appendText("→ ").appendCode(
-        llvm::to_string(*ReturnType));
+    auto &P =
+        Output.addParagraph().appendText("→ ").appendCode(ReturnType->Type);
 
     if (!Documentation.Returns.empty())
-      P.appendText(": ").appendText(Documentation.Returns);
-  }
-  if (Parameters && !Parameters->empty()) {
-    Output.addParagraph().appendText("Parameters: ");
-    markup::BulletList &L = Output.addBulletList();
-
-    llvm::SmallVector<ParameterDocumentationOwned> ParamDocs =
-        Documentation.Parameters;
+      parseDocumentationLine(Documentation.Returns, P.appendText(": "));
 
-    for (const auto &Param : *Parameters) {
-      auto &Paragraph = L.addItem().addParagraph();
-      Paragraph.appendCode(llvm::to_string(Param));
-
-      if (Param.Name.has_value()) {
-        auto ParamDoc = std::find_if(ParamDocs.begin(), ParamDocs.end(),
-                                     [Param](const auto &ParamDoc) {
-                                       return Param.Name == ParamDoc.Name;
-                                     });
-        if (ParamDoc != ParamDocs.end()) {
-          Paragraph.appendText(": ").appendText(ParamDoc->Description);
-          ParamDocs.erase(ParamDoc);
-        }
-      }
-    }
+    if (ReturnType->AKA)
+      P.appendCode(" (aka " + *ReturnType->AKA + ")");
+  }
+  presentParams("Parameters", Parameters, Documentation.Parameters, Output);
 
-    // We erased all parameters that matched, but some may still be left,
-    // usually typos. Let's also print them here.
-    for (const auto &ParamDoc : ParamDocs) {
-      L.addItem()
-          .addParagraph()
-          .appendCode(ParamDoc.Name)
-          .appendText(": ")
-          .appendText(ParamDoc.Description);
-    }
+  if (!Documentation.Details.empty()) {
+    Output.addParagraph().appendText("Details: ");
+    parseDocumentation(Documentation.Details, Output);
   }
 
   // Don't print Type after Parameters or ReturnType as this will just duplicate
@@ -1577,6 +1667,39 @@ markup::Document HoverInfo::present() const {
       parseDocumentation(Note, L.addItem());
   }
 
+  if (!Documentation.Exceptions.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Exception")
+        .appendText(Documentation.Exceptions.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Exception : Documentation.Exceptions)
+      parseDocumentation(Exception, L.addItem());
+  }
+
+  if (!Documentation.Bugs.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Bug")
+        .appendText(Documentation.Bugs.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Bug : Documentation.Bugs)
+      parseDocumentation(Bug, L.addItem());
+  }
+
+  if (!Documentation.Todos.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Todo")
+        .appendText(Documentation.Todos.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Todo : Documentation.Todos)
+      parseDocumentation(Todo, L.addItem());
+  }
+
   if (!Definition.empty()) {
     Output.addRuler();
     std::string Buffer;
@@ -1627,71 +1750,6 @@ markup::Document HoverInfo::present() const {
   return Output;
 }
 
-// If the backtick at `Offset` starts a probable quoted range, return the range
-// (including the quotes).
-std::optional<llvm::StringRef>
-getBacktickQuoteRange(llvm::StringRef Line, unsigned Offset,
-                      llvm::StringRef Quote = "`") {
-  assert(Line.substr(Offset, Quote.size()) == Quote);
-
-  // The open-quote is usually preceded by whitespace.
-  llvm::StringRef Prefix = Line.substr(0, Offset);
-  constexpr llvm::StringLiteral BeforeStartChars = " \t(=";
-  if (!Prefix.empty() && !BeforeStartChars.contains(Prefix.back()))
-    return std::nullopt;
-
-  // The quoted string must be nonempty and usually has no leading/trailing ws.
-  auto Next = Line.find(Quote, Offset + Quote.size());
-  if (Next == llvm::StringRef::npos)
-    return std::nullopt;
-  llvm::StringRef Contents = Line.slice(Offset + Quote.size(), Next);
-  if (Contents.empty() || isWhitespace(Contents.front()) ||
-      isWhitespace(Contents.back()))
-    return std::nullopt;
-
-  // The close-quote is usually followed by whitespace or punctuation.
-  llvm::StringRef Suffix = Line.substr(Next + Quote.size());
-  constexpr llvm::StringLiteral AfterEndChars = " \t)=.,;:";
-  if (!Suffix.empty() && !AfterEndChars.contains(Suffix.front()))
-    return std::nullopt;
-
-  return Line.slice(Offset, Next + Quote.size());
-}
-
-void parseDocumentationLine(llvm::StringRef Line, markup::Paragraph &Out) {
-  // Probably this is appendText(Line), but scan for something interesting.
-  for (unsigned I = 0; I < Line.size(); ++I) {
-    switch (Line[I]) {
-    case '`':
-      if (auto Range = getBacktickQuoteRange(Line, I)) {
-        Out.appendText(Line.substr(0, I));
-        Out.appendCode(Range->trim("`"), /*Preserve=*/true);
-        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-      }
-      break;
-    case '\\':
-      Out.appendText(Line.substr(0, I));
-      Out.appendText(Line.substr(I + 1, 1));
-      return parseDocumentationLine(Line.substr(I + 2), Out);
-    case '*':
-      if (Line[I + 1] == '*') {
-        if (auto Range = getBacktickQuoteRange(Line, I, "**")) {
-          Out.appendText(Line.substr(0, I));
-          Out.appendBoldText(Range->trim("**"));
-          return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-        }
-      }
-      if (auto Range = getBacktickQuoteRange(Line, I, "*")) {
-        Out.appendText(Line.substr(0, I));
-        Out.appendItalicText(Range->trim("*"));
-        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-      }
-      break;
-    }
-  }
-  Out.appendText(Line).appendSpace();
-}
-
 void parseDocumentation(llvm::StringRef Input, markup::Document &Output) {
   std::vector<llvm::StringRef> ParagraphLines;
   auto FlushParagraph = [&] {
diff --git a/clang-tools-extra/clangd/SymbolDocumentation.cpp b/clang-tools-extra/clangd/SymbolDocumentation.cpp
index 50d63f47515f..9defaa7fe53e 100644
--- a/clang-tools-extra/clangd/SymbolDocumentation.cpp
+++ b/clang-tools-extra/clangd/SymbolDocumentation.cpp
@@ -106,11 +106,22 @@ public:
     // Otherwise, we want to keep the command name, so visit B itself.
     if (CommandName == "brief") {
       BlockCommentToString(Output.Brief, Ctx).visit(B->getParagraph());
+    } else if (CommandName == "details") {
+      BlockCommentToString(Output.Details, Ctx).visit(B->getParagraph());
     } else if (CommandName == "return") {
       BlockCommentToString(Output.Returns, Ctx).visit(B->getParagraph());
     } else if (CommandName == "warning") {
       BlockCommentToString(Output.Warnings.emplace_back(), Ctx)
           .visit(B->getParagraph());
+    } else if (CommandName == "exception" || CommandName == "throw") {
+      BlockCommentToString(Output.Exceptions.emplace_back(), Ctx)
+          .visit(B->getParagraph());
+    } else if (CommandName == "todo") {
+      BlockCommentToString(Output.Todos.emplace_back(), Ctx)
+          .visit(B->getParagraph());
+    } else if (CommandName == "bug") {
+      BlockCommentToString(Output.Bugs.emplace_back(), Ctx)
+          .visit(B->getParagraph());
     } else if (CommandName == "note") {
       BlockCommentToString(Output.Notes.emplace_back(), Ctx)
           .visit(B->getParagraph());
@@ -135,6 +146,15 @@ public:
     }
   }
 
+  void visitTParamCommandComment(const comments::TParamCommandComment *P) {
+    if (P->hasParamName() && P->hasNonWhitespaceParagraph()) {
+      ParameterDocumentationOwned Doc;
+      Doc.Name = P->getParamNameAsWritten().str();
+      BlockCommentToString(Doc.Description, Ctx).visit(P->getParagraph());
+      Output.TemplateParameters.push_back(std::move(Doc));
+    }
+  }
+
 private:
   comments::FullComment *FullComment;
   SymbolDocumentationOwned &Output;
@@ -149,16 +169,25 @@ SymbolDocumentationOwned parseDoxygenComment(const RawComment &RC,
 
   // Clang requires source to be UTF-8, but doesn't enforce this in comments.
   ensureUTF8(Doc.Brief);
+  ensureUTF8(Doc.Details);
   ensureUTF8(Doc.Returns);
 
   ensureUTF8(Doc.Notes);
   ensureUTF8(Doc.Warnings);
+  ensureUTF8(Doc.Exceptions);
+  ensureUTF8(Doc.Todos);
+  ensureUTF8(Doc.Bugs);
 
   for (auto &Param : Doc.Parameters) {
     ensureUTF8(Param.Name);
     ensureUTF8(Param.Description);
   }
 
+  for (auto &Param : Doc.TemplateParameters) {
+    ensureUTF8(Param.Name);
+    ensureUTF8(Param.Description);
+  }
+
   ensureUTF8(Doc.Description);
   ensureUTF8(Doc.CommentText);
 
@@ -173,6 +202,7 @@ SymbolDocumentation<StrOut> convert(const SymbolDocumentation<StrIn> &In) {
   SymbolDocumentation<StrOut> Doc;
 
   Doc.Brief = In.Brief;
+  Doc.Details = In.Details;
   Doc.Returns = In.Returns;
 
   Doc.Notes.reserve(In.Notes.size());
@@ -185,12 +215,33 @@ SymbolDocumentation<StrOut> convert(const SymbolDocumentation<StrIn> &In) {
     Doc.Warnings.emplace_back(Warning);
   }
 
+  Doc.Exceptions.reserve(In.Exceptions.size());
+  for (const auto &Exception : In.Exceptions) {
+    Doc.Exceptions.emplace_back(Exception);
+  }
+
+  Doc.Todos.reserve(In.Todos.size());
+  for (const auto &Todo : In.Todos) {
+    Doc.Todos.emplace_back(Todo);
+  }
+
+  Doc.Bugs.reserve(In.Bugs.size());
+  for (const auto &Bug : In.Bugs) {
+    Doc.Bugs.emplace_back(Bug);
+  }
+
   Doc.Parameters.reserve(In.Parameters.size());
   for (const auto &ParamDoc : In.Parameters) {
     Doc.Parameters.emplace_back(ParameterDocumentation<StrOut>{
         StrOut(ParamDoc.Name), StrOut(ParamDoc.Description)});
   }
 
+  Doc.TemplateParameters.reserve(In.TemplateParameters.size());
+  for (const auto &ParamDoc : In.TemplateParameters) {
+    Doc.TemplateParameters.emplace_back(ParameterDocumentation<StrOut>{
+        StrOut(ParamDoc.Name), StrOut(ParamDoc.Description)});
+  }
+
   Doc.Description = In.Description;
   Doc.CommentText = In.CommentText;
 
diff --git a/clang-tools-extra/clangd/SymbolDocumentation.h b/clang-tools-extra/clangd/SymbolDocumentation.h
index 77bd90927802..0c9db8653f22 100644
--- a/clang-tools-extra/clangd/SymbolDocumentation.h
+++ b/clang-tools-extra/clangd/SymbolDocumentation.h
@@ -65,6 +65,9 @@ public:
   /// Paragraph of the "brief" command.
   String Brief;
 
+  /// Paragraph of the "details" command.
+  String Details;
+
   /// Paragraph of the "return" command.
   String Returns;
 
@@ -72,10 +75,19 @@ public:
   llvm::SmallVector<String, 1> Notes;
   /// Paragraph(s) of the "warning" command(s)
   llvm::SmallVector<String, 1> Warnings;
+  /// Paragraph(s) of the "exception" command(s)
+  llvm::SmallVector<String, 1> Exceptions;
+  /// Paragraph(s) of the "todo" command(s)
+  llvm::SmallVector<String, 1> Todos;
+  /// Paragraph(s) of the "bug" command(s)
+  llvm::SmallVector<String, 1> Bugs;
 
   /// Parsed paragaph(s) of the "param" comamnd(s)
   llvm::SmallVector<ParameterDocumentation<String>> Parameters;
 
+  /// Parsed paragaph(s) of the "tparam" comamnd(s)
+  llvm::SmallVector<ParameterDocumentation<String>> TemplateParameters;
+
   /// All the paragraphs we don't have any special handling for,
   /// e.g. "details".
   String Description;
diff --git a/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h b/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
index 12c955c458cc..12a247ecf3ce 100644
--- a/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
+++ b/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
@@ -37,6 +37,12 @@ matchesDoc(const SymbolDocumentation<S> &Expected) {
             ElementsAreArray(Expected.Notes)),
       Field("Warnings", &SymbolDocumentation<S>::Warnings,
             ElementsAreArray(Expected.Warnings)),
+      Field("Exceptions", &SymbolDocumentation<S>::Exceptions,
+            ElementsAreArray(Expected.Exceptions)),
+      Field("TODO", &SymbolDocumentation<S>::Todos,
+            ElementsAreArray(Expected.Todos)),
+      Field("Bugs", &SymbolDocumentation<S>::Bugs,
+            ElementsAreArray(Expected.Bugs)),
       Field("Parameters", &SymbolDocumentation<S>::Parameters,
             ElementsAreArray(ParamMatchers)),
       Field("Description", &SymbolDocumentation<S>::Description,
