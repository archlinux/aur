--- a/vmmon/Makefile
+++ b/vmmon/Makefile
@@ -43,7 +43,11 @@
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
--- a/vmmon/include/pgtbl.h
+++ b/vmmon/include/pgtbl.h
@@ -91,7 +91,11 @@
          } else {
             pte_t *pte;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,5,0)
+            pte = pte_offset_kernel(pmd, addr);
+#else
             pte = pte_offset_map(pmd, addr);
+#endif
             if (pte_present(*pte) == 0) {
                pte_unmap(pte);
                return INVALID_MPN;
--- a/vmmon/include/vm_assert.h
+++ b/vmmon/include/vm_assert.h
@@ -40,7 +40,11 @@
 
 // XXX not necessary except some places include vm_assert.h improperly
 #include "vm_basic_types.h"
+
+/* No stdarg.h on Linux kernels 5.15+ */
+#ifndef KBUILD_MODNAME
 #include <stdarg.h>
+#endif
 
 #ifdef __cplusplus
 extern "C" {
--- a/vmmon/include/vm_basic_defs.h
+++ b/vmmon/include/vm_basic_defs.h
@@ -50,7 +50,10 @@
  * References:
  *   C90 7.17, C99 7.19, C11 7.19
  */
-#if !defined(VMKERNEL)
+/* Use linux/stddef.h when building Linux kernel modules. */
+#ifdef KBUILD_MODNAME
+#  include <linux/stddef.h>
+#elif !defined(VMKERNEL)
 #  include <stddef.h>
 #else
    /*
--- a/vmmon/linux/driver.c
+++ b/vmmon/linux/driver.c
@@ -256,7 +256,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * init_module --
+ * LinuxDriverInit --
  *
  *      linux module entry point. Called by /sbin/insmod command
  *
@@ -268,7 +268,7 @@
  */
 
 int
-init_module(void)
+LinuxDriverInit(void)
 {
    int retval;
 
@@ -328,7 +328,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * cleanup_module --
+ * LinuxDriverExit --
  *
  *      Called by /sbin/rmmod
  *
@@ -337,7 +337,7 @@
  */
 
 void
-cleanup_module(void)
+LinuxDriverExit(void)
 {
    /*
     * XXX smp race?
@@ -1450,3 +1450,5 @@
  * by default (i.e., neither mkinitrd nor modprobe will accept it).
  */
 MODULE_INFO(supported, "external");
+module_init(LinuxDriverInit);
+module_exit(LinuxDriverExit);
--- a/vmmon/linux/hostif.c
+++ b/vmmon/linux/hostif.c
@@ -2356,7 +2332,11 @@
    int ret;
 
    r = APICR_TO_ADDR(r, APICR_VERSION);
-#ifdef HAVE_GET_KERNEL_NOFAULT
+#if defined(HAVE_GET_KERNEL_NOFAULT) || LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+   /*
+    * Exists from 5.10, first indicated by HAVE_GET_KERNEL_NOFAULT,
+    * and from post-5.17 just existing everywhere.
+    */
    ret = get_kernel_nofault(dummy, (void *)r);
 #else
    {
From 4c2a103fd2d71f2084f1fe7ceacb816b9832ffa2 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sun, 22 Oct 2023 23:24:05 +0200
Subject: [PATCH] vmmon: use get_user_pages to get page PFN

As a side effect of mainline commit 0d940a9b270b ("mm/pgtable: allow
pte_offset_map[_lock]() to fail") in 6.5-rc1, __pte_offset_map(), called by
pte_offset_map(), is no longer exported. WMware developers decided to hack
around this by replacing pte_offset_map() by pte_offset_kernel() which does
not seem to be a good idea and apparently may trigger warn checks in RCU
code on some systems as mentioned in the discussion on issue #223.
Therefore let's use the same solution as we had for 17.0.2 and older
versions as it does not show these problems.

Based on an upstream IRC discussion and the hva_to_pfn_*() family of
functions in KVM code, what PgtblVa2MPNLocked() does seems to be an
incomplete and partial open coded logic of get_user_pages() and as it is
only used to get PFN from a virtual address, it can be easily implemented
using get_user_pages() family.

Without knowledge what exactly are the PFNs used for in VMware, it is hard
to guess the right flags, these seem to work and have been tested by
multiple users over last few weeks.

We could likely use get_user_pages() also on older kernels and it might be
actually cleaner and more reliable as existing open coded implementation
does not seem to handle some corner cases but without knowledge of VMware
internals, it will be safer to stick to existing code where possible.
---
 vmmon-only/include/pgtbl.h | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/vmmon-only/include/pgtbl.h b/vmmon-only/include/pgtbl.h
index 3f43c62..7eaa49a 100644
--- a/vmmon-only/include/pgtbl.h
+++ b/vmmon-only/include/pgtbl.h
@@ -25,6 +25,7 @@
 #include "compat_pgtable.h"
 #include "compat_spinlock.h"
 #include "compat_page.h"
+#include "compat_version.h"
 
 
 /*
@@ -45,6 +46,7 @@
  *-----------------------------------------------------------------------------
  */
 
+#if COMPAT_LINUX_VERSION_CHECK_LT(6, 5, 0) // only used by PgtblVa2MPN() below
 static INLINE MPN
 PgtblVa2MPNLocked(struct mm_struct *mm, // IN: Mm structure of a process
                   VA addr)              // IN: Address in the virtual address
@@ -110,6 +112,7 @@ PgtblVa2MPNLocked(struct mm_struct *mm, // IN: Mm structure of a process
    }
    return mpn;
 }
+#endif
 
 
 /*
@@ -129,6 +132,8 @@ PgtblVa2MPNLocked(struct mm_struct *mm, // IN: Mm structure of a process
  *-----------------------------------------------------------------------------
  */
 
+#if COMPAT_LINUX_VERSION_CHECK_LT(6, 5, 0)
+
 static INLINE MPN
 PgtblVa2MPN(VA addr)  // IN
 {
@@ -143,4 +148,24 @@ PgtblVa2MPN(VA addr)  // IN
    return mpn;
 }
 
+#else /* COMPAT_LINUX_VERSION_CHECK_LT(6, 5, 0) */
+
+static INLINE MPN
+PgtblVa2MPN(VA addr)  // IN
+{
+   struct page *page;
+   int npages;
+   MPN mpn;
+
+   npages = get_user_pages_unlocked(addr, 1, &page, FOLL_HWPOISON);
+   if (npages != 1)
+	   return INVALID_MPN;
+   mpn = page_to_pfn(page);
+   put_page(page);
+
+   return mpn;
+}
+
+#endif /* COMPAT_LINUX_VERSION_CHECK_LT(6, 5, 0) */
+
 #endif /* __PGTBL_H__ */
From 2c6d66f3f1947384038b765c897b102ecdb18298 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 12 Jan 2024 08:30:33 +0100
Subject: [PATCH] modules: fix build with -Wmissing-prototypes

Mainline commit 0fcb70851fbf ("Makefile.extrawarn: turn on
missing-prototypes globally") in 6.8-rc1 enables -Wmissing-prototypes
globally, revealing a lot of unclean code and also some actual problems.
This is also the case in vmmon and vmnet modules.

Most of them are addressed by making functions used only within one file
static. The missing prototype of random_get_entropy_fallback() is handled
by including <linux/timex.h> rather than <asm/timex.h>.

Finally, there are four functions in vmnet module which are actually used
in multiple files but instead of proper declarations, their prototype is
duplicated in vmnet-only/driver.c, risking that the two copies won't match
(which actually happened in one case). The cleanest solution would be
creating separate header files for them (bridge.h, netif.h, userif.h and
vnetUserListener.h) and including them in the respective source file and
driver.c. As the developers already handle similar cases by simply putting
the declarations into vnetInt.h, let us do the same to keep things simple.
---
 vmmon-only/common/task.c  |  2 +-
 vmmon-only/common/vmx86.c |  6 +++---
 vmmon-only/linux/driver.c |  4 ++--
 vmmon-only/linux/hostif.c |  6 +++---
 vmnet-only/bridge.c       |  2 +-
 vmnet-only/driver.c       | 16 ++--------------
 vmnet-only/vnetInt.h      |  7 +++++++
 7 files changed, 19 insertions(+), 24 deletions(-)

diff --git a/vmmon-only/common/task.c b/vmmon-only/common/task.c
index 5d34cf4d..f3752069 100644
--- a/vmmon-only/common/task.c
+++ b/vmmon-only/common/task.c
@@ -544,7 +544,7 @@ Task_Terminate(void)
  *-----------------------------------------------------------------------------
  */
 
-Selector
+static Selector
 TaskGetFlatWriteableDataSegment(void)
 {
    DTR hostGDTR;
diff --git a/vmmon-only/common/vmx86.c b/vmmon-only/common/vmx86.c
index 86e52fb4..cf64b123 100644
--- a/vmmon-only/common/vmx86.c
+++ b/vmmon-only/common/vmx86.c
@@ -53,7 +53,7 @@
 #include "x86svm.h"
 #include "x86cpuid_asm.h"
 #if defined(__linux__)
-#include <asm/timex.h>
+#include <linux/timex.h>
 #endif
 #include "perfctr.h"
 #include "x86vtinstr.h"
@@ -699,7 +699,7 @@ Vmx86FreeCrossPages(VMDriver *vm)
  *-----------------------------------------------------------------------------
  */
 
-void
+static void
 Vmx86FreeVMDriver(VMDriver *vm)
 {
    Vmx86_Free(vm->ptRootMpns);
@@ -732,7 +732,7 @@ Vmx86FreeVMDriver(VMDriver *vm)
  *-----------------------------------------------------------------------------
  */
 
-VMDriver *
+static VMDriver *
 Vmx86AllocVMDriver(uint32 numVCPUs)
 {
    VMDriver *vm = Vmx86_Calloc(1, sizeof *vm, TRUE);
diff --git a/vmmon-only/linux/driver.c b/vmmon-only/linux/driver.c
index 3d8b7228..ab8e2dc4 100644
--- a/vmmon-only/linux/driver.c
+++ b/vmmon-only/linux/driver.c
@@ -267,7 +267,7 @@ LinuxDriverInitTSCkHz(void)
  *----------------------------------------------------------------------
  */
 
-int
+static int
 LinuxDriverInit(void)
 {
    int retval;
@@ -336,7 +336,7 @@ LinuxDriverInit(void)
  *----------------------------------------------------------------------
  */
 
-void
+static void
 LinuxDriverExit(void)
 {
    /*
diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index 5d08f33a..c1e6c671 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -2944,7 +2944,7 @@ HostIF_CallOnEachCPU(void (*func)(void*), // IN: function to call
  *-----------------------------------------------------------------------------
  */
 
-Bool
+static Bool
 HostIFCheckTrackedMPN(VMDriver *vm, // IN: The VM instance
                       MPN mpn)      // IN: The MPN
 {
@@ -3064,7 +3064,7 @@ HostIF_ReadPhysical(VMDriver *vm,      // IN: The VM instance
  *----------------------------------------------------------------------
  */
 
-int
+static int
 HostIFWritePhysicalWork(MA ma,             // MA to be written to
                         VA64 addr,         // src data to write
                         Bool kernelBuffer, // is the buffer in kernel space?
@@ -3223,7 +3223,7 @@ HostIF_GetCurrentPCPU(void)
  *----------------------------------------------------------------------
  */
 
-int
+static int
 HostIFStartTimer(Bool rateChanged,  //IN: Did rate change?
                  unsigned int rate) //IN: current clock rate
 {
