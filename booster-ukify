#!/bin/bash -e

source /usr/share/makepkg/util/message.sh

function usage {
  echo "$(basename "$0") [OPTIONS]"
  echo "  -h            shows usage"
  echo "  -g <version>  generate UKI image for specified kernel version"
  echo "  -a            generate UKI images for all available kernels"
  exit 0
}

function check_root {
  [ $EUID -eq 0 ] && return
  echo "booster-ukify requires root privileges to work" >&2
  exit 1
}

if [[ ${#} -eq 0 ]]; then
   usage
fi

declare -a ukify_global_args=()
declare -A ukify_variants=()
declare -A ukify_install_path=()
declare -A ukify_cmdline=()

[ -f "/etc/booster-ukify.conf" ] && source /etc/booster-ukify.conf

case "$colorize" in
  "true")
    colorize
    ;;
  "auto")
    grep -q -e '^\w*Color\w*$' /etc/pacman.conf && colorize
    ;;
esac

[ ${#ukify_variants[@]} -eq 0 ] && {
  # Fallback to default image if ukify_variants isn't specified
  ukify_variants[default]="--strip --compression=zstd"
}

ESP_PATH=$(bootctl --print-esp-path)
MACHINE_ID=$(</etc/machine-id)
# shellcheck source=/etc/os-release
source <(grep -E '^(BUILD_)?ID=' /etc/os-release)

function variant_name() {
  local prefix="$1"
  local name="$2"
  if [[ "$name" = "default" ]]; then
    printf "%s" "$prefix"
  else
    printf "%s-%s" "$prefix" "$name"
  fi
}

function ukify_obsolete_syntax() {
  read -r -a ukify_version < <(/usr/lib/systemd/ukify --version)
  [ "${ukify_version[1]}" -lt 254 ]
  return $?
}

function uki_path() {
  local name="$1"
  local version="$2"
  local variant="$3"

  if [ ${ukify_install_path[$variant]+_} ]; then
    local -A substitutions=(
      [id]="$ID"
      [build_id]="$BUILD_ID"
      [name]="$name"
      [version]="$version"
      [machine_id]="$MACHINE_ID"
      [version]="$version"
    )

    local path="${ukify_install_path[$variant]}"
    for key in "${!substitutions[@]}"; do
      local value="${substitutions[$key]}"
      path="${path//\$\{$key\}/${value}}"
    done

    printf "%s" "$path"
  else
    printf "EFI/Linux/%s.efi" "$(variant_name "linux-$version-$MACHINE_ID-$BUILD_ID" "$variant")"
  fi
}

function sanity_check() {
  local verbose="$1"

  local -A sanity_kernel=()
  for candidate in /usr/lib/modules/*; do
    [ -f "$candidate/pkgbase" ] || continue
    if read -r pkgbase &> /dev/null < "$candidate/pkgbase"; then
      sanity_kernel["${pkgbase}"]="$(basename "$candidate")"
    fi
  done

  local -A uki_path=()

  local -i result=0

  for kernel in "${!sanity_kernel[@]}"; do
    for variant in "${!ukify_variants[@]}"; do
      local path=$(uki_path "$kernel" "${sanity_kernel[$kernel]}" "$variant")
      if [ $verbose -ne 0 ]; then
        msg "Resolved UKI path for package %s %s in variant %s: %s\n" "$kernel" "${sanity_kernel[$kernel]}" "$variant" "$path"
      fi

      if [ ${uki_path[$path]+_} ]; then
        error "Found UKI path clash: %s-%s and %s points to the same path: %s\n" "$kernel" "$variant" "${uki_path[$path]}" "$path"
        result=1
      fi
      uki_path[$path]="$kernel-$variant"
    done
  done

  if [ $result -ne 0 ]; then
    exit $result
  fi
}

declare -A kernels
update_all=0

while getopts ":hag:sxyz" arg; do
  case ${arg} in
    g)
      found=0
      for line in $(pacman -Qql "$OPTARG"); do
        if [[ $line =~ ^/usr/lib/modules/([^/]+)/pkgbase$ ]]; then
          read -r pkgbase < "/${line}"
          kernels["${pkgbase}"]="${BASH_REMATCH[1]}"
          found=1
          break
        fi
      done
      if (( ! found )); then
        error "Error occurred during '$OPTARG' package traversal"
        exit 1
      fi
      ;;
    a)
      update_all=1
      ;;
    x)
      check_root
      # Trigger some IO on ESP path to be sure it's mounted by autofs if it's the case
      # Otherwise upgrading systemd may cause ESP partition not mounted at the time booster attempt to write new image
      stat "$ESP_PATH" >/dev/null
      exit 0
      ;;
    y)
      check_root
      sanity_check 0
      while read -r line; do
        if [[ "$line" == 'usr/lib/modules/'+([^/])'/pkgbase' ]]; then
          read -r pkgbase < "/${line}"
          path="$(grep -lE "^${pkgbase}\$" /usr/lib/modules/*/pkgbase)"
          version=$(basename "${path%/pkgbase}")
          for variant in "${!ukify_variants[@]}"; do
            IMAGE="${ESP_PATH}/$(uki_path "$pkgbase" "$version" "$variant")"
            if [ -f "$IMAGE" ]; then
              msg "Removing $IMAGE..."
              rm -f "$IMAGE"
            fi
          done
        fi
      done
      exit 0
      ;;
    s)
      sanity_check 1
      exit 0
      ;;
    z)
      check_root
      while read -r line; do
        if [[ $line =~ ^usr/lib/modules/([^/]+)/pkgbase$ ]]; then
          read -r pkgbase < "/${line}"
          kernels["${pkgbase}"]="${BASH_REMATCH[1]}"
        else
          update_all=1
          break 
        fi
      done
      ;;
    h)
      usage
      ;;
    *)
      usage
      ;;
  esac
done

sanity_check 0

if (( update_all )); then
  for candidate in /usr/lib/modules/*; do
    [ -f "$candidate/pkgbase" ] || continue
    if read -r pkgbase &> /dev/null < "$candidate/pkgbase"; then
      kernels["${pkgbase}"]="$(basename "$candidate")"
    fi
  done
fi

function gen_image() {
  check_root
  local kernel="$1"
  local version="$2"
  local path="/usr/lib/modules/${version}/pkgbase"
  local vmlinuz="/usr/lib/modules/${version}/vmlinuz"

  msg "booster-ukify -g %s" "$kernel"

  for variant in "${!ukify_variants[@]}"; do
    local image="${ESP_PATH}/$(uki_path "$kernel" "$version" "$variant")"
    local version_name=$(variant_name "$version" "$variant")

    read -r pkgbase < "$path"

    local initrd=$(mktemp ukify.XXXXXXXXXX)

    msg2 "Building initrd image %s (%s)" "$kernel" "$version_name"
    booster build --force "--kernel-version=${version}" ${ukify_variants[$variant]} "$initrd"

    local os_release=$(mktemp ukify.XXXXXXXXXX)
    grep -v '^BUILD_ID=' /etc/os-release > "$os_release"
    echo "BUILD_ID=\"$version_name\"" >> "$os_release"
    echo "VERSION_ID=\"$(variant_name "$pkgbase" "$variant")\"" >> "$os_release"

    local -a ukify_args=()
    if ! ukify_obsolete_syntax; then
          ukify_args+=(build)
    fi
    ukify_args+=("${ukify_global_args[@]}")
    ukify_args+=(--uname "$version")
    ukify_args+=(--os-release "@$os_release")
    ukify_args+=(--output "$image")

    if [ ! -z "${ukify_cmdline["$variant"]}" ]; then
      for i in "${!ukify_args[@]}"; do
         [[ "${ukify_args[$i]}" = "--cmdline" ]] && break
      done
      if [ "${ukify_args[$i]}" == "--cmdline" ]; then
        # Global args contains cmdline, override it
        ukify_args[$((i + 1))]="${ukify_cmdline["$variant"]}"
      else
        # There is no global cmdline, append it
        ukify_args+=("--cmdline" "${ukify_cmdline["$variant"]}")
      fi
    fi

    if ukify_obsolete_syntax; then
      ukify_args+=("$vmlinuz" "$initrd")
    else
      ukify_args+=(--linux "$vmlinuz")
      ukify_args+=(--initrd "$initrd")
    fi

    msg2 "Ukify image %s (%s)" "$kernel" "$version_name"

    /usr/lib/systemd/ukify "${ukify_args[@]}"

    # Remove temporary files
    rm "$initrd"
    rm "$os_release"

    # Mark image as default if needed
    if [[ "$pkgbase" == "$default_kernel_package" && "$variant" == "default" ]]; then
      if ! bootctl is-installed --quiet; then
        warning "systemd-boot is not installed, unable to mark image as default"
      else
        msg2 "Mark linux image %s (%s) as default" "$kernel" "$version"
        bootctl set-default "$(basename "$image")" || {
          error "Unable to mark linux image $kernel ($version) as default due to error"
        }
      fi
    fi
  done
}

for kernel in "${!kernels[@]}"; do
  gen_image "$kernel" "${kernels[$kernel]}"
done
