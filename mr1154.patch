From 798fd5475bed4e8c0398e8fa57e7685ee4194b7c Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 4 Jul 2020 01:03:19 +0300
Subject: [PATCH 01/23] renderer-view: Keep track of the associated MetaOutput

---
 src/backends/meta-renderer-view.c             | 24 +++++++++++++++++++
 src/backends/meta-renderer-view.h             |  2 ++
 src/backends/native/meta-renderer-native.c    |  1 +
 .../x11/nested/meta-renderer-x11-nested.c     |  1 +
 4 files changed, 28 insertions(+)

diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index 55617fc682..2e0ddf943f 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -33,6 +33,7 @@
 #include "backends/meta-renderer-view.h"
 
 #include "backends/meta-crtc.h"
+#include "backends/meta-output.h"
 #include "backends/meta-renderer.h"
 #include "clutter/clutter-mutter.h"
 #include "compositor/region-utils.h"
@@ -43,6 +44,7 @@ enum
 
   PROP_TRANSFORM,
   PROP_CRTC,
+  PROP_OUTPUT,
 
   PROP_LAST
 };
@@ -56,6 +58,7 @@ struct _MetaRendererView
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
+  MetaOutput *output;
 };
 
 G_DEFINE_TYPE (MetaRendererView, meta_renderer_view,
@@ -73,6 +76,12 @@ meta_renderer_view_get_crtc (MetaRendererView *view)
   return view->crtc;
 }
 
+MetaOutput *
+meta_renderer_view_get_output (MetaRendererView *view)
+{
+  return view->output;
+}
+
 static void
 meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
@@ -174,6 +183,9 @@ meta_renderer_view_get_property (GObject    *object,
     case PROP_CRTC:
       g_value_set_object (value, view->crtc);
       break;
+    case PROP_OUTPUT:
+      g_value_set_object (value, view->output);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -196,6 +208,9 @@ meta_renderer_view_set_property (GObject      *object,
     case PROP_CRTC:
       view->crtc = g_value_get_object (value);
       break;
+    case PROP_OUTPUT:
+      view->output = g_value_get_object (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -243,5 +258,14 @@ meta_renderer_view_class_init (MetaRendererViewClass *klass)
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_OUTPUT] =
+    g_param_spec_object ("output",
+                         "MetaOutput",
+                         "MetaOutput",
+                         META_TYPE_OUTPUT,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff --git a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
index 3f21c7c48c..ebaf7e0232 100644
--- a/src/backends/meta-renderer-view.h
+++ b/src/backends/meta-renderer-view.h
@@ -31,4 +31,6 @@ MetaMonitorTransform meta_renderer_view_get_transform (MetaRendererView *view);
 
 MetaCrtc *meta_renderer_view_get_crtc (MetaRendererView *view);
 
+MetaOutput *meta_renderer_view_get_output (MetaRendererView *view);
+
 #endif /* META_RENDERER_VIEW_H */
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index d538cc25a4..71e6796715 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1357,6 +1357,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "scale", scale,
                        "framebuffer", framebuffer,
                        "offscreen", offscreen,
diff --git a/src/backends/x11/nested/meta-renderer-x11-nested.c b/src/backends/x11/nested/meta-renderer-x11-nested.c
index 7c1a4facfd..2f9eca5ba3 100644
--- a/src/backends/x11/nested/meta-renderer-x11-nested.c
+++ b/src/backends/x11/nested/meta-renderer-x11-nested.c
@@ -223,6 +223,7 @@ meta_renderer_x11_nested_create_view (MetaRenderer       *renderer,
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "refresh-rate", mode_info->refresh_rate,
                        "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                        "offscreen", COGL_FRAMEBUFFER (offscreen),
-- 
GitLab


From b5c9bd1301c6b26517c83a710c6c3a8201916c0d Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 17:14:03 +0300
Subject: [PATCH 02/23] surface-actor: Add "frozen" signal

This signal is emitted when the surface actor is frozen and will not
update until it is thawed.
---
 src/compositor/meta-surface-actor.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index c2bf6696a2..978ccf9e61 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -51,6 +51,7 @@ enum
 {
   REPAINT_SCHEDULED,
   SIZE_CHANGED,
+  FROZEN,
 
   LAST_SIGNAL,
 };
@@ -269,6 +270,13 @@ meta_surface_actor_class_init (MetaSurfaceActorClass *klass)
                                         0,
                                         NULL, NULL, NULL,
                                         G_TYPE_NONE, 0);
+
+  signals[FROZEN] = g_signal_new ("frozen",
+                                  G_TYPE_FROM_CLASS (object_class),
+                                  G_SIGNAL_RUN_LAST,
+                                  0,
+                                  NULL, NULL, NULL,
+                                  G_TYPE_NONE, 0);
 }
 
 gboolean
@@ -594,6 +602,9 @@ meta_surface_actor_set_frozen (MetaSurfaceActor *self,
 
   priv->frozen = frozen;
 
+  if (frozen)
+    g_signal_emit (self, signals[FROZEN], 0);
+
   if (!frozen && priv->pending_damage)
     {
       int i, n_rects = cairo_region_num_rectangles (priv->pending_damage);
-- 
GitLab


From 0c7c4e4cd97bb22ffdb9831cd47ae69f2c7a4133 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 19:50:45 +0300
Subject: [PATCH 03/23] clutter/stage: Allow scheduling stage updates in the
 context of an actor

This is required synchronizing the frame clock to the update rate of
specific actors in later commits.
---
 clutter/clutter/clutter-stage-view-private.h |  4 +++
 clutter/clutter/clutter-stage-view.c         | 18 ++++++++++++
 clutter/clutter/clutter-stage-view.h         |  3 ++
 clutter/clutter/clutter-stage.c              | 30 ++++++++++++++++++++
 clutter/clutter/clutter-stage.h              |  4 +++
 5 files changed, 59 insertions(+)

diff --git a/clutter/clutter/clutter-stage-view-private.h b/clutter/clutter/clutter-stage-view-private.h
index 39d8601ea5..5c1ce96452 100644
--- a/clutter/clutter/clutter-stage-view-private.h
+++ b/clutter/clutter/clutter-stage-view-private.h
@@ -72,6 +72,10 @@ void clutter_stage_view_transform_rect_to_onscreen (ClutterStageView
 CLUTTER_EXPORT
 void clutter_stage_view_schedule_update (ClutterStageView *view);
 
+CLUTTER_EXPORT
+void clutter_stage_view_schedule_actor_update (ClutterStageView *view,
+                                               ClutterActor     *actor);
+
 CLUTTER_EXPORT
 void clutter_stage_view_notify_presented (ClutterStageView *view,
                                           ClutterFrameInfo *frame_info);
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 2e47237f0a..55d4368bc5 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -1047,6 +1047,22 @@ clutter_stage_view_schedule_update (ClutterStageView *view)
   clutter_frame_clock_schedule_update (priv->frame_clock);
 }
 
+void
+clutter_stage_view_schedule_actor_update (ClutterStageView *view,
+                                          ClutterActor     *actor)
+{
+  ClutterStageViewClass *view_class = CLUTTER_STAGE_VIEW_GET_CLASS (view);
+
+  view_class->schedule_actor_update (view, actor);
+}
+
+static void
+clutter_stage_view_real_schedule_actor_update (ClutterStageView *view,
+                                               ClutterActor     *actor)
+{
+  clutter_stage_view_schedule_update (view);
+}
+
 float
 clutter_stage_view_get_refresh_rate (ClutterStageView *view)
 {
@@ -1443,6 +1459,8 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
   object_class->dispose = clutter_stage_view_dispose;
   object_class->finalize = clutter_stage_view_finalize;
 
+  klass->schedule_actor_update = clutter_stage_view_real_schedule_actor_update;
+
   obj_props[PROP_NAME] =
     g_param_spec_string ("name",
                          "Name",
diff --git a/clutter/clutter/clutter-stage-view.h b/clutter/clutter/clutter-stage-view.h
index c2cf76abf6..0f34cf5b8a 100644
--- a/clutter/clutter/clutter-stage-view.h
+++ b/clutter/clutter/clutter-stage-view.h
@@ -50,6 +50,9 @@ struct _ClutterStageViewClass
                                        int                          dst_width,
                                        int                          dst_height,
                                        cairo_rectangle_int_t       *dst_rect);
+
+  void (* schedule_actor_update) (ClutterStageView *view,
+                                  ClutterActor     *actor);
 };
 
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index e97cd54a3f..3e81655e01 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -2467,6 +2467,36 @@ clutter_stage_schedule_update (ClutterStage *stage)
     }
 }
 
+/**
+ * clutter_stage_schedule_actor_update:
+ * @stage: a #ClutterStage actor
+ * @actor: a #ClutterActor which requires an update
+ *
+ * Schedules a redraw of the #ClutterStage at the next optimal timestamp
+ * for the specified actor.
+ */
+void
+clutter_stage_schedule_actor_update (ClutterStage *stage,
+                                     ClutterActor *actor)
+{
+  ClutterStageWindow *stage_window;
+  GList *l;
+
+  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
+    return;
+
+  stage_window = _clutter_stage_get_window (stage);
+  if (stage_window == NULL)
+    return;
+
+  for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
+    {
+      ClutterStageView *view = l->data;
+
+      clutter_stage_view_schedule_actor_update (view, actor);
+    }
+}
+
 ClutterPaintVolume *
 _clutter_stage_paint_volume_stack_allocate (ClutterStage *stage)
 {
diff --git a/clutter/clutter/clutter-stage.h b/clutter/clutter/clutter-stage.h
index 5412c4d729..a579820a44 100644
--- a/clutter/clutter/clutter-stage.h
+++ b/clutter/clutter/clutter-stage.h
@@ -210,6 +210,10 @@ gboolean        clutter_stage_is_redraw_queued_on_view          (ClutterStage
 CLUTTER_EXPORT
 void clutter_stage_schedule_update (ClutterStage *stage);
 
+CLUTTER_EXPORT
+void clutter_stage_schedule_actor_update (ClutterStage *stage,
+                                          ClutterActor *actor);
+
 CLUTTER_EXPORT
 gboolean clutter_stage_get_capture_final_size (ClutterStage          *stage,
                                                cairo_rectangle_int_t *rect,
-- 
GitLab


From 74f3405a954483d1c1ceaa24025139dbb483f320 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 13 Mar 2021 12:55:09 +0200
Subject: [PATCH 04/23] clutter/frame-clock: Simplify logic around early
 presented event

A few calculations and assignments are done unnecessarily when the
last next presentation time is invalid. This increases the cognitive
complexity of the function for no reason.
---
 clutter/clutter/clutter-frame-clock.c | 46 +++++++++++++--------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 23141f1c93..f822720896 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -406,8 +406,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
-  int64_t last_next_presentation_time_us;
-  int64_t time_since_last_next_presentation_time_us;
   int64_t next_presentation_time_us;
   int64_t next_update_time_us;
 
@@ -509,28 +507,30 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
         refresh_interval_us;
     }
 
-  /*
-   * Skip one interval if we got an early presented event.
-   *
-   *        last frame this was last_presentation_time
-   *       /       frame_clock->next_presentation_time_us
-   *      /       /
-   * |---|-o-----|-x----->
-   *       |       \
-   *       \        next_presentation_time_us is thus right after the last one
-   *        but got an unexpected early presentation
-   *             \_/
-   *             time_since_last_next_presentation_time_us
-   *
-   */
-  last_next_presentation_time_us = frame_clock->next_presentation_time_us;
-  time_since_last_next_presentation_time_us =
-    next_presentation_time_us - last_next_presentation_time_us;
-  if (frame_clock->is_next_presentation_time_valid &&
-      time_since_last_next_presentation_time_us < (refresh_interval_us / 2))
+  if (G_LIKELY (frame_clock->is_next_presentation_time_valid))
     {
-      next_presentation_time_us =
-        frame_clock->next_presentation_time_us + refresh_interval_us;
+      int64_t time_since_last_next_presentation_time_us =
+        next_presentation_time_us - frame_clock->next_presentation_time_us;
+
+      /*
+       * Skip one interval if we got an early presented event.
+       *
+       *        last frame this was last_presentation_time
+       *       /       frame_clock->next_presentation_time_us
+       *      /       /
+       * |---|-o-----|-x----->
+       *       |       \
+       *       \        next_presentation_time_us is thus right after the last one
+       *        but got an unexpected early presentation
+       *             \_/
+       *             time_since_last_next_presentation_time_us
+       *
+       */
+      if (time_since_last_next_presentation_time_us < (refresh_interval_us / 2))
+        {
+          next_presentation_time_us =
+            frame_clock->next_presentation_time_us + refresh_interval_us;
+        }
     }
 
   while (next_presentation_time_us < now_us + min_render_time_allowed_us)
-- 
GitLab


From c6c6dd437ba9ef388129a31115e405a918a60912 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 4 Aug 2020 00:28:12 +0300
Subject: [PATCH 05/23] clutter/frame-clock: Add a mode for variable scheduling

A new variable mode is introduced which allows:
  * Immediate update scheduling, even when an update is already
    scheduled.
  * A timeout-based frame scheduling for every other update.

This mode will be used by following commits to implement
synchronization of page flips to actor frames.
---
 clutter/clutter/clutter-frame-clock.c | 143 ++++++++++++++++++++------
 clutter/clutter/clutter-frame-clock.h |  10 ++
 2 files changed, 120 insertions(+), 33 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index f822720896..9419acf0de 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -47,6 +47,9 @@ typedef struct _EstimateQueue
 
 #define SYNC_DELAY_FALLBACK_FRACTION 0.875
 
+#define PRESENTATION_TIME_INVALID -1
+#define MINIMUM_REFRESH_RATE 30
+
 typedef struct _ClutterFrameListener
 {
   const ClutterFrameListenerIface *iface;
@@ -62,8 +65,8 @@ typedef struct _ClutterClockSource
 
 typedef enum _ClutterFrameClockState
 {
-  CLUTTER_FRAME_CLOCK_STATE_INIT,
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
+  CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
   CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
@@ -75,6 +78,8 @@ struct _ClutterFrameClock
 
   float refresh_rate;
   int64_t refresh_interval_us;
+  int64_t minimum_refresh_interval_us;
+
   ClutterFrameListener listener;
 
   GSource *source;
@@ -82,11 +87,12 @@ struct _ClutterFrameClock
   int64_t frame_count;
 
   ClutterFrameClockState state;
+  ClutterFrameClockMode mode;
+
   int64_t last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
-  int64_t last_presentation_time_us;
 
-  gboolean is_next_presentation_time_valid;
+  int64_t last_presentation_time_us;
   int64_t next_presentation_time_us;
 
   /* Buffer must be submitted to KMS and GPU rendering must be finished
@@ -270,7 +276,10 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     }
 #endif
 
-  frame_clock->last_presentation_time_us = frame_info->presentation_time;
+  if (frame_info->presentation_time > 0)
+    frame_clock->last_presentation_time_us = frame_info->presentation_time;
+  else
+    frame_clock->last_presentation_time_us = PRESENTATION_TIME_INVALID;
 
   frame_clock->got_measurements_last_frame = FALSE;
 
@@ -312,8 +321,8 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -332,8 +341,8 @@ clutter_frame_clock_notify_ready (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -398,12 +407,12 @@ clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
 
 static void
 calculate_next_update_time_us (ClutterFrameClock *frame_clock,
+                               int64_t            refresh_interval_us,
                                int64_t           *out_next_update_time_us,
                                int64_t           *out_next_presentation_time_us)
 {
   int64_t last_presentation_time_us;
   int64_t now_us;
-  int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
   int64_t next_presentation_time_us;
@@ -411,9 +420,9 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 
   now_us = g_get_monotonic_time ();
 
-  refresh_interval_us = frame_clock->refresh_interval_us;
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
 
-  if (frame_clock->last_presentation_time_us == 0)
+  if (last_presentation_time_us == PRESENTATION_TIME_INVALID)
     {
       *out_next_update_time_us =
         frame_clock->last_dispatch_time_us ?
@@ -421,7 +430,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
           frame_clock->last_dispatch_lateness_us) + refresh_interval_us) :
         now_us;
 
-      *out_next_presentation_time_us = 0;
+      *out_next_presentation_time_us = PRESENTATION_TIME_INVALID;
       return;
     }
 
@@ -449,7 +458,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
    * 0
    *
    */
-  last_presentation_time_us = frame_clock->last_presentation_time_us;
   next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
 
   /*
@@ -507,7 +515,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
         refresh_interval_us;
     }
 
-  if (G_LIKELY (frame_clock->is_next_presentation_time_valid))
+  if (G_LIKELY (frame_clock->next_presentation_time_us != PRESENTATION_TIME_INVALID))
     {
       int64_t time_since_last_next_presentation_time_us =
         next_presentation_time_us - frame_clock->next_presentation_time_us;
@@ -542,6 +550,37 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   *out_next_presentation_time_us = next_presentation_time_us;
 }
 
+static void
+calculate_timeout_update_time_us (ClutterFrameClock *frame_clock,
+                                  int64_t            timeout_us,
+                                  int64_t           *out_next_update_time_us)
+{
+  int64_t now_us;
+  int64_t last_presentation_time_us;
+  int64_t next_update_time_us;
+
+  now_us = g_get_monotonic_time ();
+
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
+
+  if (last_presentation_time_us == PRESENTATION_TIME_INVALID)
+    {
+      *out_next_update_time_us =
+        frame_clock->last_dispatch_time_us ?
+        ((frame_clock->last_dispatch_time_us -
+          frame_clock->last_dispatch_lateness_us) + timeout_us) :
+        now_us;
+      return;
+    }
+
+  next_update_time_us = last_presentation_time_us + timeout_us;
+
+  while (next_update_time_us < now_us)
+    next_update_time_us += timeout_us;
+
+  *out_next_update_time_us = next_update_time_us;
+}
+
 void
 clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
 {
@@ -551,9 +590,9 @@ clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
     {
       switch (frame_clock->state)
         {
-        case CLUTTER_FRAME_CLOCK_STATE_INIT:
         case CLUTTER_FRAME_CLOCK_STATE_IDLE:
           break;
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
         case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
           frame_clock->pending_reschedule = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
@@ -581,8 +620,6 @@ clutter_frame_clock_uninhibit (ClutterFrameClock *frame_clock)
 void
 clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 {
-  int64_t next_update_time_us = -1;
-
   if (frame_clock->inhibit_count > 0)
     {
       frame_clock->pending_reschedule = TRUE;
@@ -592,9 +629,8 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      next_update_time_us = g_get_monotonic_time ();
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
@@ -605,11 +641,9 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
       return;
     }
 
-  g_warn_if_fail (next_update_time_us != -1);
-
-  g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  g_source_set_ready_time (frame_clock->source, 0);
+  frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
   frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
-  frame_clock->is_next_presentation_time_valid = FALSE;
 }
 
 void
@@ -625,16 +659,9 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
-      next_update_time_us = g_get_monotonic_time ();
-      break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      calculate_next_update_time_us (frame_clock,
-                                     &next_update_time_us,
-                                     &frame_clock->next_presentation_time_us);
-      frame_clock->is_next_presentation_time_valid =
-        (frame_clock->next_presentation_time_us != 0);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -643,10 +670,53 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
       return;
     }
 
+  switch (frame_clock->mode)
+    {
+    case CLUTTER_FRAME_CLOCK_MODE_FIXED:
+      calculate_next_update_time_us (frame_clock,
+                                     frame_clock->refresh_interval_us,
+                                     &next_update_time_us,
+                                     &frame_clock->next_presentation_time_us);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      break;
+    case CLUTTER_FRAME_CLOCK_MODE_VARIABLE:
+      calculate_timeout_update_time_us (frame_clock,
+                                        frame_clock->minimum_refresh_interval_us,
+                                        &next_update_time_us);
+      frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT;
+      break;
+    }
+
   g_warn_if_fail (next_update_time_us != -1);
 
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+}
+
+void
+clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                              ClutterFrameClockMode  mode)
+{
+  if (frame_clock->mode == mode)
+    return;
+
+  frame_clock->mode = mode;
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+      frame_clock->pending_reschedule = TRUE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      break;
+    }
+
+  maybe_reschedule_update (frame_clock);
 }
 
 static void
@@ -692,7 +762,7 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
   COGL_TRACE_END (ClutterFrameClockEvents);
 
   COGL_TRACE_BEGIN (ClutterFrameClockTimelines, "Frame Clock (timelines)");
-  if (frame_clock->is_next_presentation_time_valid)
+  if (frame_clock->next_presentation_time_us != PRESENTATION_TIME_INVALID)
     time_us = frame_clock->next_presentation_time_us;
   advance_timelines (frame_clock, time_us);
   COGL_TRACE_END (ClutterFrameClockTimelines);
@@ -705,11 +775,11 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       g_warn_if_reached ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -850,6 +920,10 @@ clutter_frame_clock_new (float                            refresh_rate,
   init_frame_clock_source (frame_clock);
 
   clutter_frame_clock_set_refresh_rate (frame_clock, refresh_rate);
+
+  frame_clock->minimum_refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / MINIMUM_REFRESH_RATE);
+
   frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
@@ -880,7 +954,10 @@ clutter_frame_clock_dispose (GObject *object)
 static void
 clutter_frame_clock_init (ClutterFrameClock *frame_clock)
 {
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_INIT;
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+  frame_clock->mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
+  frame_clock->last_presentation_time_us = PRESENTATION_TIME_INVALID;
+  frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
 }
 
 static void
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index 91e6b3a130..0b2325a56d 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -53,6 +53,12 @@ typedef struct _ClutterFrameListenerIface
                                 gpointer           user_data);
 } ClutterFrameListenerIface;
 
+typedef enum _ClutterFrameClockMode
+{
+  CLUTTER_FRAME_CLOCK_MODE_FIXED,
+  CLUTTER_FRAME_CLOCK_MODE_VARIABLE
+} ClutterFrameClockMode;
+
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
                                              int64_t                          vblank_duration_us,
@@ -62,6 +68,10 @@ ClutterFrameClock * clutter_frame_clock_new (float                            re
 CLUTTER_EXPORT
 void clutter_frame_clock_destroy (ClutterFrameClock *frame_clock);
 
+CLUTTER_EXPORT
+void clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                                   ClutterFrameClockMode  mode);
+
 CLUTTER_EXPORT
 void clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                            ClutterFrameInfo  *frame_info);
-- 
GitLab


From ac5f155c2b7802dd8929fd314ad77f578de20ee1 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Fri, 10 Jul 2020 18:40:07 +0300
Subject: [PATCH 06/23] backends/native: Introduce MetaRendererViewNative

MetaRendererViewNative is a MetaRendererView which contains logic
specific to views of the native backend. It will be used by following
commits.

In the future, per-view logic from MetaRendererNative can be moved to
MetaRendererViewNative where it makes more sense to have it.
---
 src/backends/meta-renderer-view.c             | 54 ++++++++++++-------
 src/backends/meta-renderer-view.h             | 11 ++--
 src/backends/native/meta-renderer-native.c    | 36 +++++++------
 .../native/meta-renderer-view-native.c        | 43 +++++++++++++++
 .../native/meta-renderer-view-native.h        | 34 ++++++++++++
 src/meson.build                               |  2 +
 6 files changed, 142 insertions(+), 38 deletions(-)
 create mode 100644 src/backends/native/meta-renderer-view-native.c
 create mode 100644 src/backends/native/meta-renderer-view-native.h

diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index 2e0ddf943f..348ce0fb8c 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -51,35 +51,42 @@ enum
 
 static GParamSpec *obj_props[PROP_LAST];
 
-struct _MetaRendererView
+typedef struct _MetaRendererViewPrivate
 {
-  MetaStageView parent;
-
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
   MetaOutput *output;
-};
+} MetaRendererViewPrivate;
 
-G_DEFINE_TYPE (MetaRendererView, meta_renderer_view,
-               META_TYPE_STAGE_VIEW)
+G_DEFINE_TYPE_WITH_PRIVATE (MetaRendererView, meta_renderer_view,
+                            META_TYPE_STAGE_VIEW)
 
 MetaMonitorTransform
 meta_renderer_view_get_transform (MetaRendererView *view)
 {
-  return view->transform;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->transform;
 }
 
 MetaCrtc *
 meta_renderer_view_get_crtc (MetaRendererView *view)
 {
-  return view->crtc;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->crtc;
 }
 
 MetaOutput *
 meta_renderer_view_get_output (MetaRendererView *view)
 {
-  return view->output;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->output;
 }
 
 static void
@@ -87,10 +94,12 @@ meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
 {
   MetaRendererView *renderer_view = META_RENDERER_VIEW (view);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (renderer_view);
 
   graphene_matrix_init_identity (matrix);
 
-  switch (renderer_view->transform)
+  switch (priv->transform)
     {
     case META_MONITOR_TRANSFORM_NORMAL:
       break;
@@ -145,10 +154,12 @@ meta_renderer_view_transform_rect_to_onscreen (ClutterStageView            *view
                                                cairo_rectangle_int_t       *dst_rect)
 {
   MetaRendererView *renderer_view = META_RENDERER_VIEW (view);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (renderer_view);
   MetaMonitorTransform inverted_transform;
 
   inverted_transform =
-    meta_monitor_transform_invert (renderer_view->transform);
+    meta_monitor_transform_invert (priv->transform);
   return meta_rectangle_transform (src_rect,
                                    inverted_transform,
                                    dst_width,
@@ -160,10 +171,13 @@ static void
 meta_renderer_view_set_transform (MetaRendererView     *view,
                                   MetaMonitorTransform  transform)
 {
-  if (view->transform == transform)
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  if (priv->transform == transform)
     return;
 
-  view->transform = transform;
+  priv->transform = transform;
   clutter_stage_view_invalidate_offscreen_blit_pipeline (CLUTTER_STAGE_VIEW (view));
 }
 
@@ -174,17 +188,19 @@ meta_renderer_view_get_property (GObject    *object,
                                  GParamSpec *pspec)
 {
   MetaRendererView *view = META_RENDERER_VIEW (object);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
 
   switch (prop_id)
     {
     case PROP_TRANSFORM:
-      g_value_set_uint (value, view->transform);
+      g_value_set_uint (value, priv->transform);
       break;
     case PROP_CRTC:
-      g_value_set_object (value, view->crtc);
+      g_value_set_object (value, priv->crtc);
       break;
     case PROP_OUTPUT:
-      g_value_set_object (value, view->output);
+      g_value_set_object (value, priv->output);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -199,6 +215,8 @@ meta_renderer_view_set_property (GObject      *object,
                                  GParamSpec   *pspec)
 {
   MetaRendererView *view = META_RENDERER_VIEW (object);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
 
   switch (prop_id)
     {
@@ -206,10 +224,10 @@ meta_renderer_view_set_property (GObject      *object,
       meta_renderer_view_set_transform (view, g_value_get_uint (value));
       break;
     case PROP_CRTC:
-      view->crtc = g_value_get_object (value);
+      priv->crtc = g_value_get_object (value);
       break;
     case PROP_OUTPUT:
-      view->output = g_value_get_object (value);
+      priv->output = g_value_get_object (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
diff --git a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
index ebaf7e0232..d0a5166614 100644
--- a/src/backends/meta-renderer-view.h
+++ b/src/backends/meta-renderer-view.h
@@ -23,9 +23,14 @@
 #include "backends/meta-stage-view-private.h"
 
 #define META_TYPE_RENDERER_VIEW (meta_renderer_view_get_type ())
-G_DECLARE_FINAL_TYPE (MetaRendererView, meta_renderer_view,
-                      META, RENDERER_VIEW,
-                      MetaStageView)
+G_DECLARE_DERIVABLE_TYPE (MetaRendererView, meta_renderer_view,
+                          META, RENDERER_VIEW,
+                          MetaStageView)
+
+struct _MetaRendererViewClass
+{
+  MetaStageViewClass parent_class;
+};
 
 MetaMonitorTransform meta_renderer_view_get_transform (MetaRendererView *view);
 
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 71e6796715..fdfe4a35f1 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -61,6 +61,7 @@
 #include "backends/native/meta-output-kms.h"
 #include "backends/native/meta-render-device-gbm.h"
 #include "backends/native/meta-render-device-surfaceless.h"
+#include "backends/native/meta-renderer-view-native.h"
 #include "backends/native/meta-renderer-native-private.h"
 #include "cogl/cogl.h"
 #include "core/boxes-private.h"
@@ -1240,7 +1241,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
   int onscreen_width;
   int onscreen_height;
   MetaRectangle view_layout;
-  MetaRendererView *view;
+  MetaRendererViewNative *view_native;
   EGLSurface egl_surface;
   GError *error = NULL;
 
@@ -1352,27 +1353,28 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
   meta_rectangle_from_graphene_rect (&crtc_config->layout,
                                      META_ROUNDING_STRATEGY_ROUND,
                                      &view_layout);
-  view = g_object_new (META_TYPE_RENDERER_VIEW,
-                       "name", meta_output_get_name (output),
-                       "stage", meta_backend_get_stage (backend),
-                       "layout", &view_layout,
-                       "crtc", crtc,
-                       "output", output,
-                       "scale", scale,
-                       "framebuffer", framebuffer,
-                       "offscreen", offscreen,
-                       "use-shadowfb", use_shadowfb,
-                       "transform", view_transform,
-                       "refresh-rate", crtc_mode_info->refresh_rate,
-                       "vblank-duration-us", crtc_mode_info->vblank_duration_us,
-                       NULL);
+  view_native = g_object_new (META_TYPE_RENDERER_VIEW_NATIVE,
+                              "name", meta_output_get_name (output),
+                              "stage", meta_backend_get_stage (backend),
+                              "layout", &view_layout,
+                              "crtc", crtc,
+                              "output", output,
+                              "scale", scale,
+                              "framebuffer", framebuffer,
+                              "offscreen", offscreen,
+                              "use-shadowfb", use_shadowfb,
+                              "transform", view_transform,
+                              "refresh-rate", crtc_mode_info->refresh_rate,
+                              "vblank-duration-us", crtc_mode_info->vblank_duration_us,
+                              NULL);
 
   if (META_IS_ONSCREEN_NATIVE (framebuffer))
     {
       CoglDisplayEGL *cogl_display_egl;
       CoglOnscreenEgl *onscreen_egl;
 
-      meta_onscreen_native_set_view (COGL_ONSCREEN (framebuffer), view);
+      meta_onscreen_native_set_view (COGL_ONSCREEN (framebuffer),
+                                     META_RENDERER_VIEW (view_native));
 
       /* Ensure we don't point to stale surfaces when creating the offscreen */
       cogl_display_egl = cogl_display->winsys;
@@ -1384,7 +1386,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                                      cogl_display_egl->egl_context);
     }
 
-  return view;
+  return META_RENDERER_VIEW (view_native);
 }
 
 static void
diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
new file mode 100644
index 0000000000..38fd0453d9
--- /dev/null
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -0,0 +1,43 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2020 Dor Askayo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by:
+ *     Dor Askayo <dor.askayo@gmail.com>
+ */
+
+#include "backends/native/meta-renderer-view-native.h"
+
+struct _MetaRendererViewNative
+{
+  MetaRendererView parent;
+};
+
+G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
+               META_TYPE_RENDERER_VIEW);
+
+static void
+meta_renderer_view_native_init (MetaRendererViewNative *view_native)
+{
+}
+
+static void
+meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
+{
+}
diff --git a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
new file mode 100644
index 0000000000..e420640069
--- /dev/null
+++ b/src/backends/native/meta-renderer-view-native.h
@@ -0,0 +1,34 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2020 Dor Askayo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by:
+ *     Dor Askayo <dor.askayo@gmail.com>
+ */
+
+#ifndef META_RENDERER_VIEW_NATIVE_H
+#define META_RENDERER_VIEW_NATIVE_H
+
+#include "backends/meta-renderer-view.h"
+
+#define META_TYPE_RENDERER_VIEW_NATIVE (meta_renderer_view_native_get_type ())
+G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
+                      META, RENDERER_VIEW_NATIVE, MetaRendererView)
+
+#endif /* META_RENDERER_VIEW_NATIVE_H */
diff --git a/src/meson.build b/src/meson.build
index f752f03d96..d3d1ae0f49 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -775,6 +775,8 @@ if have_native_backend
     'backends/native/meta-renderer-native-private.h',
     'backends/native/meta-renderer-native.c',
     'backends/native/meta-renderer-native.h',
+    'backends/native/meta-renderer-view-native.c',
+    'backends/native/meta-renderer-view-native.h',
     'backends/native/meta-seat-impl.c',
     'backends/native/meta-seat-impl.h',
     'backends/native/meta-seat-native.c',
-- 
GitLab


From ff121f0833b6a20b35efe5a18b15f8dfa9b72094 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 4 Jul 2020 22:13:55 +0300
Subject: [PATCH 07/23] renderer-view/native: Allow syncing frame clock updates
 with actor updates

Allow per-view tracking of actors for the purpose of synchronizing
the frame clock to their updates.

This uses the variable mode of ClutterFrameClock to either perform an
immediate update or a delayed update depending on whether the update
is performed in the context of the tracked actor or a different one.

This approach achieves a minimal latency between updates of the actor
and updates of the view, and delays updates of the view when the
tracked actor has not updated.

Changes in the synchronization mode are applied asynchronously at the
preparation phase of the next frame.

If the tracked actor is frozen or destroyed, the synchornization is
stopped as no further updates from the actor are expected.

For now, the only applicable synchronization mode is
META_FRAME_SYNC_MODE_DISABLED, which doesn't synchronize to actor
updates and keeps the frame clock on the its default fixed mode.
When support for VRR is added in the commits to follow,
META_FRAME_SYNC_MODE_ENABLED will be set when appropriate.
---
 src/backends/native/meta-renderer-native.c    |   1 +
 .../native/meta-renderer-view-native.c        | 158 ++++++++++++++++++
 .../native/meta-renderer-view-native.h        |   5 +
 3 files changed, 164 insertions(+)

diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index fdfe4a35f1..8fc365ea02 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1454,6 +1454,7 @@ meta_renderer_native_prepare_frame (MetaRendererNative *renderer_native,
   kms_device = meta_kms_crtc_get_device (kms_crtc);
 
   meta_crtc_kms_maybe_set_gamma (crtc_kms, kms_device);
+  meta_renderer_view_native_maybe_set_frame_sync (META_RENDERER_VIEW_NATIVE (view));
 }
 
 void
diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
index 38fd0453d9..14f3c543b2 100644
--- a/src/backends/native/meta-renderer-view-native.c
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -24,20 +24,178 @@
 
 #include "backends/native/meta-renderer-view-native.h"
 
+#include "clutter/clutter.h"
+
+typedef enum _MetaFrameSyncMode
+{
+  META_FRAME_SYNC_MODE_INIT,
+  META_FRAME_SYNC_MODE_ENABLED,
+  META_FRAME_SYNC_MODE_DISABLED
+} MetaFrameSyncMode;
+
 struct _MetaRendererViewNative
 {
   MetaRendererView parent;
+
+  gboolean frame_sync_mode_update_queued;
+
+  MetaFrameSyncMode frame_sync_mode;
+  ClutterActor *frame_sync_actor;
+
+  gulong frame_sync_actor_frozen_id;
+  gulong frame_sync_actor_destroy_id;
 };
 
 G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                META_TYPE_RENDERER_VIEW);
 
+static void
+on_frame_sync_actor_frozen (ClutterActor           *actor,
+                            MetaRendererViewNative *view_native)
+{
+  meta_renderer_view_native_set_frame_sync_actor (view_native, NULL);
+}
+
+static void
+on_frame_sync_actor_destroyed (ClutterActor           *actor,
+                               MetaRendererViewNative *view_native)
+{
+  meta_renderer_view_native_set_frame_sync_actor (view_native, NULL);
+}
+
+static void
+meta_renderer_view_native_schedule_actor_update (ClutterStageView *stage_view,
+                                                 ClutterActor     *actor)
+{
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+  ClutterFrameClock *frame_clock;
+
+  g_return_if_fail (actor != NULL);
+
+  frame_clock = clutter_stage_view_get_frame_clock (stage_view);
+
+  if (view_native->frame_sync_mode == META_FRAME_SYNC_MODE_ENABLED &&
+      actor == view_native->frame_sync_actor)
+    clutter_frame_clock_schedule_update_now (frame_clock);
+  else
+    clutter_frame_clock_schedule_update (frame_clock);
+}
+
+void
+meta_renderer_view_native_set_frame_sync_actor (MetaRendererViewNative *view_native,
+                                                ClutterActor           *actor)
+{
+  if (G_LIKELY (actor == view_native->frame_sync_actor))
+    return;
+
+  if (view_native->frame_sync_actor)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_actor_frozen_id,
+                              view_native->frame_sync_actor);
+      g_clear_signal_handler (&view_native->frame_sync_actor_destroy_id,
+                              view_native->frame_sync_actor);
+    }
+
+  if (actor)
+    {
+      view_native->frame_sync_actor_frozen_id =
+      g_signal_connect (actor, "frozen",
+                        G_CALLBACK (on_frame_sync_actor_frozen),
+                        view_native);
+      view_native->frame_sync_actor_destroy_id =
+      g_signal_connect (actor, "destroy",
+                        G_CALLBACK (on_frame_sync_actor_destroyed),
+                        view_native);
+    }
+
+  view_native->frame_sync_actor = actor;
+
+  view_native->frame_sync_mode_update_queued = TRUE;
+}
+
+static void
+meta_renderer_view_native_set_frame_sync (MetaRendererViewNative *view_native,
+                                          MetaFrameSyncMode       sync_mode)
+{
+  ClutterFrameClock *frame_clock =
+    clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+
+  switch (sync_mode)
+    {
+    case META_FRAME_SYNC_MODE_ENABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_VARIABLE);
+      break;
+    case META_FRAME_SYNC_MODE_DISABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_FIXED);
+      break;
+    case META_FRAME_SYNC_MODE_INIT:
+      g_assert_not_reached ();
+    }
+
+  view_native->frame_sync_mode = sync_mode;
+}
+
+static MetaFrameSyncMode
+meta_renderer_view_native_get_applicable_sync_mode (MetaRendererViewNative *view_native)
+{
+  return META_FRAME_SYNC_MODE_DISABLED;
+}
+
+void
+meta_renderer_view_native_maybe_set_frame_sync (MetaRendererViewNative *view_native)
+{
+  MetaFrameSyncMode applicable_sync_mode;
+
+  if (G_LIKELY (!view_native->frame_sync_mode_update_queued))
+    return;
+
+  view_native->frame_sync_mode_update_queued = FALSE;
+
+  applicable_sync_mode =
+    meta_renderer_view_native_get_applicable_sync_mode (view_native);
+
+  if (applicable_sync_mode != view_native->frame_sync_mode)
+    {
+      meta_renderer_view_native_set_frame_sync (view_native,
+                                                applicable_sync_mode);
+    }
+}
+
+static void
+meta_renderer_view_native_dispose (GObject *object)
+{
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (object);
+
+  if (view_native->frame_sync_actor)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_actor_destroy_id,
+                              view_native->frame_sync_actor);
+      g_clear_signal_handler (&view_native->frame_sync_actor_frozen_id,
+                              view_native->frame_sync_actor);
+    }
+
+  G_OBJECT_CLASS (meta_renderer_view_native_parent_class)->dispose (object);
+}
+
 static void
 meta_renderer_view_native_init (MetaRendererViewNative *view_native)
 {
+  view_native->frame_sync_mode_update_queued = TRUE;
+  view_native->frame_sync_mode = META_FRAME_SYNC_MODE_INIT;
+  view_native->frame_sync_actor = NULL;
+  view_native->frame_sync_actor_frozen_id = 0;
+  view_native->frame_sync_actor_destroy_id = 0;
 }
 
 static void
 meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
 {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  ClutterStageViewClass *clutter_stage_view_class = CLUTTER_STAGE_VIEW_CLASS (klass);
+
+  object_class->dispose = meta_renderer_view_native_dispose;
+
+  clutter_stage_view_class->schedule_actor_update = meta_renderer_view_native_schedule_actor_update;
 }
diff --git a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
index e420640069..07f90ffb76 100644
--- a/src/backends/native/meta-renderer-view-native.h
+++ b/src/backends/native/meta-renderer-view-native.h
@@ -31,4 +31,9 @@
 G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                       META, RENDERER_VIEW_NATIVE, MetaRendererView)
 
+void meta_renderer_view_native_set_frame_sync_actor (MetaRendererViewNative *view_native,
+                                                     ClutterActor           *actor);
+
+void meta_renderer_view_native_maybe_set_frame_sync (MetaRendererViewNative *view_native);
+
 #endif /* META_RENDERER_VIEW_NATIVE_H */
-- 
GitLab


From ddfce785b699d1bd405ff689143680683f780f01 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 20:11:48 +0300
Subject: [PATCH 08/23] wayland/actor-surface: Schedule actor updates for frame
 callbacks

---
 src/wayland/meta-wayland-actor-surface.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index b6d26fdc11..096b46aa2a 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -307,7 +307,8 @@ meta_wayland_actor_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
       MetaBackend *backend = meta_get_backend ();
       ClutterActor *stage = meta_backend_get_stage (backend);
 
-      clutter_stage_schedule_update (CLUTTER_STAGE (stage));
+      clutter_stage_schedule_actor_update (CLUTTER_STAGE (stage),
+                                           CLUTTER_ACTOR (priv->actor));
     }
 
   meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
-- 
GitLab


From 157452e0c41355dac5695ef45e4d4a4e9430f229 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 10:07:54 +0300
Subject: [PATCH 09/23] clutter/stage: Always schedule actor updates on redraw

When updates are scheduled in the context of specific actors,
already-scheduled updates may need to be rescheduled based on the
actor requesting the update.

Allow scheduling updates for actors when the stage is already
pending a redraw.
---
 clutter/clutter/clutter-stage.c | 21 +--------------------
 1 file changed, 1 insertion(+), 20 deletions(-)

diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 3e81655e01..f40df1017d 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -127,8 +127,6 @@ struct _ClutterStagePrivate
 
   int update_freeze_count;
 
-  gboolean pending_finish_queue_redraws;
-
   GHashTable *pointer_devices;
   GHashTable *touch_sequences;
 
@@ -2548,19 +2546,7 @@ clutter_stage_queue_actor_redraw (ClutterStage             *stage,
   CLUTTER_NOTE (CLIPPING, "stage_queue_actor_redraw (actor=%s, clip=%p): ",
                 _clutter_actor_get_debug_name (actor), clip);
 
-  if (!priv->pending_finish_queue_redraws)
-    {
-      GList *l;
-
-      for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
-        {
-          ClutterStageView *view = l->data;
-
-          clutter_stage_view_schedule_update (view);
-        }
-
-      priv->pending_finish_queue_redraws = TRUE;
-    }
+  clutter_stage_schedule_actor_update (stage, actor);
 
   entry = g_hash_table_lookup (priv->pending_queue_redraws, actor);
 
@@ -2684,11 +2670,6 @@ clutter_stage_maybe_finish_queue_redraws (ClutterStage *stage)
 
   COGL_TRACE_BEGIN_SCOPED (ClutterStageFinishQueueRedraws, "FinishQueueRedraws");
 
-  if (!priv->pending_finish_queue_redraws)
-    return;
-
-  priv->pending_finish_queue_redraws = FALSE;
-
   g_hash_table_iter_init (&iter, priv->pending_queue_redraws);
   while (g_hash_table_iter_next (&iter, &key, &value))
     {
-- 
GitLab


From c57463c2df8709ce10586ab82e0f79c2ae287218 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:39:49 +0200
Subject: [PATCH 10/23] window: Allow indicating that variable refresh rate is
 supported

---
 src/core/window-private.h |  7 +++++++
 src/core/window.c         | 24 ++++++++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/src/core/window-private.h b/src/core/window-private.h
index 8d2d4a0203..f337dfef89 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -562,6 +562,8 @@ struct _MetaWindow
   GFile *cgroup_path;
 
   unsigned int events_during_ping;
+
+  gboolean vrr_supported;
 };
 
 struct _MetaWindowClass
@@ -826,6 +828,11 @@ void meta_window_set_transient_for        (MetaWindow *window,
 void meta_window_set_opacity              (MetaWindow *window,
                                            guint8      opacity);
 
+void meta_window_set_vrr_supported (MetaWindow *window,
+                                    gboolean    vrr_supported);
+
+gboolean meta_window_get_vrr_supported (MetaWindow *window);
+
 void meta_window_handle_enter (MetaWindow  *window,
                                guint32      timestamp,
                                guint        root_x,
diff --git a/src/core/window.c b/src/core/window.c
index 95a8e33e04..175a01d342 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -2784,6 +2784,30 @@ meta_window_is_on_primary_monitor (MetaWindow *window)
   return window->monitor->is_primary;
 }
 
+/**
+ * meta_window_set_vrr_supported:
+ * @window: a #MetaWindow
+ * @vrr_supported: whether the window supports variable refresh rate
+ */
+void
+meta_window_set_vrr_supported (MetaWindow *window,
+                               gboolean    vrr_supported)
+{
+  window->vrr_supported = vrr_supported;
+}
+
+/**
+ * meta_window_get_vrr_supported:
+ * @window: a #MetaWindow
+ *
+ * Return value: %TRUE if the window supports variable refresh rate
+ */
+gboolean
+meta_window_get_vrr_supported (MetaWindow *window)
+{
+  return window->vrr_supported;
+}
+
 static void
 meta_window_get_tile_fraction (MetaWindow   *window,
                                MetaTileMode  tile_mode,
-- 
GitLab


From 39832e071ca01eceab176a9799ae80bf9d6c7f96 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 11 Jun 2022 12:50:02 +0300
Subject: [PATCH 11/23] window: Allow checking if a window covers a rect

This is just a small function to improve the readability of the code.
---
 src/core/window-private.h | 3 +++
 src/core/window.c         | 8 ++++++++
 2 files changed, 11 insertions(+)

diff --git a/src/core/window-private.h b/src/core/window-private.h
index f337dfef89..6c6b483c60 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -718,6 +718,9 @@ void        meta_window_get_session_geometry (MetaWindow  *window,
                                               int         *width,
                                               int         *height);
 
+gboolean    meta_window_contains_rect (MetaWindow    *window,
+                                       MetaRectangle *rect);
+
 void        meta_window_update_unfocused_button_grabs (MetaWindow *window);
 
 void        meta_window_update_appears_focused (MetaWindow *window);
diff --git a/src/core/window.c b/src/core/window.c
index 175a01d342..fed841ed49 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -4274,6 +4274,14 @@ meta_window_get_session_geometry (MetaWindow  *window,
     window->size_hints.height_inc;
 }
 
+gboolean
+meta_window_contains_rect (MetaWindow    *window,
+                           MetaRectangle *rect)
+{
+  return meta_rectangle_contains_rect (&window->buffer_rect,
+                                       rect);
+}
+
 /**
  * meta_window_get_buffer_rect:
  * @window: a #MetaWindow
-- 
GitLab


From 8eb6a859916a685d2a8317abd63962e69bae10f9 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 11 Jun 2022 13:03:24 +0300
Subject: [PATCH 12/23] workspace: Allow searching for the topmost window
 overlapping a rect

This is useful for determining if a window is the topmost window in
a view.
---
 src/core/workspace-private.h |  3 +++
 src/core/workspace.c         | 22 ++++++++++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/src/core/workspace-private.h b/src/core/workspace-private.h
index f0d896f6cd..67abc89df9 100644
--- a/src/core/workspace-private.h
+++ b/src/core/workspace-private.h
@@ -92,6 +92,9 @@ GList* meta_workspace_get_onscreen_region       (MetaWorkspace *workspace);
 GList * meta_workspace_get_onmonitor_region (MetaWorkspace      *workspace,
                                              MetaLogicalMonitor *logical_monitor);
 
+MetaWindow * meta_workspace_topmost_window_on_rect (MetaWorkspace *workspace,
+                                                    MetaRectangle *rect);
+
 MetaWindow * meta_workspace_get_default_focus_window (MetaWorkspace *workspace);
 void meta_workspace_focus_default_window (MetaWorkspace *workspace,
                                           MetaWindow    *not_this_one,
diff --git a/src/core/workspace.c b/src/core/workspace.c
index 3bd517fca6..dd2feb5fe4 100644
--- a/src/core/workspace.c
+++ b/src/core/workspace.c
@@ -1327,6 +1327,28 @@ meta_workspace_get_default_focus_window (MetaWorkspace *workspace)
     }
 }
 
+MetaWindow *
+meta_workspace_topmost_window_on_rect (MetaWorkspace *workspace,
+                                       MetaRectangle *rect)
+{
+  GList *stack = workspace->display->stack->sorted;
+  GList *l;
+
+  for (l = stack; l != NULL; l = l->next)
+    {
+      MetaWindow *window = l->data;
+      MetaRectangle *window_frame_rect = &window->rect;
+
+      if (!meta_window_located_on_workspace (window, workspace))
+        continue;
+
+      if (meta_rectangle_overlap (window_frame_rect, rect))
+        return window;
+    }
+
+  return NULL;
+}
+
 void
 meta_workspace_focus_default_window (MetaWorkspace *workspace,
                                      MetaWindow    *not_this_one,
-- 
GitLab


From 98fbf055e7d4fe081c46250a2c8a455595b769e6 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 14 Jun 2022 01:04:03 +0300
Subject: [PATCH 13/23] surface-actor: Allow checking if a surface actor covers
 a rect

---
 src/compositor/meta-surface-actor.c | 20 ++++++++++++++++++++
 src/compositor/meta-surface-actor.h |  3 +++
 2 files changed, 23 insertions(+)

diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index 978ccf9e61..883eb7c398 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -521,6 +521,26 @@ meta_surface_actor_is_obscured_on_stage_view (MetaSurfaceActor *self,
                                                       stage_view);
 }
 
+gboolean
+meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                  MetaRectangle    *rect)
+{
+  ClutterActor *actor = CLUTTER_ACTOR (surface_actor);
+  MetaRectangle surface_rect;
+  float x, y, width, height;
+
+  clutter_actor_get_position (actor, &x, &y);
+  clutter_actor_get_size (actor, &width, &height);
+
+  surface_rect = META_RECTANGLE_INIT (ceilf (x),
+                                      ceilf (y),
+                                      ceilf (width),
+                                      ceilf (height));
+
+  return meta_rectangle_contains_rect (&surface_rect,
+                                       rect);
+}
+
 void
 meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                      cairo_region_t   *region)
diff --git a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
index f69cb15275..3128f513cd 100644
--- a/src/compositor/meta-surface-actor.h
+++ b/src/compositor/meta-surface-actor.h
@@ -40,6 +40,9 @@ gboolean meta_surface_actor_is_obscured_on_stage_view (MetaSurfaceActor *self,
                                                        ClutterStageView *stage_view,
                                                        float            *unobscurred_fraction);
 
+gboolean meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                           MetaRectangle    *rect);
+
 void meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                           cairo_region_t   *region);
 void meta_surface_actor_set_opaque_region (MetaSurfaceActor *self,
-- 
GitLab


From a49f32b2ba0480cd08d8d2b8715e5c3ca3271636 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 01:44:25 +0200
Subject: [PATCH 14/23] compositor/native: Request frame sync for compatible
 windows

---
 src/compositor/meta-compositor-native.c | 20 +++++-
 src/compositor/meta-compositor-native.h |  3 +
 src/compositor/meta-window-actor.c      | 86 +++++++++++++++++++++++++
 3 files changed, 108 insertions(+), 1 deletion(-)

diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index bc17704e1b..8c4c419d66 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -22,8 +22,10 @@
 
 #include "compositor/meta-compositor-native.h"
 
-#include "backends/meta-logical-monitor.h"
+#include "clutter/clutter.h"
+#include "backends/meta-output.h"
 #include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-renderer-view-native.h"
 #include "compositor/meta-surface-actor-wayland.h"
 
 struct _MetaCompositorNative
@@ -31,6 +33,8 @@ struct _MetaCompositorNative
   MetaCompositorServer parent;
 
   MetaWaylandSurface *current_scanout_candidate;
+
+  MetaSurfaceActor *frame_sync_surface_actor;
 };
 
 G_DEFINE_TYPE (MetaCompositorNative, meta_compositor_native,
@@ -155,18 +159,32 @@ done:
 }
 #endif /* HAVE_WAYLAND */
 
+void
+meta_compositor_native_request_frame_sync (MetaCompositorNative *compositor_native,
+                                           MetaSurfaceActor     *surface_actor)
+{
+  compositor_native->frame_sync_surface_actor = surface_actor;
+}
+
 static void
 meta_compositor_native_before_paint (MetaCompositor   *compositor,
                                      ClutterStageView *stage_view)
 {
+  MetaCompositorNative *compositor_native = META_COMPOSITOR_NATIVE (compositor);
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (stage_view);
   MetaCompositorClass *parent_class;
 
 #ifdef HAVE_WAYLAND
   maybe_assign_primary_plane (compositor);
 #endif
 
+  compositor_native->frame_sync_surface_actor = NULL;
+
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
   parent_class->before_paint (compositor, stage_view);
+
+  meta_renderer_view_native_set_frame_sync_actor (view_native,
+                                                  CLUTTER_ACTOR (compositor_native->frame_sync_surface_actor));
 }
 
 MetaCompositorNative *
diff --git a/src/compositor/meta-compositor-native.h b/src/compositor/meta-compositor-native.h
index 2b1c652087..dcb9c7dc15 100644
--- a/src/compositor/meta-compositor-native.h
+++ b/src/compositor/meta-compositor-native.h
@@ -27,6 +27,9 @@
 G_DECLARE_FINAL_TYPE (MetaCompositorNative, meta_compositor_native,
                       META, COMPOSITOR_NATIVE, MetaCompositor)
 
+void meta_compositor_native_request_frame_sync (MetaCompositorNative *compositor_native,
+                                                MetaSurfaceActor     *surface_actor);
+
 MetaCompositorNative * meta_compositor_native_new (MetaDisplay *display,
                                                    MetaBackend *backend);
 
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index ae1fa4d903..ccbf42325a 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -34,6 +34,7 @@
 #include "compositor/meta-window-actor-private.h"
 #include "core/boxes-private.h"
 #include "core/window-private.h"
+#include "core/workspace-private.h"
 #include "meta/window.h"
 
 #ifdef HAVE_WAYLAND
@@ -41,6 +42,11 @@
 #include "wayland/meta-wayland-surface.h"
 #endif
 
+#ifdef HAVE_NATIVE_BACKEND
+#include "backends/native/meta-backend-native.h"
+#include "compositor/meta-compositor-native.h"
+#endif
+
 typedef enum
 {
   INITIALLY_FROZEN,
@@ -1053,6 +1059,81 @@ meta_window_actor_sync_visibility (MetaWindowActor *self)
     }
 }
 
+#ifdef HAVE_NATIVE_BACKEND
+static MetaSurfaceActor *
+meta_window_actor_get_topmost_surface (MetaWindowActor *actor)
+{
+  ClutterActor *topmost_actor;
+
+  topmost_actor = clutter_actor_get_last_child (CLUTTER_ACTOR (actor));
+  if (!topmost_actor || !META_IS_SURFACE_ACTOR (topmost_actor))
+    return NULL;
+
+  return META_SURFACE_ACTOR (topmost_actor);
+}
+
+static void
+meta_window_actor_maybe_request_frame_sync (MetaWindowActor  *window_actor,
+                                            ClutterStageView *stage_view)
+{
+  MetaWindowActorPrivate *priv =
+    meta_window_actor_get_instance_private (window_actor);
+  MetaCompositor *compositor = priv->compositor;
+  MetaCompositorNative *compositor_native =
+    META_COMPOSITOR_NATIVE (compositor);
+  MetaWindow *window;
+  MetaRectangle view_layout;
+  MetaWorkspace *workspace;
+  MetaSurfaceActor *surface_actor;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    return;
+
+  if (meta_window_actor_is_frozen (window_actor))
+    return;
+
+  if (meta_window_actor_effect_in_progress (window_actor))
+    return;
+
+  if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
+    return;
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  if (!window)
+    return;
+
+  if (!meta_window_get_vrr_supported (window))
+    return;
+
+  if (!meta_window_should_be_showing (window))
+    return;
+
+  clutter_stage_view_get_layout (stage_view, &view_layout);
+
+  if (!meta_window_contains_rect (window, &view_layout))
+    return;
+
+  workspace = meta_window_get_workspace (window);
+  if (workspace == NULL)
+    return;
+
+  if (window != meta_workspace_topmost_window_on_rect (workspace,
+                                                       &view_layout))
+    return;
+
+  surface_actor = meta_window_actor_get_topmost_surface (window_actor);
+  if (!surface_actor)
+    return;
+
+  if (!meta_surface_actor_contains_rect (surface_actor,
+                                         &view_layout))
+    return;
+
+  meta_compositor_native_request_frame_sync (compositor_native,
+                                             surface_actor);
+}
+#endif /* HAVE_NATIVE_BACKEND */
+
 void
 meta_window_actor_before_paint (MetaWindowActor  *self,
                                 ClutterStageView *stage_view)
@@ -1061,6 +1142,11 @@ meta_window_actor_before_paint (MetaWindowActor  *self,
     return;
 
   META_WINDOW_ACTOR_GET_CLASS (self)->before_paint (self, stage_view);
+
+#ifdef HAVE_NATIVE_BACKEND
+  if (META_IS_BACKEND_NATIVE (meta_get_backend ()))
+    meta_window_actor_maybe_request_frame_sync (self, stage_view);
+#endif
 }
 
 void
-- 
GitLab


From 09f04a1717a1a5fb4834dff142343f443df3c30f Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 4 Aug 2020 22:07:13 +0300
Subject: [PATCH 15/23] temp: Assume every window supports VRR

---
 src/compositor/meta-window-actor.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index ccbf42325a..69219d19f8 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -1102,8 +1102,8 @@ meta_window_actor_maybe_request_frame_sync (MetaWindowActor  *window_actor,
   if (!window)
     return;
 
-  if (!meta_window_get_vrr_supported (window))
-    return;
+  //if (!meta_window_get_vrr_supported (window))
+  //  return;
 
   if (!meta_window_should_be_showing (window))
     return;
-- 
GitLab


From 3b53c38d5fba7e6790c3576a9758e715b543365c Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:42:37 +0200
Subject: [PATCH 16/23] connector/kms: Detect variable refresh rate capability

The "vrr_capable" property indicates whether variable refresh rate is
supported for a connector.
---
 src/backends/native/meta-kms-connector.c | 7 +++++++
 src/backends/native/meta-kms-connector.h | 2 ++
 2 files changed, 9 insertions(+)

diff --git a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
index b7550e12ee..dc906035b5 100644
--- a/src/backends/native/meta-kms-connector.c
+++ b/src/backends/native/meta-kms-connector.c
@@ -298,6 +298,9 @@ state_set_properties (MetaKmsConnectorState *state,
                 META_KMS_CONNECTOR_PROP_PRIVACY_SCREEN_HW_STATE))
         set_privacy_screen (state, connector, prop,
                             drm_connector->prop_values[i]);
+      else if ((prop->flags & DRM_MODE_PROP_RANGE) &&
+               strcmp (prop->name, "vrr_capable") == 0)
+        state->vrr_capable = drm_connector->prop_values[i];
 
       drmModeFreeProperty (prop);
     }
@@ -541,6 +544,7 @@ meta_kms_connector_state_new (void)
   state = g_new0 (MetaKmsConnectorState, 1);
   state->suggested_x = -1;
   state->suggested_y = -1;
+  state->vrr_capable = FALSE;
 
   return state;
 }
@@ -636,6 +640,9 @@ meta_kms_connector_state_changes (MetaKmsConnectorState *state,
   if (!kms_modes_equal (state->modes, new_state->modes))
     return META_KMS_UPDATE_CHANGE_FULL;
 
+  if (state->vrr_capable != new_state->vrr_capable)
+    return META_KMS_UPDATE_CHANGE_FULL;
+
   if (state->privacy_screen_state != new_state->privacy_screen_state)
     return META_KMS_UPDATE_CHANGE_PRIVACY_SCREEN;
 
diff --git a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
index c2b763548e..381edca973 100644
--- a/src/backends/native/meta-kms-connector.h
+++ b/src/backends/native/meta-kms-connector.h
@@ -59,6 +59,8 @@ typedef struct _MetaKmsConnectorState
   gboolean hotplug_mode_update;
 
   MetaMonitorTransform panel_orientation_transform;
+
+  gboolean vrr_capable;
 } MetaKmsConnectorState;
 
 META_EXPORT_TEST
-- 
GitLab


From 7226cff4fe556ae9cbdf11bbbf0efbf02a8c7017 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 22:17:59 +0200
Subject: [PATCH 17/23] update/kms: Allow setting CRTC properties

---
 .../native/meta-kms-impl-device-atomic.c      | 25 ++++++++
 .../native/meta-kms-impl-device-simple.c      | 60 +++++++++++++++++++
 src/backends/native/meta-kms-update-private.h |  9 +++
 src/backends/native/meta-kms-update.c         | 32 ++++++++++
 4 files changed, 126 insertions(+)

diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 73dd8e6971..4353788b63 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -261,6 +261,21 @@ add_crtc_property (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     drmModeAtomicReq   *req,
+                     GArray             *blob_ids,
+                     gpointer            update_entry,
+                     gpointer            user_data,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  return TRUE;
+}
+
 static gboolean
 process_mode_set (MetaKmsImplDevice  *impl_device,
                   MetaKmsUpdate      *update,
@@ -948,6 +963,16 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        req,
+                        blob_ids,
+                        meta_kms_update_get_crtc_updates (update),
+                        NULL,
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         req,
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index ca4ffe2454..4c257755a2 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -180,6 +180,47 @@ set_connector_property (MetaKmsImplDevice     *impl_device,
   return TRUE;
 }
 
+static gboolean
+set_crtc_property (MetaKmsImplDevice  *impl_device,
+                   MetaKmsCrtc        *crtc,
+                   MetaKmsCrtcProp     prop,
+                   uint64_t            value,
+                   GError            **error)
+{
+  uint32_t prop_id;
+  int fd;
+  int ret;
+
+  prop_id = meta_kms_crtc_get_prop_id (crtc, prop);
+  if (!prop_id)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Property (%s) not found on CRTC %u",
+                   meta_kms_crtc_get_prop_name (crtc, prop),
+                   meta_kms_crtc_get_id (crtc));
+      return FALSE;
+    }
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+
+  ret = drmModeObjectSetProperty (fd,
+                                  meta_kms_crtc_get_id (crtc),
+                                  DRM_MODE_OBJECT_CRTC,
+                                  prop_id,
+                                  value);
+  if (ret != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-ret),
+                   "Failed to set CRTC %u property %u: %s",
+                   meta_kms_crtc_get_id (crtc),
+                   prop_id,
+                   g_strerror (-ret));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 static gboolean
 process_connector_update (MetaKmsImplDevice  *impl_device,
                           MetaKmsUpdate      *update,
@@ -253,6 +294,18 @@ process_connector_update (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     gpointer            update_entry,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  return TRUE;
+}
+
 static CachedModeSet *
 cached_mode_set_new (GList                 *connectors,
                      const drmModeModeInfo *drm_mode,
@@ -1492,6 +1545,13 @@ meta_kms_impl_device_simple_process_update (MetaKmsImplDevice *impl_device,
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        meta_kms_update_get_crtc_updates (update),
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         meta_kms_update_get_crtc_gammas (update),
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index a613cbc5d6..ec7ca025f0 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -84,6 +84,12 @@ typedef struct _MetaKmsConnectorUpdate
   } privacy_screen;
 } MetaKmsConnectorUpdate;
 
+typedef struct _MetaKmsCrtcUpdate
+{
+  MetaKmsCrtc *crtc;
+
+} MetaKmsCrtcUpdate;
+
 typedef struct _MetaKmsPageFlipListener
 {
   MetaKmsCrtc *crtc;
@@ -157,6 +163,9 @@ void meta_kms_update_drop_defunct_page_flip_listeners (MetaKmsUpdate *update);
 META_EXPORT_TEST
 GList * meta_kms_update_get_connector_updates (MetaKmsUpdate *update);
 
+META_EXPORT_TEST
+GList * meta_kms_update_get_crtc_updates (MetaKmsUpdate *update);
+
 META_EXPORT_TEST
 GList * meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update);
 
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index 53fc92eb86..d2e912347b 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -38,6 +38,7 @@ struct _MetaKmsUpdate
   GList *mode_sets;
   GList *plane_assignments;
   GList *connector_updates;
+  GList *crtc_updates;
   GList *crtc_gammas;
 
   MetaKmsCustomPageFlip *custom_page_flip;
@@ -404,6 +405,30 @@ meta_kms_update_set_crtc_gamma (MetaKmsUpdate  *update,
   update->crtc_gammas = g_list_prepend (update->crtc_gammas, gamma);
 }
 
+static MetaKmsCrtcUpdate *
+ensure_crtc_update (MetaKmsUpdate *update,
+                    MetaKmsCrtc   *crtc)
+{
+  GList *l;
+  MetaKmsCrtcUpdate *crtc_update;
+
+  for (l = update->crtc_updates; l; l = l->next)
+    {
+      crtc_update = l->data;
+
+      if (crtc_update->crtc == crtc)
+        return crtc_update;
+    }
+
+  crtc_update = g_new0 (MetaKmsCrtcUpdate, 1);
+  crtc_update->crtc = crtc;
+
+  update->crtc_updates = g_list_prepend (update->crtc_updates,
+                                         crtc_update);
+
+  return crtc_update;
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
@@ -635,6 +660,12 @@ meta_kms_update_get_connector_updates (MetaKmsUpdate *update)
   return update->connector_updates;
 }
 
+GList *
+meta_kms_update_get_crtc_updates (MetaKmsUpdate *update)
+{
+  return update->crtc_updates;
+}
+
 GList *
 meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update)
 {
@@ -708,6 +739,7 @@ meta_kms_update_free (MetaKmsUpdate *update)
   g_list_free_full (update->page_flip_listeners,
                     (GDestroyNotify) meta_kms_page_flip_listener_free);
   g_list_free_full (update->connector_updates, g_free);
+  g_list_free_full (update->crtc_updates, g_free);
   g_list_free_full (update->crtc_gammas, (GDestroyNotify) meta_kms_crtc_gamma_free);
   g_clear_pointer (&update->custom_page_flip, meta_kms_custom_page_flip_free);
 
-- 
GitLab


From b28488356a0018feab092ffb9a03d2cce12476d8 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Thu, 9 Jun 2022 23:49:23 +0300
Subject: [PATCH 18/23] kms/update: Explicitly track whether ALLOW_MODESET is
 required

This will be used by a following commit to set the
DRM_MODE_ATOMIC_ALLOW_MODESET flag in case the "VRR_ENABLED" KMS
property is modified, as required by the i915 DRM driver.
---
 src/backends/native/meta-kms-impl-device-atomic.c |  2 +-
 src/backends/native/meta-kms-update-private.h     |  3 +++
 src/backends/native/meta-kms-update.c             | 11 +++++++++++
 3 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 4353788b63..df4d9c44a6 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -1003,7 +1003,7 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
                         &error))
     goto err;
 
-  if (meta_kms_update_get_mode_sets (update))
+  if (meta_kms_update_needs_allow_modeset (update))
     commit_flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
   else
     commit_flags |= DRM_MODE_ATOMIC_NONBLOCK;
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index ec7ca025f0..be419e0acd 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -169,6 +169,9 @@ GList * meta_kms_update_get_crtc_updates (MetaKmsUpdate *update);
 META_EXPORT_TEST
 GList * meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update);
 
+META_EXPORT_TEST
+gboolean meta_kms_update_needs_allow_modeset (MetaKmsUpdate *update);
+
 MetaKmsCustomPageFlip * meta_kms_update_take_custom_page_flip_func (MetaKmsUpdate *update);
 
 void meta_kms_update_drop_plane_assignment (MetaKmsUpdate *update,
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index d2e912347b..3feb9b05a9 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -41,6 +41,8 @@ struct _MetaKmsUpdate
   GList *crtc_updates;
   GList *crtc_gammas;
 
+  gboolean needs_allow_modeset;
+
   MetaKmsCustomPageFlip *custom_page_flip;
 
   GList *page_flip_listeners;
@@ -285,6 +287,8 @@ meta_kms_update_mode_set (MetaKmsUpdate *update,
   };
 
   update->mode_sets = g_list_prepend (update->mode_sets, mode_set);
+
+  update->needs_allow_modeset = TRUE;
 }
 
 static MetaKmsConnectorUpdate *
@@ -672,6 +676,12 @@ meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update)
   return update->crtc_gammas;
 }
 
+gboolean
+meta_kms_update_needs_allow_modeset (MetaKmsUpdate *update)
+{
+  return update->needs_allow_modeset;
+}
+
 void
 meta_kms_update_lock (MetaKmsUpdate *update)
 {
@@ -723,6 +733,7 @@ meta_kms_update_new (MetaKmsDevice *device)
   update = g_new0 (MetaKmsUpdate, 1);
   update->device = device;
   update->sequence_number = sequence_number++;
+  update->needs_allow_modeset = FALSE;
 
   return update;
 }
-- 
GitLab


From 00ac85b8238e4a435fc0da00911879ecf74beac6 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:44:15 +0200
Subject: [PATCH 19/23] crtc/kms: Allow setting the "VRR_ENABLED" property on a
 CRTC

Add the "VRR_ENABLED" CRTC propetry ID and a funtion to update its
value on a CRTC.

As required by the i915 DRM driver, it sets the
DRM_MODE_ATOMIC_ALLOW_MODESET flag when modified.
---
 src/backends/native/meta-kms-crtc-private.h   |  1 +
 src/backends/native/meta-kms-crtc.c           |  5 ++++
 .../native/meta-kms-impl-device-atomic.c      | 30 +++++++++++++++++++
 .../native/meta-kms-impl-device-simple.c      | 30 +++++++++++++++++++
 src/backends/native/meta-kms-update-private.h |  4 +++
 src/backends/native/meta-kms-update.c         | 17 +++++++++++
 src/backends/native/meta-kms-update.h         |  4 +++
 7 files changed, 91 insertions(+)

diff --git a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
index 65bda3f10b..0742c1e89c 100644
--- a/src/backends/native/meta-kms-crtc-private.h
+++ b/src/backends/native/meta-kms-crtc-private.h
@@ -30,6 +30,7 @@ typedef enum _MetaKmsCrtcProp
   META_KMS_CRTC_PROP_MODE_ID = 0,
   META_KMS_CRTC_PROP_ACTIVE,
   META_KMS_CRTC_PROP_GAMMA_LUT,
+  META_KMS_CRTC_PROP_VRR_ENABLED,
   META_KMS_CRTC_N_PROPS
 } MetaKmsCrtcProp;
 
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index e9bd9308b2..b00ccca719 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -390,6 +390,11 @@ init_properties (MetaKmsCrtc       *crtc,
           .name = "GAMMA_LUT",
           .type = DRM_MODE_PROP_BLOB,
         },
+      [META_KMS_CRTC_PROP_VRR_ENABLED] =
+        {
+          .name = "VRR_ENABLED",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     }
   };
 
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index df4d9c44a6..c1ff8b2e57 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -273,6 +273,36 @@ process_crtc_update (MetaKmsImplDevice  *impl_device,
   MetaKmsCrtcUpdate *crtc_update = update_entry;
   MetaKmsCrtc *crtc = crtc_update->crtc;
 
+  if (crtc_update->vrr_mode.has_update &&
+      crtc_update->vrr_mode.is_active)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Setting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              1,
+                              error))
+        return FALSE;
+    }
+  else if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Unsetting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              0,
+                              error))
+        return FALSE;
+    }
+
   return TRUE;
 }
 
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index 4c257755a2..ece02d56ec 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -303,6 +303,36 @@ process_crtc_update (MetaKmsImplDevice  *impl_device,
   MetaKmsCrtcUpdate *crtc_update = update_entry;
   MetaKmsCrtc *crtc = crtc_update->crtc;
 
+  if (crtc_update->vrr_mode.has_update &&
+      crtc_update->vrr_mode.is_active)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Setting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              1,
+                              error))
+        return FALSE;
+    }
+  else if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Unsetting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              0,
+                              error))
+        return FALSE;
+    }
+
   return TRUE;
 }
 
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index be419e0acd..d9915afc06 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -88,6 +88,10 @@ typedef struct _MetaKmsCrtcUpdate
 {
   MetaKmsCrtc *crtc;
 
+  struct {
+    gboolean has_update;
+    gboolean is_active;
+  } vrr_mode;
 } MetaKmsCrtcUpdate;
 
 typedef struct _MetaKmsPageFlipListener
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index 3feb9b05a9..85c77e80b8 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -433,6 +433,23 @@ ensure_crtc_update (MetaKmsUpdate *update,
   return crtc_update;
 }
 
+void
+meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                              MetaKmsCrtc   *crtc,
+                              gboolean       is_active)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+
+  g_assert (!meta_kms_update_is_locked (update));
+  g_assert (meta_kms_crtc_get_device (crtc) == update->device);
+
+  crtc_update = ensure_crtc_update (update, crtc);
+  crtc_update->vrr_mode.has_update = TRUE;
+  crtc_update->vrr_mode.is_active = is_active;
+
+  update->needs_allow_modeset = TRUE;
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
diff --git a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
index f31e36aad3..2f69c754be 100644
--- a/src/backends/native/meta-kms-update.h
+++ b/src/backends/native/meta-kms-update.h
@@ -123,6 +123,10 @@ void meta_kms_update_set_crtc_gamma (MetaKmsUpdate  *update,
                                      const uint16_t *green,
                                      const uint16_t *blue);
 
+void meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                                   MetaKmsCrtc   *crtc,
+                                   gboolean       is_active);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const int              *rectangles,
                                               int                     n_rectangles);
-- 
GitLab


From 342fee2fbdbc2a9d1cd244d5e8f722d9d0b4a020 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Fri, 10 Jun 2022 19:45:47 +0300
Subject: [PATCH 20/23] output/kms: Allow setting the variable refresh rate
 mode of an output

Add a function that enables variable refresh rate on a CRTC.

Also add functions to check if an output is capable of VRR and
whether VRR is configured to be enabled on the output.

An output is considered capable of variable refresh rate if its
connector supports it.
---
 src/backends/meta-monitor-manager-private.h |  1 +
 src/backends/meta-output.c                  | 19 ++++++++++++++
 src/backends/meta-output.h                  |  6 +++++
 src/backends/native/meta-output-kms.c       | 28 +++++++++++++++++++++
 src/backends/native/meta-output-kms.h       |  3 +++
 5 files changed, 57 insertions(+)

diff --git a/src/backends/meta-monitor-manager-private.h b/src/backends/meta-monitor-manager-private.h
index edf7e45019..dc0d27de5d 100644
--- a/src/backends/meta-monitor-manager-private.h
+++ b/src/backends/meta-monitor-manager-private.h
@@ -102,6 +102,7 @@ struct _MetaOutputAssignment
   gboolean     is_primary;
   gboolean     is_presentation;
   gboolean     is_underscanning;
+  gboolean     is_vrr_enabled;
 };
 
 /*
diff --git a/src/backends/meta-output.c b/src/backends/meta-output.c
index ed48075072..1d01a964e6 100644
--- a/src/backends/meta-output.c
+++ b/src/backends/meta-output.c
@@ -55,6 +55,8 @@ typedef struct _MetaOutputPrivate
 
   gboolean is_underscanning;
 
+  gboolean is_vrr_enabled;
+
   int backlight;
 } MetaOutputPrivate;
 
@@ -177,6 +179,22 @@ meta_output_is_underscanning (MetaOutput *output)
   return priv->is_underscanning;
 }
 
+gboolean
+meta_output_is_vrr_capable (MetaOutput *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_output_is_vrr_enabled (MetaOutput *output)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  return priv->is_vrr_enabled;
+}
+
 void
 meta_output_set_backlight (MetaOutput *output,
                            int         backlight)
@@ -235,6 +253,7 @@ meta_output_assign_crtc (MetaOutput                 *output,
   priv->is_primary = output_assignment->is_primary;
   priv->is_presentation = output_assignment->is_presentation;
   priv->is_underscanning = output_assignment->is_underscanning;
+  priv->is_vrr_enabled = output_assignment->is_vrr_enabled;
 }
 
 void
diff --git a/src/backends/meta-output.h b/src/backends/meta-output.h
index 6c90d7e69e..43477c4a4e 100644
--- a/src/backends/meta-output.h
+++ b/src/backends/meta-output.h
@@ -103,6 +103,8 @@ typedef struct _MetaOutputInfo
   gboolean supports_underscanning;
   gboolean supports_color_transform;
 
+  gboolean vrr_capable;
+
   /*
    * Get a new preferred mode on hotplug events, to handle dynamic guest
    * resizing.
@@ -178,6 +180,10 @@ gboolean meta_output_is_presentation (MetaOutput *output);
 META_EXPORT_TEST
 gboolean meta_output_is_underscanning (MetaOutput *output);
 
+gboolean meta_output_is_vrr_capable (MetaOutput *output);
+
+gboolean meta_output_is_vrr_enabled (MetaOutput *output);
+
 void meta_output_set_backlight (MetaOutput *output,
                                 int         backlight);
 
diff --git a/src/backends/native/meta-output-kms.c b/src/backends/native/meta-output-kms.c
index fb658f29d4..6b107dab9e 100644
--- a/src/backends/native/meta-output-kms.c
+++ b/src/backends/native/meta-output-kms.c
@@ -97,6 +97,32 @@ meta_output_kms_set_underscan (MetaOutputKms *output_kms,
     }
 }
 
+void
+meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                              gboolean       enabled)
+{
+  MetaOutput *output = META_OUTPUT (output_kms);
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+  MetaKmsDevice *kms_device;
+  MetaKms *kms;
+  MetaKmsUpdate *kms_update;
+
+  g_assert (output_info->vrr_capable);
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+  kms_device = meta_kms_crtc_get_device (kms_crtc);
+  kms = meta_kms_device_get_kms (kms_device);
+
+  kms_update = meta_kms_ensure_pending_update (kms, kms_device);
+
+  meta_kms_update_set_vrr_mode (kms_update,
+                                kms_crtc,
+                                enabled);
+}
+
 static MetaPrivacyScreenState
 meta_output_kms_get_privacy_screen_state (MetaOutput *output)
 {
@@ -405,6 +431,8 @@ meta_output_kms_new (MetaGpuKms        *gpu_kms,
   output_info->supports_underscanning =
     meta_kms_connector_is_underscanning_supported (kms_connector);
 
+  output_info->vrr_capable = connector_state->vrr_capable;
+
   meta_output_info_parse_edid (output_info, connector_state->edid_data);
 
   drm_connector_type = meta_kms_connector_get_connector_type (kms_connector);
diff --git a/src/backends/native/meta-output-kms.h b/src/backends/native/meta-output-kms.h
index 52acc6032a..54b1721a42 100644
--- a/src/backends/native/meta-output-kms.h
+++ b/src/backends/native/meta-output-kms.h
@@ -40,6 +40,9 @@ void meta_output_kms_set_power_save_mode (MetaOutputKms *output_kms,
 void meta_output_kms_set_underscan (MetaOutputKms *output_kms,
                                     MetaKmsUpdate *kms_update);
 
+void meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                                   gboolean       enabled);
+
 gboolean meta_output_kms_can_clone (MetaOutputKms *output_kms,
                                     MetaOutputKms *other_output_kms);
 
-- 
GitLab


From 81e178c4b418145a05b7ad766b3c7d0861638735 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 20:57:41 +0200
Subject: [PATCH 21/23] monitor: Allow checking the state of variable refresh
 rate

A monitor is considered to have variable refresh rate support if its
main output supports it.
---
 src/backends/meta-monitor.c | 19 +++++++++++++++++++
 src/backends/meta-monitor.h |  4 ++++
 2 files changed, 23 insertions(+)

diff --git a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
index 46cb05a666..2abfb3ea69 100644
--- a/src/backends/meta-monitor.c
+++ b/src/backends/meta-monitor.c
@@ -358,6 +358,25 @@ meta_monitor_is_underscanning (MetaMonitor *monitor)
   return meta_output_is_underscanning (output);
 }
 
+gboolean
+meta_monitor_is_vrr_capable (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_monitor_is_vrr_enabled (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_vrr_enabled (output);
+}
+
 gboolean
 meta_monitor_is_laptop_panel (MetaMonitor *monitor)
 {
diff --git a/src/backends/meta-monitor.h b/src/backends/meta-monitor.h
index 066caa7f46..a63300cd0e 100644
--- a/src/backends/meta-monitor.h
+++ b/src/backends/meta-monitor.h
@@ -118,6 +118,10 @@ gboolean meta_monitor_supports_underscanning (MetaMonitor *monitor);
 
 gboolean meta_monitor_is_underscanning (MetaMonitor *monitor);
 
+gboolean meta_monitor_is_vrr_capable (MetaMonitor *monitor);
+
+gboolean meta_monitor_is_vrr_enabled (MetaMonitor *monitor);
+
 gboolean meta_monitor_is_laptop_panel (MetaMonitor *monitor);
 
 gboolean meta_monitor_is_same_as (MetaMonitor *monitor,
-- 
GitLab


From c3ba2a68ca4a61fbf851117ddf16b65bf371e664 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 20:52:16 +0200
Subject: [PATCH 22/23] monitor-manager: Add variable refresh rate
 configuration

This allows enabling variable refresh rate on monitors that support it.

The configuration is persistent via monitors.xml and exposed in
DisplayConfig to be managed through DBus.
---
 .../org.gnome.Mutter.DisplayConfig.xml        |  7 +++++
 src/backends/meta-monitor-config-manager.c    |  9 ++++--
 src/backends/meta-monitor-config-manager.h    |  1 +
 src/backends/meta-monitor-config-migration.c  |  6 +++-
 src/backends/meta-monitor-config-store.c      | 30 +++++++++++++++++++
 src/backends/meta-monitor-manager.c           | 27 ++++++++++++++++-
 6 files changed, 75 insertions(+), 5 deletions(-)

diff --git a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
index af78ec0517..89d878748f 100644
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
@@ -343,6 +343,10 @@
 	    - "is-underscanning" (b): whether underscanning is enabled
 				      (absence of this means underscanning
 				      not being supported)
+	    - "is-vrr-enabled" (b): whether variable refresh rate is enabled
+	                            (absence of this means variable refresh
+	                            rate not being supported)
+
 	    - "max-screen-size" (ii): the maximum size a screen may have
 				      (absence of this means unlimited screen
 				      size)
@@ -461,6 +465,9 @@
 	        - "enable_underscanning" (b): enable monitor underscanning;
 					      may only be set when underscanning
 					      is supported (see GetCurrentState).
+	        - "enable_vrr" (b): enable variable refresh rate; may only be set
+	                            when variable refresh rate is supported (see
+	                            GetCurrentState).
 
 	@properties may effect the global monitor configuration state. Possible
 	properties are:
diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index da3f1dd544..0fb36ef93d 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -286,7 +286,8 @@ assign_monitor_crtc (MetaMonitor         *monitor,
     .output = output,
     .is_primary = assign_output_as_primary,
     .is_presentation = assign_output_as_presentation,
-    .is_underscanning = data->monitor_config->enable_underscanning
+    .is_underscanning = data->monitor_config->enable_underscanning,
+    .is_vrr_enabled = data->monitor_config->enable_vrr
   };
 
   g_ptr_array_add (data->crtc_assignments, crtc_assignment);
@@ -691,7 +692,8 @@ create_monitor_config (MetaMonitor     *monitor,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = meta_monitor_spec_clone (monitor_spec),
     .mode_spec = g_memdup2 (mode_spec, sizeof (MetaMonitorModeSpec)),
-    .enable_underscanning = meta_monitor_is_underscanning (monitor)
+    .enable_underscanning = meta_monitor_is_underscanning (monitor),
+    .enable_vrr = meta_monitor_is_vrr_enabled (monitor)
   };
 
   return monitor_config;
@@ -953,7 +955,8 @@ clone_monitor_config_list (GList *monitor_configs_in)
         .monitor_spec = meta_monitor_spec_clone (monitor_config_in->monitor_spec),
         .mode_spec = g_memdup2 (monitor_config_in->mode_spec,
                                 sizeof (MetaMonitorModeSpec)),
-        .enable_underscanning = monitor_config_in->enable_underscanning
+        .enable_underscanning = monitor_config_in->enable_underscanning,
+        .enable_vrr = monitor_config_in->enable_vrr
       };
       monitor_configs_out =
         g_list_append (monitor_configs_out, monitor_config_out);
diff --git a/src/backends/meta-monitor-config-manager.h b/src/backends/meta-monitor-config-manager.h
index a789e2f088..adbc3e5757 100644
--- a/src/backends/meta-monitor-config-manager.h
+++ b/src/backends/meta-monitor-config-manager.h
@@ -34,6 +34,7 @@ typedef struct _MetaMonitorConfig
   MetaMonitorSpec *monitor_spec;
   MetaMonitorModeSpec *mode_spec;
   gboolean enable_underscanning;
+  gboolean enable_vrr;
 } MetaMonitorConfig;
 
 typedef struct _MetaLogicalMonitorConfig
diff --git a/src/backends/meta-monitor-config-migration.c b/src/backends/meta-monitor-config-migration.c
index 69c426cd73..10c26c4f01 100644
--- a/src/backends/meta-monitor-config-migration.c
+++ b/src/backends/meta-monitor-config-migration.c
@@ -74,6 +74,7 @@ typedef struct
   gboolean is_primary;
   gboolean is_presentation;
   gboolean is_underscanning;
+  gboolean is_vrr_enabled;
 } MetaOutputConfig;
 
 typedef struct _MetaLegacyMonitorsConfig
@@ -605,6 +606,8 @@ handle_text (GMarkupParseContext *context,
           parser->output.is_presentation = read_bool (text, text_len, error);
         else if (strcmp (parser->output_field, "underscanning") == 0)
           parser->output.is_underscanning = read_bool (text, text_len, error);
+        else if (strcmp (parser->output_field, "enable_vrr") == 0)
+          parser->output.is_vrr_enabled = read_bool (text, text_len, error);
         else
           g_assert_not_reached ();
         return;
@@ -697,7 +700,8 @@ create_monitor_config (MetaOutputKey    *output_key,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = mode_spec,
-    .enable_underscanning = output_config->is_underscanning
+    .enable_underscanning = output_config->is_underscanning,
+    .enable_vrr = output_config->is_vrr_enabled
   };
 
   if (!meta_verify_monitor_config (monitor_config, error))
diff --git a/src/backends/meta-monitor-config-store.c b/src/backends/meta-monitor-config-store.c
index 5d48ec2ea5..946d4ed5dc 100644
--- a/src/backends/meta-monitor-config-store.c
+++ b/src/backends/meta-monitor-config-store.c
@@ -167,6 +167,7 @@ typedef enum
   STATE_MONITOR_MODE_RATE,
   STATE_MONITOR_MODE_FLAG,
   STATE_MONITOR_UNDERSCANNING,
+  STATE_MONITOR_ENABLE_VRR,
   STATE_DISABLED,
   STATE_POLICY,
   STATE_STORES,
@@ -451,6 +452,10 @@ handle_start_element (GMarkupParseContext  *context,
           {
             parser->state = STATE_MONITOR_UNDERSCANNING;
           }
+        else if (g_str_equal (element_name, "enable-vrr"))
+          {
+            parser->state = STATE_MONITOR_ENABLE_VRR;
+          }
         else
           {
             g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
@@ -544,6 +549,13 @@ handle_start_element (GMarkupParseContext  *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under enable-vrr", element_name);
+        return;
+      }
+
     case STATE_DISABLED:
       {
         if (!g_str_equal (element_name, "monitorspec"))
@@ -818,6 +830,14 @@ handle_end_element (GMarkupParseContext  *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        g_assert (g_str_equal (element_name, "enable-vrr"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
     case STATE_MONITOR:
       {
         MetaLogicalMonitorConfig *logical_monitor_config;
@@ -1301,6 +1321,14 @@ handle_text (GMarkupParseContext *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        read_bool (text, text_len,
+                   &parser->current_monitor_config->enable_vrr,
+                   error);
+        return;
+      }
+
     case STATE_STORE:
       {
         MetaConfigStore store;
@@ -1476,6 +1504,8 @@ append_monitors (GString *buffer,
       g_string_append (buffer, "        </mode>\n");
       if (monitor_config->enable_underscanning)
         g_string_append (buffer, "        <underscanning>yes</underscanning>\n");
+      if (monitor_config->enable_vrr)
+        g_string_append (buffer, "        <enable-vrr>yes</enable-vrr>\n");
       g_string_append (buffer, "      </monitor>\n");
     }
 }
diff --git a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
index 6d9b7f416b..93094a21cb 100644
--- a/src/backends/meta-monitor-manager.c
+++ b/src/backends/meta-monitor-manager.c
@@ -2034,6 +2034,15 @@ meta_monitor_manager_handle_get_current_state (MetaDBusDisplayConfig *skeleton,
                                  g_variant_new_boolean (is_underscanning));
         }
 
+      if (meta_monitor_is_vrr_capable (monitor))
+        {
+          gboolean vrr_enabled = meta_monitor_is_vrr_enabled (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-vrr-enabled",
+                                 g_variant_new_boolean (vrr_enabled));
+        }
+
       is_builtin = meta_monitor_is_laptop_panel (monitor);
       g_variant_builder_add (&monitor_properties_builder, "{sv}",
                              "is-builtin",
@@ -2353,6 +2362,8 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
   g_autoptr (GVariant) properties_variant = NULL;
   gboolean enable_underscanning = FALSE;
   gboolean set_underscanning = FALSE;
+  gboolean enable_vrr = FALSE;
+  gboolean set_enable_vrr = FALSE;
 
   g_variant_get (monitor_config_variant, "(ss@a{sv})",
                  &connector,
@@ -2388,6 +2399,19 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
         }
     }
 
+  set_enable_vrr =
+    g_variant_lookup (properties_variant, "enable_vrr", "b",
+                      &enable_vrr);
+  if (set_enable_vrr)
+    {
+      if (enable_vrr && !meta_monitor_is_vrr_capable (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Variable refresh rate requested but unsupported");
+          return NULL;
+        }
+    }
+
   monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
 
   monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
@@ -2397,7 +2421,8 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = monitor_mode_spec,
-    .enable_underscanning = enable_underscanning
+    .enable_underscanning = enable_underscanning,
+    .enable_vrr = enable_vrr
   };
 
   return monitor_config;
-- 
GitLab


From a98390cd0adde7b86d114edc0e97ced33b261444 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Fri, 10 Jun 2022 21:12:49 +0300
Subject: [PATCH 23/23] renderer-view/native: Enable VRR and actor sync when
 applicable

If an actor is tracked for synchronization and VRR is configured to
be enabled for the output, set the synchronization mode to
META_FRAME_SYNC_MODE_ENABLED.

If an actor isn't tracked for synchronization or VRR is not configured
to be enabled for the output, set the synchronization mode to
META_FRAME_SYNC_MODE_DISABLED.

When the synchronization mode is set to META_FRAME_SYNC_MODE_ENABLED,
enable the VRR mode on the output, and when it's set to
META_FRAME_SYNC_MODE_DISABLED, disable it.

Enabling the VRR mode on an output along with synchronizing frame
clock updates to actor updates on the matching view allows the monitor
match its refresh rate to the rate at which the actor updates,
effectively achieving the VRR effect.
---
 .../native/meta-renderer-view-native.c        | 27 ++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
index 14f3c543b2..677b975bc8 100644
--- a/src/backends/native/meta-renderer-view-native.c
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -25,6 +25,11 @@
 #include "backends/native/meta-renderer-view-native.h"
 
 #include "clutter/clutter.h"
+#include "backends/meta-output.h"
+#include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-output-kms.h"
 
 typedef enum _MetaFrameSyncMode
 {
@@ -115,20 +120,24 @@ meta_renderer_view_native_set_frame_sync_actor (MetaRendererViewNative *view_nat
 
 static void
 meta_renderer_view_native_set_frame_sync (MetaRendererViewNative *view_native,
+                                          MetaOutput             *output,
                                           MetaFrameSyncMode       sync_mode)
 {
   ClutterFrameClock *frame_clock =
     clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+  MetaOutputKms *output_kms = META_OUTPUT_KMS (output);
 
   switch (sync_mode)
     {
     case META_FRAME_SYNC_MODE_ENABLED:
       clutter_frame_clock_set_mode (frame_clock,
                                     CLUTTER_FRAME_CLOCK_MODE_VARIABLE);
+      meta_output_kms_set_vrr_mode (output_kms, TRUE);
       break;
     case META_FRAME_SYNC_MODE_DISABLED:
       clutter_frame_clock_set_mode (frame_clock,
                                     CLUTTER_FRAME_CLOCK_MODE_FIXED);
+      meta_output_kms_set_vrr_mode (output_kms, FALSE);
       break;
     case META_FRAME_SYNC_MODE_INIT:
       g_assert_not_reached ();
@@ -140,12 +149,21 @@ meta_renderer_view_native_set_frame_sync (MetaRendererViewNative *view_native,
 static MetaFrameSyncMode
 meta_renderer_view_native_get_applicable_sync_mode (MetaRendererViewNative *view_native)
 {
-  return META_FRAME_SYNC_MODE_DISABLED;
+  MetaRendererView *view = META_RENDERER_VIEW (view_native);
+  MetaOutput *output = meta_renderer_view_get_output (view);
+
+  if (view_native->frame_sync_actor != NULL &&
+      meta_output_is_vrr_enabled (output))
+    return META_FRAME_SYNC_MODE_ENABLED;
+  else
+    return META_FRAME_SYNC_MODE_DISABLED;
 }
 
 void
 meta_renderer_view_native_maybe_set_frame_sync (MetaRendererViewNative *view_native)
 {
+  MetaRendererView *view;
+  MetaOutput *output;
   MetaFrameSyncMode applicable_sync_mode;
 
   if (G_LIKELY (!view_native->frame_sync_mode_update_queued))
@@ -153,12 +171,19 @@ meta_renderer_view_native_maybe_set_frame_sync (MetaRendererViewNative *view_nat
 
   view_native->frame_sync_mode_update_queued = FALSE;
 
+  view = META_RENDERER_VIEW (view_native);
+  output = meta_renderer_view_get_output (view);
+
+  if (!meta_output_is_vrr_capable (output))
+    return;
+
   applicable_sync_mode =
     meta_renderer_view_native_get_applicable_sync_mode (view_native);
 
   if (applicable_sync_mode != view_native->frame_sync_mode)
     {
       meta_renderer_view_native_set_frame_sync (view_native,
+                                                output,
                                                 applicable_sync_mode);
     }
 }
-- 
GitLab

