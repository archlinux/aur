From b5222a243ca7f69e4eb0da7349cc3a1c9911fe41 Mon Sep 17 00:00:00 2001
From: fleminga <none_of_concern@whatever.tld>
Date: Sun, 11 Feb 2024 00:47:07 +0000
Subject: [PATCH] Fix build issue on latest Arch

---
 src/Makefile.in                 | 22 ++++++-----
 src/core/Makefile.in            | 22 ++++++-----
 src/core/file_unix.cpp          |  4 +-
 src/core/hashtable.h            | 10 ++---
 src/core/stringutil.cpp         |  4 +-
 src/core/types.h                |  2 +-
 src/cryptlib/Makefile.in        | 22 ++++++-----
 src/cryptlib/asn.cpp            | 14 +++----
 src/cryptlib/asn.h              | 12 +++---
 src/cryptlib/config.h           |  2 +-
 src/cryptlib/cryptlib.cpp       | 26 ++++++-------
 src/cryptlib/cryptlib.h         | 54 +++++++++++++--------------
 src/cryptlib/des.cpp            | 42 ++++++++++-----------
 src/cryptlib/des.h              | 34 ++++++++---------
 src/cryptlib/elgamal.cpp        |  8 ++--
 src/cryptlib/elgamal.h          |  8 ++--
 src/cryptlib/filters.cpp        |  8 ++--
 src/cryptlib/filters.h          | 36 +++++++++---------
 src/cryptlib/forkjoin.cpp       | 14 +++----
 src/cryptlib/forkjoin.h         | 24 ++++++------
 src/cryptlib/integer.cpp        | 22 +++++------
 src/cryptlib/integer.h          | 16 ++++----
 src/cryptlib/iterhash.h         | 18 ++++-----
 src/cryptlib/misc.cpp           |  4 +-
 src/cryptlib/misc.h             |  8 ++--
 src/cryptlib/queue.cpp          | 38 +++++++++----------
 src/cryptlib/queue.h            | 14 +++----
 src/cryptlib/rng.cpp            | 16 ++++----
 src/cryptlib/rng.h              | 14 +++----
 src/cryptlib/sha.cpp            |  2 +-
 src/cryptlib/sha.h              |  2 +-
 src/cryptlib/zbits.cpp          |  6 +--
 src/cryptlib/zbits.h            |  2 +-
 src/cryptlib/zdeflate.cpp       | 26 ++++++-------
 src/cryptlib/zdeflate.h         | 10 ++---
 src/cryptlib/zinflate.cpp       | 24 ++++++------
 src/cryptlib/zinflate.h         | 10 ++---
 src/cryptlib/ztrees.cpp         | 18 ++++-----
 src/cryptlib/ztrees.h           |  8 ++--
 src/db/Makefile.in              | 22 ++++++-----
 src/fco/Makefile.in             | 22 ++++++-----
 src/fco/signature.cpp           | 34 ++++++++---------
 src/fco/signature.h             | 16 ++++----
 src/fs/Makefile.in              | 22 ++++++-----
 src/siggen/Makefile.in          | 22 ++++++-----
 src/tripwire/Makefile.in        | 22 ++++++-----
 src/tripwire/mailmessage.h      |  2 +-
 src/tw/Makefile.in              | 22 ++++++-----
 src/tw/twutil.cpp               |  4 +-
 src/twadmin/Makefile.in         | 22 ++++++-----
 src/twcrypto/Makefile.in        | 22 ++++++-----
 src/twcrypto/bytequeue.cpp      | 38 +++++++++----------
 src/twcrypto/bytequeue.h        | 14 +++----
 src/twcrypto/crypto.cpp         | 66 ++++++++++++++++-----------------
 src/twcrypto/cryptoarchive.cpp  | 14 +++----
 src/twparser/Makefile.in        | 22 ++++++-----
 src/twprint/Makefile.in         | 22 ++++++-----
 src/twtest/Makefile.in          | 22 ++++++-----
 src/twtest/platform_t.cpp       |  6 +--
 src/twtest/serializerimpl_t.cpp |  2 +-
 src/twtest/signature_t.cpp      | 18 ++++-----
 src/util/Makefile.in            | 22 ++++++-----
 62 files changed, 566 insertions(+), 538 deletions(-)

diff --git a/src/Makefile.in b/src/Makefile.in
index be0d740..442f2bd 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -133,7 +133,7 @@ am__recursive_targets = \
   $(RECURSIVE_CLEAN_TARGETS) \
   $(am__extra_recursive_targets)
 AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	distdir
+	distdir distdir-am
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
 # Read a list of newline-separated strings from the standard input,
 # and print each of them once, without duplicates.  Input order is
@@ -151,8 +151,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -193,10 +191,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -206,6 +204,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -282,6 +281,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -317,8 +317,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -428,8 +428,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/core/Makefile.in b/src/core/Makefile.in
index 5ee6d53..aca4e7e 100644
--- a/src/core/Makefile.in
+++ b/src/core/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -141,7 +141,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -208,8 +208,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -224,10 +222,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -237,6 +235,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -313,6 +312,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -380,8 +380,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -485,8 +485,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/core/file_unix.cpp b/src/core/file_unix.cpp
index 286de9a..e77e525 100644
--- a/src/core/file_unix.cpp
+++ b/src/core/file_unix.cpp
@@ -360,7 +360,7 @@ cFile::File_t cFile::Read(void* buffer, File_t nBytes) const //throw(eFile)
     }
     else
     {
-        iBytesRead = fread(buffer, sizeof(byte), nBytes, mpData->mpCurrStream);
+        iBytesRead = fread(buffer, sizeof(ibyte), nBytes, mpData->mpCurrStream);
         if (ferror(mpData->mpCurrStream) != 0)
         {
             throw eFileRead(mpData->mFileName, iFSServices::GetInstance()->GetErrString());
@@ -382,7 +382,7 @@ cFile::File_t cFile::Write(const void* buffer, File_t nBytes) //throw(eFile)
     ASSERT(mpData->mpCurrStream != NULL);
     ASSERT(isWritable);
 
-    if ((actual_count = fwrite(buffer, sizeof(byte), nBytes, mpData->mpCurrStream)) < nBytes)
+    if ((actual_count = fwrite(buffer, sizeof(ibyte), nBytes, mpData->mpCurrStream)) < nBytes)
         throw eFileWrite(mpData->mFileName, iFSServices::GetInstance()->GetErrString());
     else
         return actual_count;
diff --git a/src/core/hashtable.h b/src/core/hashtable.h
index 9804994..6d90f2d 100644
--- a/src/core/hashtable.h
+++ b/src/core/hashtable.h
@@ -91,20 +91,20 @@ template<> inline bool cDefaultCompare<TSTRING>::operator()(const TSTRING& lhs,
 template<class T> class cDefaultConvert
 {
 public:
-    const byte* operator()(const T& obj, int* const pcbKeyLen)
+    const ibyte* operator()(const T& obj, int* const pcbKeyLen)
     {
         // HACK!  TODO: in the interest of time, I've left this as it is.....
         *pcbKeyLen = sizeof(TCHAR) * _tcslen(obj);
-        return (byte*)obj;
+        return (ibyte*)obj;
     }
 };
 /////////////////////////////////////////////////////////
 // specialization for TSTRINGS
 /////////////////////////////////////////////////////////
-template<> inline const byte* cDefaultConvert<TSTRING>::operator()(const TSTRING& obj, int* const pcbKeyLen)
+template<> inline const ibyte* cDefaultConvert<TSTRING>::operator()(const TSTRING& obj, int* const pcbKeyLen)
 {
     *pcbKeyLen = sizeof(TCHAR) * obj.length();
-    return (byte*)obj.c_str();
+    return (ibyte*)obj.c_str();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -510,7 +510,7 @@ uint32 cHashTable<KEY_TYPE, VAL_TYPE, COMPARE_OP, CONVERTER>::Hash(const KEY_TYP
 {
     CONVERTER   converter;
     int         len;
-    const byte* pb = converter(key, &len); //locates key
+    const ibyte* pb = converter(key, &len); //locates key
     uint32      hindex;
 
     hindex = *pb;
diff --git a/src/core/stringutil.cpp b/src/core/stringutil.cpp
index edee741..7907081 100644
--- a/src/core/stringutil.cpp
+++ b/src/core/stringutil.cpp
@@ -84,10 +84,10 @@
 class tss_hash_key_convert
 {
 public:
-    const byte* operator()(const wc16_string& s, int* const pcbKeyLen)
+    const ibyte* operator()(const wc16_string& s, int* const pcbKeyLen)
     {
         *pcbKeyLen = sizeof(WCHAR16) * s.length();
-        return (byte*)s.c_str();
+        return (ibyte*)s.c_str();
     }
 };
 
diff --git a/src/core/types.h b/src/core/types.h
index 4287bc2..b95e31e 100644
--- a/src/core/types.h
+++ b/src/core/types.h
@@ -45,7 +45,7 @@
 // standard TSS types
 //-----------------------------------------------------------------------------
 
-typedef unsigned char byte; // platform-independent
+typedef unsigned char ibyte; // platform-independent
 
 typedef signed char    int8;
 typedef short          int16;
diff --git a/src/cryptlib/Makefile.in b/src/cryptlib/Makefile.in
index 4f6d772..bc2fb38 100644
--- a/src/cryptlib/Makefile.in
+++ b/src/cryptlib/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -131,7 +131,7 @@ am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
 am__v_at_1 = 
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -198,8 +198,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -214,10 +212,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -227,6 +225,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -303,6 +302,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -355,8 +355,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -460,8 +460,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/cryptlib/asn.cpp b/src/cryptlib/asn.cpp
index d5265e6..2d9042f 100644
--- a/src/cryptlib/asn.cpp
+++ b/src/cryptlib/asn.cpp
@@ -6,19 +6,19 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-unsigned int DERLengthEncode(unsigned int length, byte *output)
+unsigned int DERLengthEncode(unsigned int length, ibyte *output)
 {
     unsigned int i=0;
     if (length <= 0x7f)
     {
-        output[i++] = byte(length);
+        output[i++] = ibyte(length);
     }
     else
     {
-        output[i++] = byte(BytePrecision(length) | 0x80);
+        output[i++] = ibyte(BytePrecision(length) | 0x80);
         for (int j=BytePrecision(length); j; --j)
         {
-            output[i++] = byte (length >> (j-1)*8);
+            output[i++] = ibyte (length >> (j-1)*8);
         }
     }
     return i;
@@ -26,7 +26,7 @@ unsigned int DERLengthEncode(unsigned int length, byte *output)
 
 unsigned int DERLengthEncode(unsigned int length, BufferedTransformation &bt)
 {
-    byte buf[10];   // should be more than enough
+    ibyte buf[10];   // should be more than enough
     unsigned int i = DERLengthEncode(length, buf);
     assert(i <= 10);
     bt.Put(buf, i);
@@ -35,7 +35,7 @@ unsigned int DERLengthEncode(unsigned int length, BufferedTransformation &bt)
 
 bool BERLengthDecode(BufferedTransformation &bt, unsigned int &length)
 {
-    byte b;
+    ibyte b;
 
     if (!bt.Get(b))
         BERDecodeError();
@@ -76,7 +76,7 @@ bool BERLengthDecode(BufferedTransformation &bt, unsigned int &length)
 BERSequenceDecoder::BERSequenceDecoder(BufferedTransformation &inQueue)
     : inQueue(inQueue)
 {
-    byte b;
+    ibyte b;
     if (!inQueue.Get(b) || b != (SEQUENCE | CONSTRUCTED))
         BERDecodeError();
 
diff --git a/src/cryptlib/asn.h b/src/cryptlib/asn.h
index 13c18e1..2cbd69c 100644
--- a/src/cryptlib/asn.h
+++ b/src/cryptlib/asn.h
@@ -8,7 +8,7 @@
 enum ASNTag {INTEGER=0x02, BIT_STRING=0x03, SEQUENCE=0x10};
 enum ASNIdFlag {CONSTRUCTED = 0x20};
 
-unsigned int DERLengthEncode(unsigned int length, byte *output);
+unsigned int DERLengthEncode(unsigned int length, ibyte *output);
 unsigned int DERLengthEncode(unsigned int length, BufferedTransformation &);
 
 #ifdef THROW_EXCEPTIONS
@@ -27,16 +27,16 @@ public:
     BERSequenceDecoder(BufferedTransformation &inQueue);
     ~BERSequenceDecoder();
 
-    void Put(byte) {}
-    void Put(const byte *, unsigned int) {}
+    void Put(ibyte) {}
+    void Put(const ibyte *, unsigned int) {}
 
     unsigned long MaxRetrieveable()
         {return inQueue.MaxRetrieveable();}
-    unsigned int Get(byte &outByte)
+    unsigned int Get(ibyte &outByte)
         {return inQueue.Get(outByte);}
-    unsigned int Get(byte *outString, unsigned int getMax)
+    unsigned int Get(ibyte *outString, unsigned int getMax)
         {return inQueue.Get(outString, getMax);}
-    unsigned int Peek(byte &outByte) const
+    unsigned int Peek(ibyte &outByte) const
         {return inQueue.Peek(outByte);}
 
 private:
diff --git a/src/cryptlib/config.h b/src/cryptlib/config.h
index 77f06de..a2eb7ef 100644
--- a/src/cryptlib/config.h
+++ b/src/cryptlib/config.h
@@ -82,7 +82,7 @@
 
 // Make sure these typedefs are correct for your computer
 
-typedef unsigned char byte;
+typedef unsigned char ibyte;
 typedef unsigned short word16;
 #if SIZEOF_INT == 4
  typedef unsigned int word32;
diff --git a/src/cryptlib/cryptlib.cpp b/src/cryptlib/cryptlib.cpp
index 06c091b..6efd065 100644
--- a/src/cryptlib/cryptlib.cpp
+++ b/src/cryptlib/cryptlib.cpp
@@ -9,7 +9,7 @@ unsigned int RandomNumberGenerator::GetBit()
     return Parity(GetByte());
 }
 
-void RandomNumberGenerator::GetBlock(byte *output, unsigned int size)
+void RandomNumberGenerator::GetBlock(ibyte *output, unsigned int size)
 {
     while (size--)
         *output++ = GetByte();
@@ -35,19 +35,19 @@ word32 RandomNumberGenerator::GetLong(word32 min, word32 max)
     return value+min;
 }
 
-void StreamCipher::ProcessString(byte *outString, const byte *inString, unsigned int length)
+void StreamCipher::ProcessString(ibyte *outString, const ibyte *inString, unsigned int length)
 {
     while(length--)
         *outString++ = ProcessByte(*inString++);
 }
 
-void StreamCipher::ProcessString(byte *inoutString, unsigned int length)
+void StreamCipher::ProcessString(ibyte *inoutString, unsigned int length)
 {
     for(;length--; inoutString++)
         *inoutString = ProcessByte(*inoutString);
 }
 
-bool MessageAuthenticationCode::Verify(const byte *macIn)
+bool MessageAuthenticationCode::Verify(const ibyte *macIn)
 {
     SecByteBlock mac(DigestSize());
     Final(mac);
@@ -82,11 +82,11 @@ void BufferedTransformation::PutShort(word16 value, bool highFirst)
     if (highFirst)
     {
         Put(value>>8);
-        Put(byte(value));
+        Put(ibyte(value));
     }
     else
     {
-        Put(byte(value));
+        Put(ibyte(value));
         Put(value>>8);
     }
 }
@@ -96,12 +96,12 @@ void BufferedTransformation::PutLong(word32 value, bool highFirst)
     if (highFirst)
     {
         for (int i=0; i<4; i++)
-            Put(byte(value>>((3-i)*8)));
+            Put(ibyte(value>>((3-i)*8)));
     }
     else
     {
         for (int i=0; i<4; i++)
-            Put(byte(value>>(i*8)));
+            Put(ibyte(value>>(i*8)));
     }
 }
 
@@ -110,7 +110,7 @@ int BufferedTransformation::GetShort(word16 &value, bool highFirst)
     if (MaxRetrieveable()<2)
         return 0;
 
-    byte buf[2];
+    ibyte buf[2];
     Get(buf, 2);
 
     if (highFirst)
@@ -126,7 +126,7 @@ int BufferedTransformation::GetLong(word32 &value, bool highFirst)
     if (MaxRetrieveable()<4)
         return 0;
 
-    byte buf[4];
+    ibyte buf[4];
     Get(buf, 4);
 
     if (highFirst)
@@ -139,7 +139,7 @@ int BufferedTransformation::GetLong(word32 &value, bool highFirst)
 
 unsigned int BufferedTransformation::Skip(unsigned int skipMax)
 {
-    byte b;
+    ibyte b;
     unsigned int skipActual=0;
 
     while (skipMax-- && Get(b))
@@ -163,7 +163,7 @@ unsigned int PK_FixedLengthCryptoSystem::CipherTextLength(unsigned int plainText
         return 0;
 }
 
-unsigned int PK_FixedLengthDecryptor::Decrypt(const byte *cipherText, unsigned int cipherTextLength, byte *plainText)
+unsigned int PK_FixedLengthDecryptor::Decrypt(const ibyte *cipherText, unsigned int cipherTextLength, ibyte *plainText)
 {
     if (cipherTextLength != CipherTextLength())
         return 0;
@@ -171,7 +171,7 @@ unsigned int PK_FixedLengthDecryptor::Decrypt(const byte *cipherText, unsigned i
     return Decrypt(cipherText, plainText);
 }
 
-bool PK_VerifierWithRecovery::Verify(const byte *message, unsigned int messageLength, const byte *signature)
+bool PK_VerifierWithRecovery::Verify(const ibyte *message, unsigned int messageLength, const ibyte *signature)
 {
     SecByteBlock recovered(MaxMessageLength());
     unsigned int rLen = Recover(signature, recovered);
diff --git a/src/cryptlib/cryptlib.h b/src/cryptlib/cryptlib.h
index 145616f..401a359 100644
--- a/src/cryptlib/cryptlib.h
+++ b/src/cryptlib/cryptlib.h
@@ -53,11 +53,11 @@ public:
 
     /// encrypt or decrypt one block in place
     //* Precondition: size of inoutBlock == BlockSize().
-    virtual void ProcessBlock(byte *inoutBlock) =0;
+    virtual void ProcessBlock(ibyte *inoutBlock) =0;
 
     /// encrypt or decrypt one block, may assume inBlock != outBlock
     //* Precondition: size of inBlock and outBlock == BlockSize().
-    virtual void ProcessBlock(const byte *inBlock, byte *outBlock) =0;
+    virtual void ProcessBlock(const ibyte *inBlock, ibyte *outBlock) =0;
 
     /// block size of the cipher in bytes
     virtual unsigned int BlockSize() const =0;
@@ -73,12 +73,12 @@ public:
     virtual ~StreamCipher() {}
 
     /// encrypt or decrypt one byte
-    virtual byte ProcessByte(byte input) =0;
+    virtual ibyte ProcessByte(ibyte input) =0;
 
     /// encrypt or decrypt an array of bytes of specified length in place
-    virtual void ProcessString(byte *inoutString, unsigned int length);
+    virtual void ProcessString(ibyte *inoutString, unsigned int length);
     /// encrypt or decrypt an array of bytes of specified length, may assume inString != outString
-    virtual void ProcessString(byte *outString, const byte *inString, unsigned int length);
+    virtual void ProcessString(ibyte *outString, const ibyte *inString, unsigned int length);
 };
 
 /// abstract base class for random access stream ciphers
@@ -103,7 +103,7 @@ public:
     virtual ~RandomNumberGenerator() {}
 
     /// generate new random byte and return it
-    virtual byte GetByte() =0;
+    virtual ibyte GetByte() =0;
 
     /// generate new random bit and return it
     /** Default implementation is to call GetByte() and return its parity. */
@@ -117,7 +117,7 @@ public:
 
     /// generate random array of bytes
     //* Default implementation is to call GetByte size times.
-    virtual void GetBlock(byte *output, unsigned int size);
+    virtual void GetBlock(ibyte *output, unsigned int size);
 };
 
 /// randomly shuffle the specified array, resulting permutation is uniformly distributed
@@ -141,18 +141,18 @@ public:
     virtual ~HashModule() {}
 
     /// process more input
-    virtual void Update(const byte *input, unsigned int length) =0;
+    virtual void Update(const ibyte *input, unsigned int length) =0;
 
     /*/ calculate hash for the current message (the concatenation of all 
         inputs passed in via Update()), then reinitialize the object */
     //* Precondition: size of digest == DigestSize().
-    virtual void Final(byte *digest) =0;
+    virtual void Final(ibyte *digest) =0;
 
     /// size of the hash returned by Final()
     virtual unsigned int DigestSize() const =0;
 
     /// use this if your input is short and you don't want to call Update() and Final() seperately
-    virtual void CalculateDigest(byte *digest, const byte *input, int length)
+    virtual void CalculateDigest(ibyte *digest, const ibyte *input, int length)
         {Update(input, length); Final(digest);}
 };
 
@@ -173,10 +173,10 @@ public:
     /// verify that mac is a valid MAC for the current message, then reinitialize the object
     /** Default implementation is to call Final() and do a bitwise comparison
         between its output and mac. */
-    virtual bool Verify(const byte *mac);
+    virtual bool Verify(const ibyte *mac);
 
     /// use this if your input is short and you don't want to call Update() and Verify() seperately
-    virtual bool VerifyMAC(const byte *mac, const byte *input, int length)
+    virtual bool VerifyMAC(const ibyte *mac, const ibyte *input, int length)
         {Update(input, length); return Verify(mac);}
 };
 
@@ -203,9 +203,9 @@ public:
     //@Man: INPUT
     //@{
         /// input a byte for processing
-        virtual void Put(byte inByte) =0;
+        virtual void Put(ibyte inByte) =0;
         /// input multiple bytes
-        virtual void Put(const byte *inString, unsigned int length) =0;
+        virtual void Put(const ibyte *inString, unsigned int length) =0;
         /// signal that no more input is available
         virtual void InputFinished() {}
 
@@ -224,9 +224,9 @@ public:
         virtual unsigned long MaxRetrieveable() =0;
 
         /// try to retrieve a single byte
-        virtual unsigned int Get(byte &outByte) =0;
+        virtual unsigned int Get(ibyte &outByte) =0;
         /// try to retrieve multiple bytes
-        virtual unsigned int Get(byte *outString, unsigned int getMax) =0;
+        virtual unsigned int Get(ibyte *outString, unsigned int getMax) =0;
 
         /// try to retrieve a 16-bit word, big-endian or little-endian depending on highFirst
         int GetShort(word16 &value, bool highFirst=true);
@@ -239,7 +239,7 @@ public:
         virtual unsigned int TransferTo(BufferedTransformation &target, unsigned int transferMax);
 
         /// peek at the next byte without removing it from the output buffer
-        virtual unsigned int Peek(byte &outByte) const =0;
+        virtual unsigned int Peek(ibyte &outByte) const =0;
 
         /// discard some bytes from the output buffer
         unsigned int Skip(unsigned int skipMax);
@@ -299,7 +299,7 @@ public:
             \item size of cipherText == CipherTextLength(plainTextLength)
             \end{itemize}
     */
-    virtual void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText) =0;
+    virtual void Encrypt(RandomNumberGenerator &rng, const ibyte *plainText, unsigned int plainTextLength, ibyte *cipherText) =0;
 };
 
 /// abstract base class for public-key decryptors
@@ -317,7 +317,7 @@ public:
         The function returns the actual length of the plaintext, or 0
         if decryption fails.
     */
-    virtual unsigned int Decrypt(const byte *cipherText, unsigned int cipherTextLength, byte *plainText) =0;
+    virtual unsigned int Decrypt(const ibyte *cipherText, unsigned int cipherTextLength, ibyte *plainText) =0;
 };
 
 /// abstract base class for encryptors and decryptors with fixed length ciphertext
@@ -361,9 +361,9 @@ public:
         The function returns the actual length of the plaintext, or 0
         if decryption fails.
     */
-    virtual unsigned int Decrypt(const byte *cipherText, byte *plainText) =0;
+    virtual unsigned int Decrypt(const ibyte *cipherText, ibyte *plainText) =0;
 
-    unsigned int Decrypt(const byte *cipherText, unsigned int cipherTextLength, byte *plainText);
+    unsigned int Decrypt(const ibyte *cipherText, unsigned int cipherTextLength, ibyte *plainText);
 };
 
 /// abstract base class for public-key signers and verifiers
@@ -402,7 +402,7 @@ public:
             \item size of signature == SignatureLength()
             \end{itemize}
     */
-    virtual void Sign(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature) =0;
+    virtual void Sign(RandomNumberGenerator &rng, const ibyte *message, unsigned int messageLen, ibyte *signature) =0;
 };
 
 /// abstract base class for public-key verifiers
@@ -420,7 +420,7 @@ public:
             \item length of signature == SignatureLength()
             \end{itemize}
     */
-    virtual bool Verify(const byte *message, unsigned int messageLen, const byte *sig) =0;
+    virtual bool Verify(const ibyte *message, unsigned int messageLen, const ibyte *sig) =0;
 };
 
 /// abstract base class for public-key verifiers with recovery
@@ -439,9 +439,9 @@ public:
             \item size of recoveredMessage == MaxMessageLength()
             \end{itemize}
     */
-    virtual unsigned int Recover(const byte *signature, byte *recoveredMessage) =0;
+    virtual unsigned int Recover(const ibyte *signature, ibyte *recoveredMessage) =0;
 
-    bool Verify(const byte *message, unsigned int messageLen, const byte *signature);
+    bool Verify(const ibyte *message, unsigned int messageLen, const ibyte *signature);
 };
 
 /// abstract base class for key agreement protocols
@@ -471,7 +471,7 @@ public:
 
     /// produce public value
     //* Precondition: size of publicValue == PublicValueLength()
-    virtual void Setup(RandomNumberGenerator &rng, byte *publicValue) =0;
+    virtual void Setup(RandomNumberGenerator &rng, ibyte *publicValue) =0;
 
     /// calculate agreed key given other party's public value
     /** Precondition:
@@ -480,7 +480,7 @@ public:
             \item size of agreedKey == AgreedKeyLength()
             \end{itemize}
     */
-    virtual void Agree(const byte *otherPublicValue, byte *agreedKey) const =0;
+    virtual void Agree(const ibyte *otherPublicValue, ibyte *agreedKey) const =0;
 };
 
 /// abstract base class for all objects that support precomputation
diff --git a/src/cryptlib/des.cpp b/src/cryptlib/des.cpp
index eea35b4..e4f9326 100644
--- a/src/cryptlib/des.cpp
+++ b/src/cryptlib/des.cpp
@@ -28,7 +28,7 @@
  */
 #ifdef notdef
 /* initial permutation IP */
-static byte ip[] = {
+static ibyte ip[] = {
        58, 50, 42, 34, 26, 18, 10,  2,
        60, 52, 44, 36, 28, 20, 12,  4,
        62, 54, 46, 38, 30, 22, 14,  6,
@@ -40,7 +40,7 @@ static byte ip[] = {
 };
 
 /* final permutation IP^-1 */
-static byte fp[] = {
+static ibyte fp[] = {
        40,  8, 48, 16, 56, 24, 64, 32,
        39,  7, 47, 15, 55, 23, 63, 31,
        38,  6, 46, 14, 54, 22, 62, 30,
@@ -51,7 +51,7 @@ static byte fp[] = {
        33,  1, 41,  9, 49, 17, 57, 25
 };
 /* expansion operation matrix */
-static byte ei[] = {
+static ibyte ei[] = {
        32,  1,  2,  3,  4,  5,
         4,  5,  6,  7,  8,  9,
         8,  9, 10, 11, 12, 13,
@@ -62,7 +62,7 @@ static byte ei[] = {
        28, 29, 30, 31, 32,  1
 };
 /* The (in)famous S-boxes */
-static byte sbox[8][64] = {
+static ibyte sbox[8][64] = {
        /* S1 */
        14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
         0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
@@ -113,7 +113,7 @@ static byte sbox[8][64] = {
 };
 
 /* 32-bit permutation function P used on the output of the S-boxes */
-static byte p32i[] = {
+static ibyte p32i[] = {
        16,  7, 20, 21,
        29, 12, 28, 17,
         1, 15, 23, 26,
@@ -126,7 +126,7 @@ static byte p32i[] = {
 #endif
 
 /* permuted choice table (key) */
-static const byte pc1[] = {
+static const ibyte pc1[] = {
        57, 49, 41, 33, 25, 17,  9,
         1, 58, 50, 42, 34, 26, 18,
        10,  2, 59, 51, 43, 35, 27,
@@ -139,12 +139,12 @@ static const byte pc1[] = {
 };
 
 /* number left rotations of pc1 */
-static const byte totrot[] = {
+static const ibyte totrot[] = {
        1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28
 };
 
 /* permuted choice key (table) */
-static const byte pc2[] = {
+static const ibyte pc2[] = {
        14, 17, 11, 24,  1,  5,
         3, 28, 15,  6, 21, 10,
        23, 19, 12,  4, 26,  8,
@@ -163,13 +163,13 @@ static const int bytebit[] = {
 };
 
 /* Set key (initialize key schedule array) */
-DES::DES(const byte *key, CipherDir dir)
+DES::DES(const ibyte *key, CipherDir dir)
     : k(32)
 {
        SecByteBlock buffer(56+56+8);
-       byte *const pc1m=buffer;                 /* place to modify pc1 into */
-       byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
-       byte *const ks=pcr+56;
+       ibyte *const pc1m=buffer;                 /* place to modify pc1 into */
+       ibyte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
+       ibyte *const ks=pcr+56;
        register unsigned int i,j,l;
        int m;
 
@@ -311,7 +311,7 @@ inline void FPERM(word32 &left, word32 &right)
 }
 
 // Encrypt or decrypt a block of data in ECB mode
-void DES::ProcessBlock(const byte *inBlock, byte * outBlock)
+void DES::ProcessBlock(const ibyte *inBlock, ibyte * outBlock)
 {
     word32 l,r,work;
 
@@ -363,56 +363,56 @@ void DES::ProcessBlock(const byte *inBlock, byte * outBlock)
 #endif
 }
 
-void DES_EDE_Encryption::ProcessBlock(byte *inoutBlock)
+void DES_EDE_Encryption::ProcessBlock(ibyte *inoutBlock)
 {
     e.ProcessBlock(inoutBlock);
     d.ProcessBlock(inoutBlock);
     e.ProcessBlock(inoutBlock);
 }
 
-void DES_EDE_Encryption::ProcessBlock(const byte *inBlock, byte *outBlock)
+void DES_EDE_Encryption::ProcessBlock(const ibyte *inBlock, ibyte *outBlock)
 {
     e.ProcessBlock(inBlock, outBlock);
     d.ProcessBlock(outBlock);
     e.ProcessBlock(outBlock);
 }
 
-void DES_EDE_Decryption::ProcessBlock(byte *inoutBlock)
+void DES_EDE_Decryption::ProcessBlock(ibyte *inoutBlock)
 {
     d.ProcessBlock(inoutBlock);
     e.ProcessBlock(inoutBlock);
     d.ProcessBlock(inoutBlock);
 }
 
-void DES_EDE_Decryption::ProcessBlock(const byte *inBlock, byte *outBlock)
+void DES_EDE_Decryption::ProcessBlock(const ibyte *inBlock, ibyte *outBlock)
 {
     d.ProcessBlock(inBlock, outBlock);
     e.ProcessBlock(outBlock);
     d.ProcessBlock(outBlock);
 }
 
-void TripleDES_Encryption::ProcessBlock(byte *inoutBlock)
+void TripleDES_Encryption::ProcessBlock(ibyte *inoutBlock)
 {
     e1.ProcessBlock(inoutBlock);
     d.ProcessBlock(inoutBlock);
     e2.ProcessBlock(inoutBlock);
 }
 
-void TripleDES_Encryption::ProcessBlock(const byte *inBlock, byte *outBlock)
+void TripleDES_Encryption::ProcessBlock(const ibyte *inBlock, ibyte *outBlock)
 {
     e1.ProcessBlock(inBlock, outBlock);
     d.ProcessBlock(outBlock);
     e2.ProcessBlock(outBlock);
 }
 
-void TripleDES_Decryption::ProcessBlock(byte *inoutBlock)
+void TripleDES_Decryption::ProcessBlock(ibyte *inoutBlock)
 {
     d1.ProcessBlock(inoutBlock);
     e.ProcessBlock(inoutBlock);
     d2.ProcessBlock(inoutBlock);
 }
 
-void TripleDES_Decryption::ProcessBlock(const byte *inBlock, byte *outBlock)
+void TripleDES_Decryption::ProcessBlock(const ibyte *inBlock, ibyte *outBlock)
 {
     d1.ProcessBlock(inBlock, outBlock);
     e.ProcessBlock(outBlock);
diff --git a/src/cryptlib/des.h b/src/cryptlib/des.h
index 47688e5..6b8f1c9 100644
--- a/src/cryptlib/des.h
+++ b/src/cryptlib/des.h
@@ -7,10 +7,10 @@
 class DES : public BlockTransformation
 {
 public:
-    DES(const byte *userKey, CipherDir);
+    DES(const ibyte *userKey, CipherDir);
 
-    void ProcessBlock(const byte *inBlock, byte * outBlock);
-    void ProcessBlock(byte * inoutBlock)
+    void ProcessBlock(const ibyte *inBlock, ibyte * outBlock);
+    void ProcessBlock(ibyte * inoutBlock)
         {DES::ProcessBlock(inoutBlock, inoutBlock);}
 
     enum {KEYLENGTH=8, BLOCKSIZE=8};
@@ -25,25 +25,25 @@ protected:
 class DESEncryption : public DES
 {
 public:
-    DESEncryption(const byte * userKey)
+    DESEncryption(const ibyte * userKey)
         : DES (userKey, ENCRYPTION) {}
 };
 
 class DESDecryption : public DES
 {
 public:
-    DESDecryption(const byte * userKey)
+    DESDecryption(const ibyte * userKey)
         : DES (userKey, DECRYPTION) {}
 };
 
 class DES_EDE_Encryption : public BlockTransformation
 {
 public:
-    DES_EDE_Encryption(const byte * userKey)
+    DES_EDE_Encryption(const ibyte * userKey)
         : e(userKey, ENCRYPTION), d(userKey + DES::KEYLENGTH, DECRYPTION) {}
 
-    void ProcessBlock(const byte *inBlock, byte * outBlock);
-    void ProcessBlock(byte * inoutBlock);
+    void ProcessBlock(const ibyte *inBlock, ibyte * outBlock);
+    void ProcessBlock(ibyte * inoutBlock);
 
     enum {KEYLENGTH=16, BLOCKSIZE=8};
     unsigned int BlockSize() const {return BLOCKSIZE;}
@@ -55,11 +55,11 @@ private:
 class DES_EDE_Decryption : public BlockTransformation
 {
 public:
-    DES_EDE_Decryption(const byte * userKey)
+    DES_EDE_Decryption(const ibyte * userKey)
         : d(userKey, DECRYPTION), e(userKey + DES::KEYLENGTH, ENCRYPTION) {}
 
-    void ProcessBlock(const byte *inBlock, byte * outBlock);
-    void ProcessBlock(byte * inoutBlock);
+    void ProcessBlock(const ibyte *inBlock, ibyte * outBlock);
+    void ProcessBlock(ibyte * inoutBlock);
 
     enum {KEYLENGTH=16, BLOCKSIZE=8};
     unsigned int BlockSize() const {return BLOCKSIZE;}
@@ -71,12 +71,12 @@ private:
 class TripleDES_Encryption : public BlockTransformation
 {
 public:
-    TripleDES_Encryption(const byte * userKey)
+    TripleDES_Encryption(const ibyte * userKey)
         : e1(userKey, ENCRYPTION), d(userKey + DES::KEYLENGTH, DECRYPTION),
           e2(userKey + 2*DES::KEYLENGTH, ENCRYPTION) {}
 
-    void ProcessBlock(const byte *inBlock, byte * outBlock);
-    void ProcessBlock(byte * inoutBlock);
+    void ProcessBlock(const ibyte *inBlock, ibyte * outBlock);
+    void ProcessBlock(ibyte * inoutBlock);
 
     enum {KEYLENGTH=24, BLOCKSIZE=8};
     unsigned int BlockSize() const {return BLOCKSIZE;}
@@ -88,12 +88,12 @@ private:
 class TripleDES_Decryption : public BlockTransformation
 {
 public:
-    TripleDES_Decryption(const byte * userKey)
+    TripleDES_Decryption(const ibyte * userKey)
         : d1(userKey + 2*DES::KEYLENGTH, DECRYPTION), e(userKey + DES::KEYLENGTH, ENCRYPTION),
           d2(userKey, DECRYPTION) {}
 
-    void ProcessBlock(const byte *inBlock, byte * outBlock);
-    void ProcessBlock(byte * inoutBlock);
+    void ProcessBlock(const ibyte *inBlock, ibyte * outBlock);
+    void ProcessBlock(ibyte * inoutBlock);
 
     enum {KEYLENGTH=24, BLOCKSIZE=8};
     unsigned int BlockSize() const {return BLOCKSIZE;}
diff --git a/src/cryptlib/elgamal.cpp b/src/cryptlib/elgamal.cpp
index 501e512..febf96d 100644
--- a/src/cryptlib/elgamal.cpp
+++ b/src/cryptlib/elgamal.cpp
@@ -53,7 +53,7 @@ void ElGamalCryptoPublicKey::SavePrecomputation(BufferedTransformation &bt) cons
     ypc.Save(bt);
 }
 
-void ElGamalCryptoPublicKey::Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText)
+void ElGamalCryptoPublicKey::Encrypt(RandomNumberGenerator &rng, const ibyte *plainText, unsigned int plainTextLength, ibyte *cipherText)
 {
     assert(plainTextLength <= MaxPlainTextLength());
 
@@ -140,7 +140,7 @@ void ElGamalCryptoPrivateKey::DEREncode(BufferedTransformation &bt) const
     x.DEREncode(seq);
 }
 
-unsigned int ElGamalCryptoPrivateKey::Decrypt(const byte *cipherText, byte *plainText)
+unsigned int ElGamalCryptoPrivateKey::Decrypt(const ibyte *cipherText, ibyte *plainText)
 {
     Integer a(cipherText, modulusLen);
     Integer b(cipherText+modulusLen, modulusLen);
@@ -211,7 +211,7 @@ void ElGamalSigPublicKey::SavePrecomputation(BufferedTransformation &bt) const
     ypc.Save(bt);
 }
 
-bool ElGamalSigPublicKey::Verify(const byte *message, unsigned int messageLen, const byte *signature)
+bool ElGamalSigPublicKey::Verify(const ibyte *message, unsigned int messageLen, const ibyte *signature)
 {
     assert(messageLen <= MaxMessageLength());
 
@@ -287,7 +287,7 @@ void ElGamalSigPrivateKey::DEREncode(BufferedTransformation &bt) const
     x.DEREncode(seq);
 }
 
-void ElGamalSigPrivateKey::Sign(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature)
+void ElGamalSigPrivateKey::Sign(RandomNumberGenerator &rng, const ibyte *message, unsigned int messageLen, ibyte *signature)
 {
     assert(messageLen <= MaxMessageLength());
 
diff --git a/src/cryptlib/elgamal.h b/src/cryptlib/elgamal.h
index 14e4605..2e73814 100644
--- a/src/cryptlib/elgamal.h
+++ b/src/cryptlib/elgamal.h
@@ -17,7 +17,7 @@ public:
     void LoadPrecomputation(BufferedTransformation &storedPrecomputation);
     void SavePrecomputation(BufferedTransformation &storedPrecomputation) const;
 
-    void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText);
+    void Encrypt(RandomNumberGenerator &rng, const ibyte *plainText, unsigned int plainTextLength, ibyte *cipherText);
 
     unsigned int MaxPlainTextLength() const {return STDMIN(255U, modulusLen-3);}
     unsigned int CipherTextLength() const {return 2*modulusLen;}
@@ -45,7 +45,7 @@ public:
     ElGamalCryptoPrivateKey(BufferedTransformation &bt);
     void DEREncode(BufferedTransformation &bt) const;
 
-    unsigned int Decrypt(const byte *cipherText, byte *plainText);
+    unsigned int Decrypt(const ibyte *cipherText, ibyte *plainText);
 
 protected:
     void RawDecrypt(const Integer &a, const Integer &b, Integer &m) const;
@@ -65,7 +65,7 @@ public:
     void LoadPrecomputation(BufferedTransformation &storedPrecomputation);
     void SavePrecomputation(BufferedTransformation &storedPrecomputation) const;
 
-    bool Verify(const byte *message, unsigned int messageLen, const byte *signature);
+    bool Verify(const ibyte *message, unsigned int messageLen, const ibyte *signature);
 
     // message length for signature is unlimited, but only message digests should be signed
     unsigned int MaxMessageLength() const {return 0xffff;}
@@ -97,7 +97,7 @@ public:
     ElGamalSigPrivateKey(BufferedTransformation &bt);
     void DEREncode(BufferedTransformation &bt) const;
 
-    void Sign(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature);
+    void Sign(RandomNumberGenerator &rng, const ibyte *message, unsigned int messageLen, ibyte *signature);
 
     const Integer& GetParameterX() { return x; }
 
diff --git a/src/cryptlib/filters.cpp b/src/cryptlib/filters.cpp
index ef47f2a..52a4f9f 100644
--- a/src/cryptlib/filters.cpp
+++ b/src/cryptlib/filters.cpp
@@ -51,7 +51,7 @@ void BlockFilterBase::ProcessBuf()
     inBufSize=0;
 }
 
-void BlockFilterBase::Put(const byte *inString, unsigned int length)
+void BlockFilterBase::Put(const ibyte *inString, unsigned int length)
 {
     while (length--)
         BlockFilterBase::Put(*inString++);
@@ -75,7 +75,7 @@ void BlockDecryptionFilter::InputFinished()
     inBufSize=0;
 }
 
-void StreamCipherFilter::Put(const byte *inString, unsigned int length)
+void StreamCipherFilter::Put(const ibyte *inString, unsigned int length)
 {
     SecByteBlock temp(length);
     cipher.ProcessString(temp, inString, length);
@@ -89,13 +89,13 @@ void HashFilter::InputFinished()
     outQueue->Put(buf, hash.DigestSize());
 }
 
-BufferedTransformation *Insert(const byte *in, unsigned int length, BufferedTransformation *outQueue)
+BufferedTransformation *Insert(const ibyte *in, unsigned int length, BufferedTransformation *outQueue)
 {
     outQueue->Put(in, length);
     return outQueue;
 }
 
-unsigned int Extract(Source *source, byte *out, unsigned int length)
+unsigned int Extract(Source *source, ibyte *out, unsigned int length)
 {
     while (source->MaxRetrieveable() < length && source->Pump(1));
     return source->Get(out, length);
diff --git a/src/cryptlib/filters.h b/src/cryptlib/filters.h
index 20862e3..253d6f0 100644
--- a/src/cryptlib/filters.h
+++ b/src/cryptlib/filters.h
@@ -20,12 +20,12 @@ public:
     unsigned long MaxRetrieveable()
         {return outQueue->MaxRetrieveable();}
 
-    unsigned int Get(byte &outByte)
+    unsigned int Get(ibyte &outByte)
         {return outQueue->Get(outByte);}
-    unsigned int Get(byte *outString, unsigned int getMax)
+    unsigned int Get(ibyte *outString, unsigned int getMax)
         {return outQueue->Get(outString, getMax);}
 
-    unsigned int Peek(byte &outByte) const
+    unsigned int Peek(ibyte &outByte) const
         {return outQueue->Peek(outByte);}
 
     BufferedTransformation *OutQueue() {return outQueue.get();}
@@ -44,14 +44,14 @@ public:
                     BufferedTransformation *outQueue);
     virtual ~BlockFilterBase() {}
 
-    void Put(byte inByte)
+    void Put(ibyte inByte)
     {
         if (inBufSize == S)
             ProcessBuf();
         inBuf[inBufSize++]=inByte;
     }
 
-    void Put(const byte *inString, unsigned int length);
+    void Put(const ibyte *inString, unsigned int length);
 
 protected:
     void ProcessBuf();
@@ -89,10 +89,10 @@ public:
                        BufferedTransformation *outQueue = NULL)
         : Filter(outQueue), cipher(c) {}
 
-    void Put(byte inByte)
+    void Put(ibyte inByte)
         {outQueue->Put(cipher.ProcessByte(inByte));}
 
-    void Put(const byte *inString, unsigned int length);
+    void Put(const ibyte *inString, unsigned int length);
 
 private:
     StreamCipher &cipher;
@@ -106,10 +106,10 @@ public:
 
     void InputFinished();
 
-    void Put(byte inByte)
+    void Put(ibyte inByte)
         {hash.Update(&inByte, 1);}
 
-    void Put(const byte *inString, unsigned int length)
+    void Put(const ibyte *inString, unsigned int length)
         {hash.Update(inString, length);}
 
 private:
@@ -122,9 +122,9 @@ public:
     Source(BufferedTransformation *outQ = NULL)
         : Filter(outQ) {}
 
-    void Put(byte)
+    void Put(ibyte)
         {Pump(1);}
-    void Put(const byte *, unsigned int length)
+    void Put(const ibyte *, unsigned int length)
         {Pump(length);}
     void InputFinished()
         {PumpAll();}
@@ -138,22 +138,22 @@ class Sink : public BufferedTransformation
 public:
     unsigned long MaxRetrieveable()
         {return 0;}
-    unsigned int Get(byte &)
+    unsigned int Get(ibyte &)
         {return 0;}
-    unsigned int Get(byte *, unsigned int)
+    unsigned int Get(ibyte *, unsigned int)
         {return 0;}
-    unsigned int Peek(byte &) const
+    unsigned int Peek(ibyte &) const
         {return 0;}
 };
 
 class BitBucket : public Sink
 {
 public:
-    void Put(byte) {}
-    void Put(const byte *, unsigned int) {}
+    void Put(ibyte) {}
+    void Put(const ibyte *, unsigned int) {}
 };
 
-BufferedTransformation *Insert(const byte *in, unsigned int length, BufferedTransformation *outQueue);
-unsigned int Extract(Source *source, byte *out, unsigned int length);
+BufferedTransformation *Insert(const ibyte *in, unsigned int length, BufferedTransformation *outQueue);
+unsigned int Extract(Source *source, ibyte *out, unsigned int length);
 
 #endif
diff --git a/src/cryptlib/forkjoin.cpp b/src/cryptlib/forkjoin.cpp
index 899ec85..25cbdbb 100644
--- a/src/cryptlib/forkjoin.cpp
+++ b/src/cryptlib/forkjoin.cpp
@@ -49,13 +49,13 @@ void Fork::Close()
         outPorts[i]->Close();
 }
 
-void Fork::Put(byte inByte)
+void Fork::Put(ibyte inByte)
 {
     for (unsigned int i=0; i<numberOfPorts; i++)
         outPorts[i]->Put(inByte);
 }
 
-void Fork::Put(const byte *inString, unsigned int length)
+void Fork::Put(const ibyte *inString, unsigned int length)
 {
     for (unsigned int i=0; i<numberOfPorts; i++)
         outPorts[i]->Put(inString, length);
@@ -95,13 +95,13 @@ void Join::NotifyClose(unsigned int /* id */)
 
 // ********************************************************
 
-void Interface::Put(byte inByte)
+void Interface::Put(ibyte inByte)
 {
     bq.Put(inByte);
     parent.NotifyInput(id, 1);
 }
 
-void Interface::Put(const byte *inString, unsigned int length)
+void Interface::Put(const ibyte *inString, unsigned int length)
 {
     bq.Put(inString, length);
     parent.NotifyInput(id, length);
@@ -127,17 +127,17 @@ void Interface::Attach(BufferedTransformation *bt)
     parent.Attach(bt);
 }
 
-unsigned int Interface::Get(byte &outByte) 
+unsigned int Interface::Get(ibyte &outByte) 
 {
     return parent.Get(outByte);
 }
 
-unsigned int Interface::Get(byte *outString, unsigned int getMax)
+unsigned int Interface::Get(ibyte *outString, unsigned int getMax)
 {
     return parent.Get(outString, getMax);
 }
 
-unsigned int Interface::Peek(byte &outByte) const
+unsigned int Interface::Peek(ibyte &outByte) const
 {
     return parent.Peek(outByte);
 }
diff --git a/src/cryptlib/forkjoin.h b/src/cryptlib/forkjoin.h
index 65c139e..45e0655 100644
--- a/src/cryptlib/forkjoin.h
+++ b/src/cryptlib/forkjoin.h
@@ -22,15 +22,15 @@ public:
 //    virtual void InputFinished()
 //        {outPorts[currentPort]->InputFinished();}
 
-    unsigned int Get(byte &outByte)
+    unsigned int Get(ibyte &outByte)
         {return outPorts[currentPort]->Get(outByte);}
-    unsigned int Get(byte *outString, unsigned int getMax)
+    unsigned int Get(ibyte *outString, unsigned int getMax)
         {return outPorts[currentPort]->Get(outString, getMax);}
-    unsigned int Peek(byte &outByte) const
+    unsigned int Peek(ibyte &outByte) const
         {return outPorts[currentPort]->Peek(outByte);}
 
-    virtual void Put(byte inByte);
-    virtual void Put(const byte *inString, unsigned int length);
+    virtual void Put(ibyte inByte);
+    virtual void Put(const ibyte *inString, unsigned int length);
 
 protected:
     unsigned int NumberOfPorts() const {return numberOfPorts;}
@@ -57,11 +57,11 @@ public:
     void Detach(BufferedTransformation *bt);
     void Attach(BufferedTransformation *bt);
 
-    void Put(byte inByte);
-    void Put(const byte *inString, unsigned int length);
-    unsigned int Get(byte &outByte);
-    unsigned int Get(byte *outString, unsigned int getMax);
-    unsigned int Peek(byte &outByte) const;
+    void Put(ibyte inByte);
+    void Put(const ibyte *inString, unsigned int length);
+    unsigned int Get(ibyte &outByte);
+    unsigned int Get(ibyte *outString, unsigned int getMax);
+    unsigned int Peek(ibyte &outByte) const;
 
 private:
     Join &parent;
@@ -83,8 +83,8 @@ public:
     virtual void NotifyInput(unsigned int interfaceId, unsigned int length);
     virtual void NotifyClose(unsigned int interfaceId);
 
-    void Put(byte inByte) {outQueue->Put(inByte);}
-    void Put(const byte *inString, unsigned int length)
+    void Put(ibyte inByte) {outQueue->Put(inByte);}
+    void Put(const ibyte *inString, unsigned int length)
         {outQueue->Put(inString, length);}
 
 protected:
diff --git a/src/cryptlib/integer.cpp b/src/cryptlib/integer.cpp
index 2a4ec6a..55c389b 100644
--- a/src/cryptlib/integer.cpp
+++ b/src/cryptlib/integer.cpp
@@ -1159,12 +1159,12 @@ long Integer::ConvertToLong() const
     return sign==POSITIVE ? value : -long(value);
 }
 
-Integer::Integer(const byte *encodedInteger, unsigned int byteCount, Signedness s)
+Integer::Integer(const ibyte *encodedInteger, unsigned int byteCount, Signedness s)
 {
     Decode(encodedInteger, byteCount, s);
 }
 
-Integer::Integer(const byte *BEREncodedInteger)
+Integer::Integer(const ibyte *BEREncodedInteger)
 {
     BERDecode(BEREncodedInteger);
 }
@@ -1241,15 +1241,15 @@ void Integer::SetBit(unsigned int n, bool value)
     }
 }
 
-byte Integer::GetByte(unsigned int n) const
+ibyte Integer::GetByte(unsigned int n) const
 {
     if (n/WORD_SIZE >= reg.size)
         return 0;
     else
-        return byte(reg[n/WORD_SIZE] >> ((n%WORD_SIZE)*8));
+        return ibyte(reg[n/WORD_SIZE] >> ((n%WORD_SIZE)*8));
 }
 
-void Integer::SetByte(unsigned int n, byte value)
+void Integer::SetByte(unsigned int n, ibyte value)
 {
     reg.CleanGrow(RoundupSize(bytesToWords(n+1)));
     reg[n/WORD_SIZE] &= ~(word(0xff) << 8*(n%WORD_SIZE));
@@ -1360,7 +1360,7 @@ unsigned int Integer::BitCount() const
         return 0;
 }
 
-void Integer::Decode(const byte *input, unsigned int inputLen, Signedness s)
+void Integer::Decode(const ibyte *input, unsigned int inputLen, Signedness s)
 {
     sign = ((s==SIGNED) && (input[0] & 0x80)) ? NEGATIVE : POSITIVE;
 
@@ -1395,7 +1395,7 @@ unsigned int Integer::MinEncodedSize(Signedness signedness) const
     return outputLen;
 }
 
-unsigned int Integer::Encode(byte *output, unsigned int outputLen, Signedness signedness) const
+unsigned int Integer::Encode(ibyte *output, unsigned int outputLen, Signedness signedness) const
 {
     if (signedness == UNSIGNED || NotNegative())
     {
@@ -1412,7 +1412,7 @@ unsigned int Integer::Encode(byte *output, unsigned int outputLen, Signedness si
     return outputLen;
 }
 
-unsigned int Integer::DEREncode(byte *output) const
+unsigned int Integer::DEREncode(ibyte *output) const
 {
     unsigned int i=0;
     output[i++] = INTEGER;
@@ -1435,7 +1435,7 @@ unsigned int Integer::DEREncode(BufferedTransformation &bt) const
     return 1+lengthBytes+bc;
 }
 
-void Integer::BERDecode(const byte *input)
+void Integer::BERDecode(const ibyte *input)
 {
     if (*input++ != INTEGER)
         BERDecodeError();
@@ -1456,7 +1456,7 @@ void Integer::BERDecode(const byte *input)
 
 void Integer::BERDecode(BufferedTransformation &bt)
 {
-    byte b;
+    ibyte b;
     if (!bt.Get(b) || b != INTEGER)
         BERDecodeError();
 
@@ -1475,7 +1475,7 @@ void Integer::Randomize(RandomNumberGenerator &rng, unsigned int nbits)
     const unsigned int nbytes = nbits/8 + 1;
     SecByteBlock buf(nbytes);
     rng.GetBlock(buf, nbytes);
-    buf[(unsigned int)0] = (byte)Crop(buf[(unsigned int)0], nbits % 8);
+    buf[(unsigned int)0] = (ibyte)Crop(buf[(unsigned int)0], nbits % 8);
     Decode(buf, nbytes, UNSIGNED);
 }
 
diff --git a/src/cryptlib/integer.h b/src/cryptlib/integer.h
index 82f3349..7df5117 100644
--- a/src/cryptlib/integer.h
+++ b/src/cryptlib/integer.h
@@ -62,10 +62,10 @@ public:
         Integer(const char *str);
 
         /// convert from big-endian byte array
-        Integer(const byte *encodedInteger, unsigned int byteCount, Signedness s=UNSIGNED);
+        Integer(const ibyte *encodedInteger, unsigned int byteCount, Signedness s=UNSIGNED);
 
         /// convert from Basic Encoding Rules encoded byte array
-        Integer(const byte *BEREncodedInteger);
+        Integer(const ibyte *BEREncodedInteger);
 
         /// convert from BER encoded byte array stored in a BufferedTransformation object
         Integer(BufferedTransformation &bt);
@@ -104,10 +104,10 @@ public:
             if outputLen < MinEncodedSize, the most significant bytes will be dropped
             if outputLen > MinEncodedSize, the most significant bytes will be padded
         */
-        unsigned int Encode(byte *output, unsigned int outputLen, Signedness=UNSIGNED) const;
+        unsigned int Encode(ibyte *output, unsigned int outputLen, Signedness=UNSIGNED) const;
 
         /// encode integer using Distinguished Encoding Rules, returns size of output
-        unsigned int DEREncode(byte *output) const;
+        unsigned int DEREncode(ibyte *output) const;
         /// encode using DER, put result into a BufferedTransformation object
         unsigned int DEREncode(BufferedTransformation &bt) const;
 
@@ -121,7 +121,7 @@ public:
         /// return the n-th bit, n=0 being the least significant bit
         bool GetBit(unsigned int n) const;
         /// return the n-th byte
-        byte GetByte(unsigned int n) const;
+        ibyte GetByte(unsigned int n) const;
 
         ///
         bool IsNegative() const {return sign == NEGATIVE;}
@@ -161,10 +161,10 @@ public:
         Integer&  operator>>=(unsigned int);
 
         ///
-        void Decode(const byte *input, unsigned int inputLen, Signedness=UNSIGNED);
+        void Decode(const ibyte *input, unsigned int inputLen, Signedness=UNSIGNED);
 
         ///
-        void BERDecode(const byte *input);
+        void BERDecode(const ibyte *input);
         ///
         void BERDecode(BufferedTransformation &bt);
 
@@ -178,7 +178,7 @@ public:
         /// set the n-th bit to value
         void SetBit(unsigned int n, bool value=1);
         /// set the n-th byte to value
-        void SetByte(unsigned int n, byte value);
+        void SetByte(unsigned int n, ibyte value);
 
         ///
         void Negate();
diff --git a/src/cryptlib/iterhash.h b/src/cryptlib/iterhash.h
index d66cea7..d342fb5 100644
--- a/src/cryptlib/iterhash.h
+++ b/src/cryptlib/iterhash.h
@@ -15,12 +15,12 @@ template <class T> class IteratedHash : public virtual HashModule
 public:
     IteratedHash(unsigned int blockSize, unsigned int digestSize);
     ~IteratedHash();
-    void Update(const byte *input, unsigned int length);
+    void Update(const ibyte *input, unsigned int length);
 
     typedef T HashWordType;
 
 protected:
-    void PadLastBlock(unsigned int lastBlockSize, byte padFirst=0x80);
+    void PadLastBlock(unsigned int lastBlockSize, ibyte padFirst=0x80);
     virtual void Init() =0;
     virtual void HashBlock(const T *input) =0;
 
@@ -39,7 +39,7 @@ template <class T> IteratedHash<T>::~IteratedHash()
 {
 }
 
-template <class T> void IteratedHash<T>::Update(const byte *input, unsigned int len)
+template <class T> void IteratedHash<T>::Update(const ibyte *input, unsigned int len)
 {
     word32 tmp = countLo;
     if ((countLo = tmp + ((word32)len << 3)) < tmp)
@@ -53,7 +53,7 @@ template <class T> void IteratedHash<T>::Update(const byte *input, unsigned int
     {
         if ((num+len) >= blockSize)
         {
-            memcpy((byte *)data.ptr+num, input, blockSize-num);
+            memcpy((ibyte *)data.ptr+num, input, blockSize-num);
             HashBlock(data);
             input += (blockSize-num);
             len-=(blockSize - num);
@@ -62,7 +62,7 @@ template <class T> void IteratedHash<T>::Update(const byte *input, unsigned int
         }
         else
         {
-            memcpy((byte *)data.ptr+num, input, len);
+            memcpy((ibyte *)data.ptr+num, input, len);
             return;
         }
     }
@@ -91,16 +91,16 @@ template <class T> void IteratedHash<T>::Update(const byte *input, unsigned int
     memcpy(data, input, len);
 }
 
-template <class T> void IteratedHash<T>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)
+template <class T> void IteratedHash<T>::PadLastBlock(unsigned int lastBlockSize, ibyte padFirst)
 {
     unsigned int num = (unsigned int)(countLo >> 3) & (blockSize-1);
     assert(num < blockSize);
-    ((byte *)data.ptr)[num++]=padFirst;
+    ((ibyte *)data.ptr)[num++]=padFirst;
     if (num <= lastBlockSize)
-        memset((byte *)data.ptr+num, 0, lastBlockSize-num);
+        memset((ibyte *)data.ptr+num, 0, lastBlockSize-num);
     else
     {
-        memset((byte *)data.ptr+num, 0, blockSize-num);
+        memset((ibyte *)data.ptr+num, 0, blockSize-num);
         HashBlock(data);
         memset(data, 0, lastBlockSize);
     }
diff --git a/src/cryptlib/misc.cpp b/src/cryptlib/misc.cpp
index 6ad4683..62209a7 100644
--- a/src/cryptlib/misc.cpp
+++ b/src/cryptlib/misc.cpp
@@ -4,7 +4,7 @@
 #include "misc.h"
 #include "words.h"
 
-void xorbuf(byte *buf, const byte *mask, unsigned int count)
+void xorbuf(ibyte *buf, const ibyte *mask, unsigned int count)
 {
     if (((ptr_size_type)buf | (ptr_size_type)mask | count) % WORD_SIZE == 0)
         XorWords((word *)buf, (const word *)mask, count/WORD_SIZE);
@@ -15,7 +15,7 @@ void xorbuf(byte *buf, const byte *mask, unsigned int count)
     }
 }
 
-void xorbuf(byte *output, const byte *input, const byte *mask, unsigned int count)
+void xorbuf(ibyte *output, const ibyte *input, const ibyte *mask, unsigned int count)
 {
     if (((ptr_size_type)output | (ptr_size_type)input | (ptr_size_type)mask | count) % WORD_SIZE == 0)
         XorWords((word *)output, (const word *)input, (const word *)mask, count/WORD_SIZE);
diff --git a/src/cryptlib/misc.h b/src/cryptlib/misc.h
index d390fa2..3431277 100644
--- a/src/cryptlib/misc.h
+++ b/src/cryptlib/misc.h
@@ -31,8 +31,8 @@ inline unsigned int bitsToWords(unsigned int bitCount)
     return ((bitCount+WORD_BITS-1)/(WORD_BITS));
 }
 
-void xorbuf(byte *buf, const byte *mask, unsigned int count);
-void xorbuf(byte *output, const byte *input, const byte *mask, unsigned int count);
+void xorbuf(ibyte *buf, const ibyte *mask, unsigned int count);
+void xorbuf(ibyte *output, const ibyte *input, const ibyte *mask, unsigned int count);
 
 template <class T> inline T rotl(T x, unsigned int y)
 {
@@ -116,7 +116,7 @@ template <class T> void byteReverse(T *out, const T *in, unsigned int byteCount)
     #ifdef WORDS_BIGENDIAN
     #error MSVC big endian GETBYTE not implemented
     #else
-    #define GETBYTE(x, y) (((byte *)&(x))[y])
+    #define GETBYTE(x, y) (((ibyte *)&(x))[y])
     #endif
 #else
     #define GETBYTE(x, y) (unsigned int)(((x)>>(8*(y)))&255)
@@ -262,7 +262,7 @@ template <class T> void SecBlock<T>::swap(SecBlock<T> &b)
     std::swap(ptr, b.ptr);
 }
 
-typedef SecBlock<byte> SecByteBlock;
+typedef SecBlock<ibyte> SecByteBlock;
 typedef SecBlock<word> SecWordBlock;
 
 #endif // MISC_H
diff --git a/src/cryptlib/queue.cpp b/src/cryptlib/queue.cpp
index 7a23a43..0947916 100644
--- a/src/cryptlib/queue.cpp
+++ b/src/cryptlib/queue.cpp
@@ -15,20 +15,20 @@ public:
     unsigned int UsedUp() const
         {return (head==MaxSize());}
 
-    unsigned int Put(byte inByte);
-    unsigned int Put(const byte *inString, unsigned int length);
+    unsigned int Put(ibyte inByte);
+    unsigned int Put(const ibyte *inString, unsigned int length);
 
-    unsigned int Get(byte &outByte);
-    unsigned int Get(byte *outString, unsigned int getMax);
+    unsigned int Get(ibyte &outByte);
+    unsigned int Get(ibyte *outString, unsigned int getMax);
 
-    unsigned int Peek(byte &outByte) const;
+    unsigned int Peek(ibyte &outByte) const;
 
     void CopyTo(BufferedTransformation &target) const
         {target.Put(buf+head, tail-head);}
-    void CopyTo(byte *target) const
+    void CopyTo(ibyte *target) const
         {memcpy(target, buf+head, tail-head);}
 
-    byte operator[](unsigned int i) const
+    ibyte operator[](unsigned int i) const
         {return buf[i-head];}
 
     ByteQueueNode *next;
@@ -48,7 +48,7 @@ ByteQueueNode::ByteQueueNode(unsigned int maxSize)
     next = 0;
 }
 
-unsigned int ByteQueueNode::Put(byte inByte)
+unsigned int ByteQueueNode::Put(ibyte inByte)
 {
     if (MaxSize()==tail)
         return 0;
@@ -57,7 +57,7 @@ unsigned int ByteQueueNode::Put(byte inByte)
     return 1;
 }
 
-unsigned int ByteQueueNode::Put(const byte *inString, unsigned int length)
+unsigned int ByteQueueNode::Put(const ibyte *inString, unsigned int length)
 {
     unsigned int l = STDMIN(length, MaxSize()-tail);
     memcpy(buf+tail, inString, l);
@@ -65,7 +65,7 @@ unsigned int ByteQueueNode::Put(const byte *inString, unsigned int length)
     return l;
 }
 
-unsigned int ByteQueueNode::Get(byte &outByte)
+unsigned int ByteQueueNode::Get(ibyte &outByte)
 {
     if (tail==head)
         return 0;
@@ -74,7 +74,7 @@ unsigned int ByteQueueNode::Get(byte &outByte)
     return 1;
 }
 
-unsigned int ByteQueueNode::Get(byte *outString, unsigned int getMax)
+unsigned int ByteQueueNode::Get(ibyte *outString, unsigned int getMax)
 {
     unsigned int l = STDMIN(getMax, tail-head);
     memcpy(outString, buf+head, l);
@@ -82,7 +82,7 @@ unsigned int ByteQueueNode::Get(byte *outString, unsigned int getMax)
     return l;
 }
 
-unsigned int ByteQueueNode::Peek(byte &outByte) const
+unsigned int ByteQueueNode::Peek(ibyte &outByte) const
 {
     if (tail==head)
         return 0;
@@ -140,7 +140,7 @@ void ByteQueue::CopyTo(BufferedTransformation &target) const
         current->CopyTo(target);
 }
 
-void ByteQueue::CopyTo(byte *target) const
+void ByteQueue::CopyTo(ibyte *target) const
 {
     for (ByteQueueNode *current=head; current; current=current->next)
     {
@@ -159,7 +159,7 @@ unsigned long ByteQueue::CurrentSize() const
     return size;
 }
 
-void ByteQueue::Put(byte inByte)
+void ByteQueue::Put(ibyte inByte)
 {
     if (!tail->Put(inByte))
     {
@@ -169,7 +169,7 @@ void ByteQueue::Put(byte inByte)
     }
 }
 
-void ByteQueue::Put(const byte *inString, unsigned int length)
+void ByteQueue::Put(const ibyte *inString, unsigned int length)
 {
     unsigned int l;
 
@@ -182,7 +182,7 @@ void ByteQueue::Put(const byte *inString, unsigned int length)
     }
 }
 
-unsigned int ByteQueue::Get(byte &outByte)
+unsigned int ByteQueue::Get(ibyte &outByte)
 {
     int l = head->Get(outByte);
     if (head->UsedUp())
@@ -196,7 +196,7 @@ unsigned int ByteQueue::Get(byte &outByte)
     return l;
 }
 
-unsigned int ByteQueue::Get(byte *outString, unsigned int getMax)
+unsigned int ByteQueue::Get(ibyte *outString, unsigned int getMax)
 {
     unsigned int getMaxSave=getMax;
     ByteQueueNode *current=head;
@@ -224,7 +224,7 @@ unsigned int ByteQueue::Get(byte *outString, unsigned int getMax)
     return (getMaxSave-getMax);
 }
 
-unsigned int ByteQueue::Peek(byte &outByte) const
+unsigned int ByteQueue::Peek(ibyte &outByte) const
 {
     return head->Peek(outByte);
 }
@@ -250,7 +250,7 @@ bool ByteQueue::operator==(const ByteQueue &rhs) const
     return true;
 }
 
-byte ByteQueue::operator[](unsigned long i) const
+ibyte ByteQueue::operator[](unsigned long i) const
 {
     for (ByteQueueNode *current=head; current; current=current->next)
     {
diff --git a/src/cryptlib/queue.h b/src/cryptlib/queue.h
index c340652..82921a0 100644
--- a/src/cryptlib/queue.h
+++ b/src/cryptlib/queue.h
@@ -21,21 +21,21 @@ public:
     unsigned long MaxRetrieveable()
         {return CurrentSize();}
 
-    void Put(byte inByte);
-    void Put(const byte *inString, unsigned int length);
+    void Put(ibyte inByte);
+    void Put(const ibyte *inString, unsigned int length);
 
     // both functions returns the number of bytes actually retrived
-    unsigned int Get(byte &outByte);
-    unsigned int Get(byte *outString, unsigned int getMax);
+    unsigned int Get(ibyte &outByte);
+    unsigned int Get(ibyte *outString, unsigned int getMax);
 
-    unsigned int Peek(byte &outByte) const;
+    unsigned int Peek(ibyte &outByte) const;
 
     void CopyTo(BufferedTransformation &target) const;
-    void CopyTo(byte *target) const;
+    void CopyTo(ibyte *target) const;
 
     ByteQueue & operator=(const ByteQueue &rhs);
     bool operator==(const ByteQueue &rhs) const;
-    byte operator[](unsigned long i) const;
+    ibyte operator[](unsigned long i) const;
 
 private:
     void CopyFrom(const ByteQueue &copy);
diff --git a/src/cryptlib/rng.cpp b/src/cryptlib/rng.cpp
index 0f62a87..178ad76 100644
--- a/src/cryptlib/rng.cpp
+++ b/src/cryptlib/rng.cpp
@@ -32,7 +32,7 @@ const word16 LC_RNG::a=16807;
 const word16 LC_RNG::r=2836;
 #endif
 
-byte LC_RNG::GetByte()
+ibyte LC_RNG::GetByte()
 {
     word32 hi = seed/q;
     word32 lo = seed%q;
@@ -49,7 +49,7 @@ byte LC_RNG::GetByte()
 
 // ********************************************************
 
-X917RNG::X917RNG(BlockTransformation *c, const byte *seed)
+X917RNG::X917RNG(BlockTransformation *c, const ibyte *seed)
     : cipher(c),
       S(cipher->BlockSize()),
       dtbuf(S),
@@ -58,20 +58,20 @@ X917RNG::X917RNG(BlockTransformation *c, const byte *seed)
       randbuf_counter(0)
 {
     time_t tstamp1 = time(0);
-    xorbuf(dtbuf, (byte *)&tstamp1, STDMIN((int)sizeof(tstamp1), S));
+    xorbuf(dtbuf, (ibyte *)&tstamp1, STDMIN((int)sizeof(tstamp1), S));
     cipher->ProcessBlock(dtbuf);
     clock_t tstamp2 = clock();
-    xorbuf(dtbuf, (byte *)&tstamp2, STDMIN((int)sizeof(tstamp2), S));
+    xorbuf(dtbuf, (ibyte *)&tstamp2, STDMIN((int)sizeof(tstamp2), S));
     cipher->ProcessBlock(dtbuf);
 }
 
-byte X917RNG::GetByte()
+ibyte X917RNG::GetByte()
 {
     if (randbuf_counter==0)
     {
         // calculate new enciphered timestamp
         clock_t tstamp = clock();
-        xorbuf(dtbuf, (byte *)&tstamp, STDMIN((int)sizeof(tstamp), S));
+        xorbuf(dtbuf, (ibyte *)&tstamp, STDMIN((int)sizeof(tstamp), S));
         cipher->ProcessBlock(dtbuf);
 
         // combine enciphered timestamp with seed
@@ -97,7 +97,7 @@ MaurerRandomnessTest::MaurerRandomnessTest()
         tab[i] = 0;
 }
 
-inline void MaurerRandomnessTest::Put(byte inByte)
+inline void MaurerRandomnessTest::Put(ibyte inByte)
 {
     if (n >= Q)
         sum += log(double(n - tab[inByte]));
@@ -105,7 +105,7 @@ inline void MaurerRandomnessTest::Put(byte inByte)
     n++;
 }
 
-void MaurerRandomnessTest::Put(const byte *inString, unsigned int length)
+void MaurerRandomnessTest::Put(const ibyte *inString, unsigned int length)
 {
     while (length--)
         Put(*inString++);
diff --git a/src/cryptlib/rng.h b/src/cryptlib/rng.h
index c39b828..4e03398 100644
--- a/src/cryptlib/rng.h
+++ b/src/cryptlib/rng.h
@@ -13,15 +13,15 @@ class LC_RNG : public RandomNumberGenerator
 {
 public:
     LC_RNG(word32 init_seed)
-        : seedBytes((byte *)&seed) {seed=init_seed;}
+        : seedBytes((ibyte *)&seed) {seed=init_seed;}
 
-    byte GetByte();
+    ibyte GetByte();
 
     word32 GetSeed() {return seed;}
 
 private:
     word32 seed;
-    byte *const seedBytes;
+    ibyte *const seedBytes;
 
     static const word32 m;
     static const word32 q;
@@ -35,9 +35,9 @@ class X917RNG : public RandomNumberGenerator
 {
 public:
     // cipher will be deleted by destructor
-    X917RNG(BlockTransformation *cipher, const byte *seed);
+    X917RNG(BlockTransformation *cipher, const ibyte *seed);
 
-    byte GetByte();
+    ibyte GetByte();
 
 private:
     member_ptr<BlockTransformation> cipher;
@@ -56,8 +56,8 @@ class MaurerRandomnessTest : public Sink
 public:
     MaurerRandomnessTest();
 
-    void Put(byte inByte);
-    void Put(const byte *inString, unsigned int length);
+    void Put(ibyte inByte);
+    void Put(const ibyte *inString, unsigned int length);
 
     // BytesNeeded() returns how many more bytes of input is needed by the test
     // GetTestValue() should not be called before BytesNeeded()==0
diff --git a/src/cryptlib/sha.cpp b/src/cryptlib/sha.cpp
index cb1fc49..d03a131 100644
--- a/src/cryptlib/sha.cpp
+++ b/src/cryptlib/sha.cpp
@@ -31,7 +31,7 @@ void SHA::HashBlock(const word32 *input)
 #endif
 }
 
-void SHA::Final(byte *hash)
+void SHA::Final(ibyte *hash)
 {
     PadLastBlock(56);
     CorrectEndianess(data, data, 56);
diff --git a/src/cryptlib/sha.h b/src/cryptlib/sha.h
index 99e9ad7..9382688 100644
--- a/src/cryptlib/sha.h
+++ b/src/cryptlib/sha.h
@@ -7,7 +7,7 @@ class SHA : public IteratedHash<word32>
 {
 public:
     SHA();
-    void Final(byte *hash);
+    void Final(ibyte *hash);
     unsigned int DigestSize() const {return DIGESTSIZE;};
 
     static void CorrectEndianess(word32 *out, const word32 *in, unsigned int byteCount)
diff --git a/src/cryptlib/zbits.cpp b/src/cryptlib/zbits.cpp
index 8be571f..cf488fe 100644
--- a/src/cryptlib/zbits.cpp
+++ b/src/cryptlib/zbits.cpp
@@ -63,13 +63,13 @@ void BitOutput::bi_windup()
 
 void BitOutput::bi_putsh(word16 x)
 {
-    outQ.Put((byte)x);
-    outQ.Put(byte(x>>8));
+    outQ.Put((ibyte)x);
+    outQ.Put(ibyte(x>>8));
 }
 
 /* Copy a stored block to the zip file, storing first the length and its
    one's complement if requested. */
-void BitOutput::copy_block(byte *buf, unsigned int len, int header)
+void BitOutput::copy_block(ibyte *buf, unsigned int len, int header)
 {
    /* align on byte boundary */
    bi_windup();
diff --git a/src/cryptlib/zbits.h b/src/cryptlib/zbits.h
index 8f5dcb5..c02797e 100644
--- a/src/cryptlib/zbits.h
+++ b/src/cryptlib/zbits.h
@@ -11,7 +11,7 @@ public:
     void send_bits  (unsigned value, int length);
     void bi_windup  (void);
     void bi_putsh   (unsigned short);
-    void copy_block (byte *buf, unsigned len, int header);
+    void copy_block (ibyte *buf, unsigned len, int header);
 
 private:
     BufferedTransformation &outQ;
diff --git a/src/cryptlib/zdeflate.cpp b/src/cryptlib/zdeflate.cpp
index 60d74e3..a874b0c 100644
--- a/src/cryptlib/zdeflate.cpp
+++ b/src/cryptlib/zdeflate.cpp
@@ -175,7 +175,7 @@ Deflator::Deflator(int deflate_level, BufferedTransformation *outQ)
    prev_length = MIN_MATCH-1;
 }
 
-void Deflator::Put(const byte *inString, unsigned int length)
+void Deflator::Put(const ibyte *inString, unsigned int length)
 {
     if (deflate_level <= 3)
         fast_deflate(inString, length);
@@ -205,8 +205,8 @@ void Deflator::InputFinished()
 int Deflator::longest_match(IPos cur_match)
 {
    unsigned chain_length = max_chain_length;   /* max hash chain length */
-   register byte *scan = window + strstart;     /* current string */
-   register byte *match;                        /* matched string */
+   register ibyte *scan = window + strstart;     /* current string */
+   register ibyte *match;                        /* matched string */
    register int len;                           /* length of current match */
    int best_len = prev_length;                 /* best match length so far */
    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;
@@ -223,13 +223,13 @@ int Deflator::longest_match(IPos cur_match)
 #ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
       Try with and without -DUNALIGNED_OK to check. */
-   register byte *strend = window + strstart + MAX_MATCH - 1;
+   register ibyte *strend = window + strstart + MAX_MATCH - 1;
    register word16 scan_start = *(word16*)scan;
    register word16 scan_end   = *(word16*)(scan+best_len-1);
 #else
-   register byte *strend = window + strstart + MAX_MATCH;
-   register byte scan_end1 = scan[best_len-1];
-   register byte scan_end  = scan[best_len];
+   register ibyte *strend = window + strstart + MAX_MATCH;
+   register ibyte scan_end1 = scan[best_len-1];
+   register ibyte scan_end  = scan[best_len];
 #endif
 
    /* Do not waste too much time if we already have a good match: */
@@ -350,7 +350,7 @@ int length;
  * IN assertion: lookahead < MIN_LOOKAHEAD.
  * Note: call with either lookahead == 0 or length == 0 is valid
  */
-unsigned Deflator::fill_window(const byte *buffer, unsigned int length)
+unsigned Deflator::fill_window(const ibyte *buffer, unsigned int length)
 {
    register unsigned n, m;
    unsigned more = length;
@@ -382,7 +382,7 @@ unsigned Deflator::fill_window(const byte *buffer, unsigned int length)
       if ((more += WSIZE) > length) more = length;
    }
    if (more) {
-      memcpy((byte*)window+strstart+lookahead, buffer, more);
+      memcpy((ibyte*)window+strstart+lookahead, buffer, more);
       lookahead += more;
    }
    return more;
@@ -390,15 +390,13 @@ unsigned Deflator::fill_window(const byte *buffer, unsigned int length)
 
 /* Flush the current block, with given end-of-file flag.
    IN assertion: strstart is set to the end of the current match. */
-#define FLUSH_BLOCK(eof) flush_block(block_start >= 0L ?\
-        window+block_start : \
-        (byte *)0, (long)strstart - block_start, (eof))
+#define FLUSH_BLOCK(eof) flush_block(block_start >= 0L ? window+block_start : (ibyte *)0, (long)strstart - block_start, (eof))
 
 /* Processes a new input block.
  * This function does not perform lazy evaluationof matches and inserts
  * new strings in the dictionary only for unmatched strings or for short
  * matches. It is used only for the fast compression options. */
-int Deflator::fast_deflate(const byte *buffer, unsigned int length)
+int Deflator::fast_deflate(const ibyte *buffer, unsigned int length)
 {
    IPos hash_head; /* head of the hash chain */
    int flush;      /* set if current block must be flushed */
@@ -486,7 +484,7 @@ int Deflator::fast_deflate(const byte *buffer, unsigned int length)
 /* Same as above, but achieves better compression. We use a lazy
  * evaluation for matches: a match is finally adopted only if there is
  * no better match at the next window position.  */
-int Deflator::lazy_deflate(const byte *buffer, unsigned int length)
+int Deflator::lazy_deflate(const ibyte *buffer, unsigned int length)
 {
    IPos hash_head;          /* head of hash chain */
    IPos prev_match;         /* previous match */
diff --git a/src/cryptlib/zdeflate.h b/src/cryptlib/zdeflate.h
index 23b26df..cf449f5 100644
--- a/src/cryptlib/zdeflate.h
+++ b/src/cryptlib/zdeflate.h
@@ -13,9 +13,9 @@ public:
     // default for the gzip program is 6
     Deflator(int deflate_level, BufferedTransformation *outQ = NULL);
 
-    void Put(byte inByte)
+    void Put(ibyte inByte)
         {Deflator::Put(&inByte, 1);}
-    void Put(const byte *inString, unsigned int length);
+    void Put(const ibyte *inString, unsigned int length);
 
     void InputFinished();
 
@@ -52,13 +52,13 @@ private:
     SecByteBlock window;
     SecBlock<Pos> prev, head;
 
-    unsigned fill_window (const byte*, unsigned);
+    unsigned fill_window (const ibyte*, unsigned);
     void     init_hash   ();
 
     int longest_match (IPos cur_match);
 
-    int fast_deflate(const byte *buffer, unsigned int length);
-    int lazy_deflate(const byte *buffer, unsigned int length);
+    int fast_deflate(const ibyte *buffer, unsigned int length);
+    int lazy_deflate(const ibyte *buffer, unsigned int length);
 
     unsigned ins_h;  /* hash index of string to be inserted */
     char uptodate;   /* hash preparation flag */
diff --git a/src/cryptlib/zinflate.cpp b/src/cryptlib/zinflate.cpp
index b6b8b87..d8076ec 100644
--- a/src/cryptlib/zinflate.cpp
+++ b/src/cryptlib/zinflate.cpp
@@ -74,7 +74,7 @@ Inflator::Inflator(BufferedTransformation *output, BufferedTransformation *bypas
     afterEnd = false;
 }
 
-void Inflator::Put(const byte *inString, unsigned int length)
+void Inflator::Put(const ibyte *inString, unsigned int length)
 {
     if (afterEnd)
         AccessPort(1).Put(inString, length);
@@ -89,7 +89,7 @@ void Inflator::Put(const byte *inString, unsigned int length)
         {
             flush_output(wp);
             if (bk>=8)  // undo too much lookahead
-                AccessPort(1).Put(byte(bb>>(bk-=8)));
+                AccessPort(1).Put(ibyte(bb>>(bk-=8)));
 
             inQueue.TransferTo(AccessPort(1));
         }
@@ -104,7 +104,7 @@ void Inflator::InputFinished()
     flush_output(wp);
 
     if (bk>=8)  // undo too much lookahead
-        AccessPort(1).Put(byte(bb>>(bk-=8)));
+        AccessPort(1).Put(ibyte(bb>>(bk-=8)));
 
     inQueue.TransferTo(AccessPort(1));
 }
@@ -183,9 +183,9 @@ const word16 Inflator::mask_bits[] = {
     0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
 };
 
-byte Inflator::NEXTBYTE()
+ibyte Inflator::NEXTBYTE()
 {
-    byte b;
+    ibyte b;
     if (!inQueue.Get(b))
 #ifdef THROW_EXCEPTIONS
         throw UnexpectedEndErr();
@@ -380,8 +380,8 @@ int Inflator::huft_build(unsigned *b, unsigned n, unsigned s, const word16 *d, c
         if (h)
         {
           x[h] = i;             /* save pattern for backing up */
-          r.b = (byte)l;         /* bits to dump before this table */
-          r.e = (byte)(16 + j);  /* bits in this table */
+          r.b = (ibyte)l;         /* bits to dump before this table */
+          r.e = (ibyte)(16 + j);  /* bits in this table */
           r.v.t = q;            /* pointer to this table */
           j = i >> (w - l);     /* (get around Turbo C bug) */
           u[h-1][j] = r;        /* connect to last table */
@@ -389,18 +389,18 @@ int Inflator::huft_build(unsigned *b, unsigned n, unsigned s, const word16 *d, c
       }
 
       /* set up table entry in r */
-      r.b = (byte)(k - w);
+      r.b = (ibyte)(k - w);
       if (p >= v + n)
         r.e = 99;               /* out of values--invalid code */
       else if (*p < s)
       {
-        r.e = (byte)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
+        r.e = (ibyte)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
         r.v.n = (word16)(*p);             /* simple code is just the value */
     p++;                           /* one compiler does not like *p++ */
       }
       else
       {
-        r.e = (byte)e[*p - s];   /* non-simple--look up in lists */
+        r.e = (ibyte)e[*p - s];   /* non-simple--look up in lists */
         r.v.n = d[*p++ - s];
       }
 
@@ -485,7 +485,7 @@ int Inflator::inflate_codes(huft *tl, huft *td, int bl, int bd)
     DUMPBITS(t->b)
     if (e == 16)                /* then it's a literal */
     {
-      slide[w++] = (byte)t->v.n;
+      slide[w++] = (ibyte)t->v.n;
       Tracevv((stderr, "%c", slide[w-1]));
       if (w == WSIZE)
       {
@@ -591,7 +591,7 @@ int Inflator::inflate_stored()
   while (n--)
   {
     NEEDBITS(8)
-    slide[w++] = (byte)b;
+    slide[w++] = (ibyte)b;
     if (w == WSIZE)
     {
       flush_output(w);
diff --git a/src/cryptlib/zinflate.h b/src/cryptlib/zinflate.h
index 5e9c931..090a7da 100644
--- a/src/cryptlib/zinflate.h
+++ b/src/cryptlib/zinflate.h
@@ -14,16 +14,16 @@ public:
     Inflator(BufferedTransformation *output = NULL,
              BufferedTransformation *bypassed = NULL);
 
-    void Put(byte b)
+    void Put(ibyte b)
         {Inflator::Put(&b, 1);}
 
-    void Put(const byte *inString, unsigned int length);
+    void Put(const ibyte *inString, unsigned int length);
     void InputFinished();
 
 private:
     struct huft {
-      byte e;                /* number of extra bits or operation */
-      byte b;                /* number of bits in this code or subcode */
+      ibyte e;                /* number of extra bits or operation */
+      ibyte b;                /* number of bits in this code or subcode */
       union {
         word16 n;              /* literal, length base, or distance base */
         struct huft *t;     /* pointer to next level of table */
@@ -49,7 +49,7 @@ private:
     static const word16 mask_bits[18];
 
     ByteQueue inQueue;
-    byte NEXTBYTE();
+    ibyte NEXTBYTE();
 
     SecByteBlock slide;
     unsigned int wp;
diff --git a/src/cryptlib/ztrees.cpp b/src/cryptlib/ztrees.cpp
index e600583..9200a34 100644
--- a/src/cryptlib/ztrees.cpp
+++ b/src/cryptlib/ztrees.cpp
@@ -75,7 +75,7 @@ const int CodeTree::extra_dbits[] /* extra bits for each distance code */
 const int CodeTree::extra_blbits[]/* extra bits for each bit length code */
    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
 
-const byte CodeTree::bl_order[]
+const ibyte CodeTree::bl_order[]
    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
@@ -136,21 +136,21 @@ CodeTree::CodeTree(int deflate_level, BufferedTransformation &outQ)
    for (code=0; code < LENGTH_CODES-1; code++) {
       base_length[code] = length;
       for (n=0; n < (1U<<extra_lbits[code]); n++) {
-         length_code[length++] = (byte)code;
+         length_code[length++] = (ibyte)code;
       }
    }
    assert (length == 256);
     /* Note that the length 255 (match length 258) can be represented
        in two different ways: code 284 + 5 bits or code 285, so we
        overwrite length_code[255] to use the best encoding:     */
-   length_code[length-1] = (byte)code;
+   length_code[length-1] = (ibyte)code;
 
    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code=0 ; code < 16; code++) {
       base_dist[code] = dist;
       for (n=0; n < (1U<<extra_dbits[code]); n++) {
-         dist_code[dist++] = (byte)code;
+         dist_code[dist++] = (ibyte)code;
       }
    }
    assert (dist == 256);
@@ -158,7 +158,7 @@ CodeTree::CodeTree(int deflate_level, BufferedTransformation &outQ)
    for (; code < D_CODES; code++) {
       base_dist[code] = dist << 7;
       for (n=0; n < (1U<<(extra_dbits[code]-7)); n++) {
-         dist_code[256 + dist++] = (byte)code;
+         dist_code[256 + dist++] = (ibyte)code;
       }
    }
    assert (dist == 256);
@@ -444,7 +444,7 @@ void CodeTree::build_tree(tree_desc *desc)
 
         /* Create a new node father of n and m */
         tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        depth[(unsigned int)node] = (byte) (MAX(depth[(unsigned int)n], depth[(unsigned int)m]) + 1);
+        depth[(unsigned int)node] = (ibyte) (MAX(depth[(unsigned int)n], depth[(unsigned int)m]) + 1);
         tree[n].Dad = tree[m].Dad = node;
 #ifdef DUMP_BL_TREE
         if (tree == bl_tree) {
@@ -627,7 +627,7 @@ void CodeTree::send_all_trees(int lcodes, int dcodes, int blcodes)
  * trees or store, and output the encoded block to the zip file. This function
  * returns the total compressed length for the file so far.
  */
-word32 CodeTree::flush_block(byte *buf, word32 stored_len, int eof)
+word32 CodeTree::flush_block(ibyte *buf, word32 stored_len, int eof)
 {
    word32 opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex;  /* index of last bit length code of non zero freq */
@@ -712,7 +712,7 @@ word32 CodeTree::flush_block(byte *buf, word32 stored_len, int eof)
    Return true if the current block must be flushed. */
 int CodeTree::ct_tally (int dist, int lc)
 {
-   l_buf[last_lit++] = (byte)lc;
+   l_buf[last_lit++] = (ibyte)lc;
    if (dist == 0) {
       /* lc is the unmatched char */
       dyn_ltree[(unsigned int)lc].Freq++;
@@ -765,7 +765,7 @@ void CodeTree::compress_block(ct_data *ltree, ct_data *dtree)
    unsigned lx = 0;    /* running index in l_buf */
    unsigned dx = 0;    /* running index in d_buf */
    unsigned fx = 0;    /* running index in flag_buf */
-   byte flag = 0;       /* current flags */
+   ibyte flag = 0;       /* current flags */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */
 
diff --git a/src/cryptlib/ztrees.h b/src/cryptlib/ztrees.h
index 1e6233c..fa59907 100644
--- a/src/cryptlib/ztrees.h
+++ b/src/cryptlib/ztrees.h
@@ -10,7 +10,7 @@ public:
     CodeTree(int deflate_level, BufferedTransformation &outQ);
 
     int  ct_tally (int dist, int lc);
-    word32  flush_block (byte *buf, word32 stored_len, int eof);
+    word32  flush_block (ibyte *buf, word32 stored_len, int eof);
 
     long block_start;       /* window offset of current block */
     unsigned int strstart; /* window offset of current string */
@@ -73,7 +73,7 @@ private:
     static const int extra_lbits[LENGTH_CODES];
     static const int extra_dbits[D_CODES];
     static const int extra_blbits[BL_CODES];
-    static const byte bl_order[BL_CODES];
+    static const ibyte bl_order[BL_CODES];
 
 public:
     // Data structure describing a single value and its code string. */
@@ -168,8 +168,8 @@ private:
     unsigned last_lit;    /* running index in l_buf */
     unsigned last_dist;   /* running index in d_buf */
     unsigned last_flags;  /* running index in flag_buf */
-    byte flags;            /* current flags not yet saved in flag_buf */
-    byte flag_bit;         /* current bit used in flags */
+    ibyte flags;            /* current flags not yet saved in flag_buf */
+    ibyte flag_bit;         /* current bit used in flags */
     /* bits are filled in flags starting at bit 0 (least significant).
      * Note: these flags are overkill in the current code since we don't
      * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
diff --git a/src/db/Makefile.in b/src/db/Makefile.in
index c875d47..7e10e50 100644
--- a/src/db/Makefile.in
+++ b/src/db/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -128,7 +128,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -195,8 +195,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -211,10 +209,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -224,6 +222,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -300,6 +299,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -346,8 +346,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -451,8 +451,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/fco/Makefile.in b/src/fco/Makefile.in
index 0300072..0264b07 100644
--- a/src/fco/Makefile.in
+++ b/src/fco/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -136,7 +136,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -203,8 +203,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -219,10 +217,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -232,6 +230,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -308,6 +307,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -367,8 +367,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -472,8 +472,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/fco/signature.cpp b/src/fco/signature.cpp
index f937586..176d551 100644
--- a/src/fco/signature.cpp
+++ b/src/fco/signature.cpp
@@ -107,10 +107,10 @@ void cArchiveSigGen::AddSig(iSignature* pSig)
 
 void cArchiveSigGen::CalculateSignatures(cArchive& a)
 {
-    byte                      abBuf[iSignature::SUGGESTED_BLOCK_SIZE * 2];
+    ibyte                      abBuf[iSignature::SUGGESTED_BLOCK_SIZE * 2];
     int                       cbRead;
     container_type::size_type i;
-    byte*                     pBuf = abBuf;
+    ibyte*                     pBuf = abBuf;
 
     if (s_direct)
     {
@@ -154,13 +154,13 @@ void cArchiveSigGen::SetHex(bool hex)
 //        number of bits in the array
 //        ptr-to-str for return string val
 ///////////////////////////////////////////////////////////////////////////////
-char* btob64(const register byte* pcbitvec, register char* pcout, int numbits)
+char* btob64(const register ibyte* pcbitvec, register char* pcout, int numbits)
 {
     register unsigned int val;
     register int          offset;
     uint8*                pcorig = (uint8*)pcout;
 
-    ASSERT(sizeof(uint8) == sizeof(byte)); /* everything breaks otherwise */
+    ASSERT(sizeof(uint8) == sizeof(ibyte)); /* everything breaks otherwise */
     assert(numbits > 0);
 
     val = *pcbitvec;
@@ -214,7 +214,7 @@ char* pltob64(uint32* pl, char* pcout, int numlongs)
         ++plto;
     }
 
-    return btob64((byte*)larray, (char*)pcout, numlongs * sizeof(uint32) * 8);
+    return btob64((ibyte*)larray, (char*)pcout, numlongs * sizeof(uint32) * 8);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -235,7 +235,7 @@ void cNullSignature::Init()
 {
 }
 
-void cNullSignature::Update(const byte* const pbData, int cbDataLen)
+void cNullSignature::Update(const ibyte* const pbData, int cbDataLen)
 {
 }
 
@@ -310,9 +310,9 @@ void cChecksumSignature::Init()
 {
 }
 
-void cChecksumSignature::Update(const byte* const pbDataC, int cbDataLen)
+void cChecksumSignature::Update(const ibyte* const pbDataC, int cbDataLen)
 {
-    byte* pbData = (byte*)pbDataC;
+    ibyte* pbData = (ibyte*)pbDataC;
     for (int i = 0; i < cbDataLen; i++, pbData++)
         mChecksum += *pbData;
 }
@@ -398,9 +398,9 @@ void cCRC32Signature::Init()
     crcInit(mCRCInfo);
 }
 
-void cCRC32Signature::Update(const byte* const pbData, int cbDataLen)
+void cCRC32Signature::Update(const ibyte* const pbData, int cbDataLen)
 {
-    ASSERT(sizeof(byte) == sizeof(uint8));
+    ASSERT(sizeof(ibyte) == sizeof(uint8));
     crcUpdate(mCRCInfo, (uint8*)pbData, cbDataLen);
 }
 
@@ -501,7 +501,7 @@ void cMD5Signature::Init()
 #endif
 }
 
-void cMD5Signature::Update(const byte* const pbData, int cbDataLen)
+void cMD5Signature::Update(const ibyte* const pbData, int cbDataLen)
 {
 #ifdef HAVE_COMMONCRYPTO_COMMONDIGEST_H
     CC_MD5_Update(&mMD5Info, (uint8*)pbData, cbDataLen);
@@ -534,8 +534,8 @@ TSTRING cMD5Signature::AsString() const
     TSTRING ret;
     char    buf[24];
 
-    ASSERT(sizeof(uint8) == sizeof(byte)); /* everything breaks otherwise */
-    btob64((byte*)md5_digest, buf, SIG_BYTE_SIZE * 8);
+    ASSERT(sizeof(uint8) == sizeof(ibyte)); /* everything breaks otherwise */
+    btob64((ibyte*)md5_digest, buf, SIG_BYTE_SIZE * 8);
     //converting to base64 representation.
 
     ret.append(buf);
@@ -626,9 +626,9 @@ void cSHASignature::Init()
 #endif
 }
 
-void cSHASignature::Update(const byte* const pbData, int cbDataLen)
+void cSHASignature::Update(const ibyte* const pbData, int cbDataLen)
 {
-    ASSERT(sizeof(byte) == sizeof(uint8));
+    ASSERT(sizeof(ibyte) == sizeof(uint8));
 #ifdef HAVE_COMMONCRYPTO_COMMONDIGEST_H
     CC_SHA1_Update(&mSHAInfo, (uint8*)pbData, cbDataLen);
 #elif HAVE_OPENSSL_SHA_H
@@ -822,7 +822,7 @@ void cHAVALSignature::Init()
     haval_start(&mHavalState);
 }
 
-void cHAVALSignature::Update(const byte* const pbData, int cbDataLen)
+void cHAVALSignature::Update(const ibyte* const pbData, int cbDataLen)
 {
     haval_hash(&mHavalState, (uint8*)pbData, cbDataLen);
 }
@@ -842,7 +842,7 @@ TSTRING cHAVALSignature::AsString() const
     TSTRING ret;
     char    buf[24];
 
-    btob64((byte*)mSignature, buf, 128);
+    btob64((ibyte*)mSignature, buf, 128);
     //converting to base64 representation.
 
     ret.append(buf);
diff --git a/src/fco/signature.h b/src/fco/signature.h
index b502f3f..426000d 100644
--- a/src/fco/signature.h
+++ b/src/fco/signature.h
@@ -76,7 +76,7 @@
 #include <CommonCrypto/CommonDigest.h>
 #endif
 
-
+#include "cryptlib/config.h"
 #include "core/haval.h"
 // TODO: figure out a way to do this without including these headers.
 // pool of objects?
@@ -108,7 +108,7 @@ public:
     //
     virtual void Init() = 0;
     // call before beginning hashing
-    virtual void Update(const byte* const pbData, int cbDataLen) = 0;
+    virtual void Update(const ibyte* const pbData, int cbDataLen) = 0;
     // may be called multiple times -- best to call with blocks of size SUGGESTED_BLOCK_SIZE,
     // but can handle any size data.
     virtual void Finit() = 0;
@@ -192,7 +192,7 @@ public:
     virtual ~cNullSignature();
 
     virtual void    Init();
-    virtual void    Update(const byte* const pbData, int cbDataLen);
+    virtual void    Update(const ibyte* const pbData, int cbDataLen);
     virtual void    Finit();
     virtual TSTRING AsString() const;
     virtual TSTRING AsStringHex() const;
@@ -219,7 +219,7 @@ public:
     virtual ~cChecksumSignature();
 
     virtual void    Init();
-    virtual void    Update(const byte* const pbData, int cbDataLen);
+    virtual void    Update(const ibyte* const pbData, int cbDataLen);
     virtual void    Finit();
     virtual TSTRING AsString() const;
     virtual TSTRING AsStringHex() const;
@@ -247,7 +247,7 @@ public:
     virtual ~cCRC32Signature();
 
     virtual void Init();
-    virtual void Update(const byte* const pbData, int cbDataLen);
+    virtual void Update(const ibyte* const pbData, int cbDataLen);
     virtual void Finit();
 
     virtual TSTRING AsString() const;
@@ -276,7 +276,7 @@ public:
     virtual ~cMD5Signature();
 
     virtual void    Init();
-    virtual void    Update(const byte* const pbData, int cbDataLen);
+    virtual void    Update(const ibyte* const pbData, int cbDataLen);
     virtual void    Finit();
     virtual TSTRING AsString() const;
     virtual TSTRING AsStringHex() const;
@@ -313,7 +313,7 @@ public:
     virtual ~cSHASignature();
 
     virtual void    Init();
-    virtual void    Update(const byte* const pbData, int cbDataLen);
+    virtual void    Update(const ibyte* const pbData, int cbDataLen);
     virtual void    Finit();
     virtual TSTRING AsString() const;
     virtual TSTRING AsStringHex() const;
@@ -355,7 +355,7 @@ public:
     virtual ~cHAVALSignature();
 
     virtual void    Init();
-    virtual void    Update(const byte* const pbData, int cbDataLen);
+    virtual void    Update(const ibyte* const pbData, int cbDataLen);
     virtual void    Finit();
     virtual TSTRING AsString() const;
     virtual TSTRING AsStringHex() const;
diff --git a/src/fs/Makefile.in b/src/fs/Makefile.in
index 21c6d25..b1b715c 100644
--- a/src/fs/Makefile.in
+++ b/src/fs/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -131,7 +131,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -198,8 +198,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -214,10 +212,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -227,6 +225,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -303,6 +302,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -353,8 +353,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -458,8 +458,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/siggen/Makefile.in b/src/siggen/Makefile.in
index 8db2435..9a97159 100644
--- a/src/siggen/Makefile.in
+++ b/src/siggen/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -124,7 +124,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -190,8 +190,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -206,10 +204,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -219,6 +217,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -295,6 +294,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -340,8 +340,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -483,8 +483,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/tripwire/Makefile.in b/src/tripwire/Makefile.in
index df8e69c..7ccfff9 100644
--- a/src/tripwire/Makefile.in
+++ b/src/tripwire/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -128,7 +128,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -194,8 +194,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -210,10 +208,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -223,6 +221,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -299,6 +298,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -348,8 +348,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -491,8 +491,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/tripwire/mailmessage.h b/src/tripwire/mailmessage.h
index 871dcd0..5fe8f4b 100644
--- a/src/tripwire/mailmessage.h
+++ b/src/tripwire/mailmessage.h
@@ -128,7 +128,7 @@ public:
         _EOL_LEN               = 2
     };
 
-    static const std::string::value_type* ConvertBase64(std::string&, const byte*, size_t);
+    static const std::string::value_type* ConvertBase64(std::string&, const ibyte*, size_t);
 
     static bool        HasNonAsciiChars(const std::string& s);
     static std::string CreateEncodedText(const std::string& text);
diff --git a/src/tw/Makefile.in b/src/tw/Makefile.in
index 8749f14..c61f523 100644
--- a/src/tw/Makefile.in
+++ b/src/tw/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -134,7 +134,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -201,8 +201,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -217,10 +215,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -230,6 +228,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -306,6 +305,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -359,8 +359,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -464,8 +464,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/tw/twutil.cpp b/src/tw/twutil.cpp
index 4bee800..c6fe2fc 100644
--- a/src/tw/twutil.cpp
+++ b/src/tw/twutil.cpp
@@ -661,7 +661,7 @@ void cTWUtil::ReadConfigText(const TCHAR* filename, TSTRING& configText, cArchiv
         throw eSerializerInputStreamFmt(_T(""), filename, eSerializer::TY_FILE);
 
     // check 8 byte header
-    if (nstring.mString.compare(0, 8 * sizeof(byte), CONFIG_FILE_MAGIC_8BYTE) != 0)
+    if (nstring.mString.compare(0, 8 * sizeof(ibyte), CONFIG_FILE_MAGIC_8BYTE) != 0)
         ThrowAndAssert(eSerializerInputStreamFmt(_T(""), filename, eSerializer::TY_FILE));
 
     // remove 8 byte header
@@ -716,7 +716,7 @@ void cTWUtil::ReadPolicyText(const TCHAR* filename, std::string& polText, const
     ReadObject(filename, NULL, nstring, cPolicyFile::GetFileHeaderID(), pPublicKey, bEncrypted);
 
     // check 8 byte header
-    if (nstring.mString.compare(0, 8 * sizeof(byte), POLICY_FILE_MAGIC_8BYTE) != 0)
+    if (nstring.mString.compare(0, 8 * sizeof(ibyte), POLICY_FILE_MAGIC_8BYTE) != 0)
         ThrowAndAssert(eSerializerInputStreamFmt(_T(""), filename, eSerializer::TY_FILE));
 
     // remove 8 byte header
diff --git a/src/twadmin/Makefile.in b/src/twadmin/Makefile.in
index b3a8e68..2d7ef43 100644
--- a/src/twadmin/Makefile.in
+++ b/src/twadmin/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -124,7 +124,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -190,8 +190,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -206,10 +204,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -219,6 +217,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -295,6 +294,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -341,8 +341,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -484,8 +484,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/twcrypto/Makefile.in b/src/twcrypto/Makefile.in
index 9afae2e..ba4ecfe 100644
--- a/src/twcrypto/Makefile.in
+++ b/src/twcrypto/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -129,7 +129,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -196,8 +196,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -212,10 +210,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -225,6 +223,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -301,6 +300,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -347,8 +347,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -452,8 +452,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/twcrypto/bytequeue.cpp b/src/twcrypto/bytequeue.cpp
index 5896e8f..42a74ad 100644
--- a/src/twcrypto/bytequeue.cpp
+++ b/src/twcrypto/bytequeue.cpp
@@ -57,24 +57,24 @@ public:
         return (head == MaxSize());
     }
 
-    unsigned int Put(byte inByte);
-    unsigned int Put(const byte* inString, unsigned int length);
+    unsigned int Put(ibyte inByte);
+    unsigned int Put(const ibyte* inString, unsigned int length);
 
-    unsigned int Get(byte& outByte);
-    unsigned int Get(byte* outString, unsigned int getMax);
+    unsigned int Get(ibyte& outByte);
+    unsigned int Get(ibyte* outString, unsigned int getMax);
 
-    unsigned int Peek(byte& outByte) const;
+    unsigned int Peek(ibyte& outByte) const;
 
     void CopyTo(BufferedTransformation& target) const
     {
         target.Put(buf + head, tail - head);
     }
-    void CopyTo(byte* target) const
+    void CopyTo(ibyte* target) const
     {
         memcpy(target, buf + head, tail - head);
     }
 
-    byte operator[](unsigned int i) const
+    ibyte operator[](unsigned int i) const
     {
         return buf[i - head];
     }
@@ -98,7 +98,7 @@ cByteQueueNode::cByteQueueNode(unsigned int maxSize) : buf(maxSize)
     next        = 0;
 }
 
-unsigned int cByteQueueNode::Put(byte inByte)
+unsigned int cByteQueueNode::Put(ibyte inByte)
 {
     if (MaxSize() == tail)
         return 0;
@@ -107,7 +107,7 @@ unsigned int cByteQueueNode::Put(byte inByte)
     return 1;
 }
 
-unsigned int cByteQueueNode::Put(const byte* inString, unsigned int length)
+unsigned int cByteQueueNode::Put(const ibyte* inString, unsigned int length)
 {
     unsigned int l = STDMIN(length, MaxSize() - tail);
     memcpy(buf + tail, inString, l);
@@ -115,7 +115,7 @@ unsigned int cByteQueueNode::Put(const byte* inString, unsigned int length)
     return l;
 }
 
-unsigned int cByteQueueNode::Get(byte& outByte)
+unsigned int cByteQueueNode::Get(ibyte& outByte)
 {
     if (tail == head)
         return 0;
@@ -124,7 +124,7 @@ unsigned int cByteQueueNode::Get(byte& outByte)
     return 1;
 }
 
-unsigned int cByteQueueNode::Get(byte* outString, unsigned int getMax)
+unsigned int cByteQueueNode::Get(ibyte* outString, unsigned int getMax)
 {
     unsigned int l = STDMIN(getMax, tail - head);
     memcpy(outString, buf + head, l);
@@ -132,7 +132,7 @@ unsigned int cByteQueueNode::Get(byte* outString, unsigned int getMax)
     return l;
 }
 
-unsigned int cByteQueueNode::Peek(byte& outByte) const
+unsigned int cByteQueueNode::Peek(ibyte& outByte) const
 {
     if (tail == head)
         return 0;
@@ -198,7 +198,7 @@ void cByteQueue::CopyTo(BufferedTransformation& target) const
         current->CopyTo(target);
 }
 
-void cByteQueue::CopyTo(byte* target) const
+void cByteQueue::CopyTo(ibyte* target) const
 {
     for (cByteQueueNode* current = head; current; current = current->next)
     {
@@ -220,7 +220,7 @@ unsigned long cByteQueue::CurrentSize() const
     */
 }
 
-void cByteQueue::Put(byte inByte)
+void cByteQueue::Put(ibyte inByte)
 {
     if (!tail->Put(inByte))
     {
@@ -232,7 +232,7 @@ void cByteQueue::Put(byte inByte)
     mCurrentSize++;
 }
 
-void cByteQueue::Put(const byte* inString, unsigned int length)
+void cByteQueue::Put(const ibyte* inString, unsigned int length)
 {
     unsigned int l;
 
@@ -248,7 +248,7 @@ void cByteQueue::Put(const byte* inString, unsigned int length)
     }
 }
 
-unsigned int cByteQueue::Get(byte& outByte)
+unsigned int cByteQueue::Get(ibyte& outByte)
 {
     int l = head->Get(outByte);
     if (head->UsedUp())
@@ -265,7 +265,7 @@ unsigned int cByteQueue::Get(byte& outByte)
     return l;
 }
 
-unsigned int cByteQueue::Get(byte* outString, unsigned int getMax)
+unsigned int cByteQueue::Get(ibyte* outString, unsigned int getMax)
 {
     unsigned int    getMaxSave = getMax;
     cByteQueueNode* current    = head;
@@ -300,7 +300,7 @@ unsigned int cByteQueue::Get(byte* outString, unsigned int getMax)
     return (rtn);
 }
 
-unsigned int cByteQueue::Peek(byte& outByte) const
+unsigned int cByteQueue::Peek(ibyte& outByte) const
 {
     return head->Peek(outByte);
 }
@@ -326,7 +326,7 @@ bool cByteQueue::operator==(const cByteQueue& rhs) const
     return true;
 }
 
-byte cByteQueue::operator[](unsigned long i) const
+ibyte cByteQueue::operator[](unsigned long i) const
 {
     for (cByteQueueNode* current = head; current; current = current->next)
     {
diff --git a/src/twcrypto/bytequeue.h b/src/twcrypto/bytequeue.h
index f5aada0..592221e 100644
--- a/src/twcrypto/bytequeue.h
+++ b/src/twcrypto/bytequeue.h
@@ -56,21 +56,21 @@ public:
         return CurrentSize();
     }
 
-    void Put(byte inByte);
-    void Put(const byte* inString, unsigned int length);
+    void Put(ibyte inByte);
+    void Put(const ibyte* inString, unsigned int length);
 
     // both functions returns the number of bytes actually retrived
-    unsigned int Get(byte& outByte);
-    unsigned int Get(byte* outString, unsigned int getMax);
+    unsigned int Get(ibyte& outByte);
+    unsigned int Get(ibyte* outString, unsigned int getMax);
 
-    unsigned int Peek(byte& outByte) const;
+    unsigned int Peek(ibyte& outByte) const;
 
     void CopyTo(BufferedTransformation& target) const;
-    void CopyTo(byte* target) const;
+    void CopyTo(ibyte* target) const;
 
     cByteQueue& operator=(const cByteQueue& rhs);
     bool        operator==(const cByteQueue& rhs) const;
-    byte        operator[](unsigned long i) const;
+    ibyte        operator[](unsigned long i) const;
 
 private:
     void CopyFrom(const cByteQueue& copy);
diff --git a/src/twcrypto/crypto.cpp b/src/twcrypto/crypto.cpp
index 6c1c80a..11c916e 100644
--- a/src/twcrypto/crypto.cpp
+++ b/src/twcrypto/crypto.cpp
@@ -135,7 +135,7 @@ void cIDEA::SetKey(iCipher::EncryptionDir dir, const cHashedKey128& key)
     ASSERT(mpData);
 
     delete mpData->mpIDEA;
-    mpData->mpIDEA = new IDEA((byte*)key.GetKey(), dir == iCipher::ENCRYPT ? ENCRYPTION : DECRYPTION);
+    mpData->mpIDEA = new IDEA((ibyte*)key.GetKey(), dir == iCipher::ENCRYPT ? ENCRYPTION : DECRYPTION);
 }
 
 // return the size of data block this crypter works on
@@ -159,7 +159,7 @@ void cIDEA::ProcessBlock(const void* indata, void* outdata)
         ThrowAndAssert(eInternal(_T("Key not set in symmetric encryption.")));
     }
 
-    mpData->mpIDEA->ProcessBlock((byte*)indata, (byte*)outdata);
+    mpData->mpIDEA->ProcessBlock((ibyte*)indata, (ibyte*)outdata);
 }
 
 #endif // _IDEA_ENCRYPTION
@@ -203,14 +203,14 @@ void cTripleDES::SetKey(iCipher::EncryptionDir dir, const cHashedKey192& key)
         delete mpData->mpEncryptor;
         delete mpData->mpDecryptor;
         mpData->mpDecryptor = 0;
-        mpData->mpEncryptor = new TripleDES_Encryption((byte*)key.GetKey());
+        mpData->mpEncryptor = new TripleDES_Encryption((ibyte*)key.GetKey());
     }
     else
     {
         delete mpData->mpEncryptor;
         delete mpData->mpDecryptor;
         mpData->mpEncryptor = 0;
-        mpData->mpDecryptor = new TripleDES_Decryption((byte*)key.GetKey());
+        mpData->mpDecryptor = new TripleDES_Decryption((ibyte*)key.GetKey());
     }
 }
 
@@ -240,9 +240,9 @@ void cTripleDES::ProcessBlock(const void* indata, void* outdata)
     }
 
     if (mpData->mpEncryptor)
-        mpData->mpEncryptor->ProcessBlock((byte*)indata, (byte*)outdata);
+        mpData->mpEncryptor->ProcessBlock((ibyte*)indata, (ibyte*)outdata);
     else
-        mpData->mpDecryptor->ProcessBlock((byte*)indata, (byte*)outdata);
+        mpData->mpDecryptor->ProcessBlock((ibyte*)indata, (ibyte*)outdata);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -274,7 +274,7 @@ cRSAPrivateKey::cRSAPrivateKey(void* pDataStream)
     int32 i32;
     int16 i16;
 
-    byte* pIn = (byte*)pDataStream;
+    ibyte* pIn = (ibyte*)pDataStream;
 
     memcpy(&i16, pIn, sizeof(i16));
     mpData->mKeyLength = tw_ntohs(i16);
@@ -343,7 +343,7 @@ void cRSAPrivateKey::Write(void* pDataStream) const
     ASSERT(mpData->mpKey->GetTrapdoorFunction().GetParameterDQ().IsPositive());
     ASSERT(mpData->mpKey->GetTrapdoorFunction().GetParameterU().IsPositive());
 
-    byte* pOut = (byte*)pDataStream;
+    ibyte* pOut = (ibyte*)pDataStream;
     int16 i16;
     int32 i32;
 
@@ -407,7 +407,7 @@ cRSAPublicKey::cRSAPublicKey(void* pDataStream)
     int16   i16;
     int32   i32;
 
-    byte* pIn = (byte*)pDataStream;
+    ibyte* pIn = (ibyte*)pDataStream;
 
     memcpy(&i16, pIn, sizeof(i16));
     mpData->mKeyLength = tw_ntohs(i16);
@@ -465,7 +465,7 @@ void cRSAPublicKey::Write(void* pDataStream) const
 
     int16 i16;
     int32 i32;
-    byte* pOut = (byte*)pDataStream;
+    ibyte* pOut = (ibyte*)pDataStream;
 
     i16 = tw_htons(mpData->mKeyLength);
     memcpy(pOut, &i16, sizeof(i16));
@@ -551,8 +551,8 @@ void cRSA::Init(KeySize keysize)
                            (keysize == KEY512) ? 512 : (keysize == KEY1024) ? 1024 : (keysize == KEY2048) ? 2048 : 256;
 
     // Create a random seed and a key
-    byte seed[MD5::DATASIZE];
-    byte deskey[TripleDES_Encryption::KEYLENGTH];
+    ibyte seed[MD5::DATASIZE];
+    ibyte deskey[TripleDES_Encryption::KEYLENGTH];
     RandomizeBytes((int8*)seed, MD5::DATASIZE);
     RandomizeBytes((int8*)deskey, TripleDES_Encryption::KEYLENGTH);
 
@@ -648,14 +648,14 @@ void cRSA::ProcessBlock(const void* indata, void* outdata)
         ASSERT(mpData->mpPublicKey->mpData->mpKey->MaxPlainTextLength() == GetBlockSizePlain());
         ASSERT(mpData->mpPublicKey->mpData->mpKey->CipherTextLength() == GetBlockSizeCipher());
         mpData->mpPublicKey->mpData->mpKey->Encrypt(
-            *mpData->mpRNG, (const byte*)indata, GetBlockSizePlain(), (byte*)outdata);
+            *mpData->mpRNG, (const ibyte*)indata, GetBlockSizePlain(), (ibyte*)outdata);
         break;
     }
     case cRSA_i::DECRYPT:
     {
         ASSERT(mpData->mpPrivateKey);
         ASSERT(mpData->mpPrivateKey->mpData->mpKey->CipherTextLength() == GetBlockSizeCipher());
-        l = mpData->mpPrivateKey->mpData->mpKey->Decrypt((const byte*)indata, (byte*)outdata);
+        l = mpData->mpPrivateKey->mpData->mpKey->Decrypt((const ibyte*)indata, (ibyte*)outdata);
         if (l != GetBlockSizePlain())
             throw eArchiveCrypto();
         break;
@@ -666,14 +666,14 @@ void cRSA::ProcessBlock(const void* indata, void* outdata)
         ASSERT(mpData->mpPrivateKey->mpData->mpKey->MaxMessageLength() == GetBlockSizePlain());
         ASSERT(mpData->mpPrivateKey->mpData->mpKey->SignatureLength() == GetBlockSizeCipher());
         mpData->mpPrivateKey->mpData->mpKey->Sign(
-            *mpData->mpRNG, (const byte*)indata, GetBlockSizePlain(), (byte*)outdata);
+            *mpData->mpRNG, (const ibyte*)indata, GetBlockSizePlain(), (ibyte*)outdata);
         break;
     }
     case cRSA_i::VERIFY:
     {
         ASSERT(mpData->mpPublicKey);
         ASSERT(mpData->mpPublicKey->mpData->mpKey->SignatureLength() == GetBlockSizeCipher());
-        l = mpData->mpPublicKey->mpData->mpKey->Recover((const byte*)indata, (byte*)outdata);
+        l = mpData->mpPublicKey->mpData->mpKey->Recover((const ibyte*)indata, (ibyte*)outdata);
         if (l != GetBlockSizePlain())
             throw eArchiveCrypto();
         break;
@@ -740,7 +740,7 @@ cElGamalSigPrivateKey::cElGamalSigPrivateKey(void* pDataStream)
     int16  i16;
     uint32 magicNum;
 
-    byte* pIn = (byte*)pDataStream;
+    ibyte* pIn = (ibyte*)pDataStream;
 
     memcpy(&i16, pIn, sizeof(i16));
     mpData->mKeyLength = tw_ntohs(i16);
@@ -802,7 +802,7 @@ void cElGamalSigPrivateKey::Write(void* pDataStream) const
     ASSERT(mpData->mpKey->GetParameterY().IsPositive());
     ASSERT(mpData->mpKey->GetParameterX().IsPositive());
 
-    byte* pOut = (byte*)pDataStream;
+    ibyte* pOut = (ibyte*)pDataStream;
     int16 i16;
     int32 i32;
 
@@ -857,7 +857,7 @@ cElGamalSigPublicKey::cElGamalSigPublicKey(void* pDataStream)
     int32   i32;
     uint32  magicNum;
 
-    byte* pIn = (byte*)pDataStream;
+    ibyte* pIn = (ibyte*)pDataStream;
 
     memcpy(&i16, pIn, sizeof(i16));
     mpData->mKeyLength = tw_ntohs(i16);
@@ -927,7 +927,7 @@ void cElGamalSigPublicKey::Write(void* pDataStream) const
     ASSERT(mpData->mpKey->GetParameterG().IsPositive());
     ASSERT(mpData->mpKey->GetParameterY().IsPositive());
 
-    byte* pOut = (byte*)pDataStream;
+    ibyte* pOut = (ibyte*)pDataStream;
     int16 i16;
     int32 i32;
 
@@ -1038,8 +1038,8 @@ void cElGamalSig::Init(KeySize keysize)
                            (keysize == KEY512) ? 512 : (keysize == KEY1024) ? 1024 : (keysize == KEY2048) ? 2048 : 256;
 
     // Create a random seed and a key
-    byte seed[SHA::DATASIZE];
-    byte deskey[TripleDES_Encryption::KEYLENGTH];
+    ibyte seed[SHA::DATASIZE];
+    ibyte deskey[TripleDES_Encryption::KEYLENGTH];
     RandomizeBytes((int8*)seed, SHA::DATASIZE);
     RandomizeBytes((int8*)deskey, TripleDES_Encryption::KEYLENGTH);
 
@@ -1109,11 +1109,11 @@ void cElGamalSig::ProcessBlock(const void* indata, void* outdata)
 
         memmove(outdata, indata, PLAIN_BLOCK_SIZE);
 
-        mpData->mSHA.CalculateDigest((byte*)shaSig, (byte*)outdata, PLAIN_BLOCK_SIZE);
+        mpData->mSHA.CalculateDigest((ibyte*)shaSig, (ibyte*)outdata, PLAIN_BLOCK_SIZE);
 
         RandomizeBytes((int8*)outdata + PLAIN_BLOCK_SIZE, GetBlockSizeCipher() - PLAIN_BLOCK_SIZE);
         mpData->mpPrivateKey->mpData->mpKey->Sign(
-            *mpData->mpRNG, (const byte*)shaSig, SHA::DIGESTSIZE, (byte*)outdata + PLAIN_BLOCK_SIZE);
+            *mpData->mpRNG, (const ibyte*)shaSig, SHA::DIGESTSIZE, (ibyte*)outdata + PLAIN_BLOCK_SIZE);
 
         /*
                 Integer m((const byte*)indata, PLAIN_BLOCK_SIZE);
@@ -1136,7 +1136,7 @@ void cElGamalSig::ProcessBlock(const void* indata, void* outdata)
         ASSERT(mpData->mpPublicKey != 0);
         ASSERT((int)mpData->mpPublicKey->mpData->mpKey->SignatureLength() + PLAIN_BLOCK_SIZE <= GetBlockSizeCipher());
 
-        mpData->mSHA.CalculateDigest((byte*)shaSig, (byte*)indata, PLAIN_BLOCK_SIZE);
+        mpData->mSHA.CalculateDigest((ibyte*)shaSig, (ibyte*)indata, PLAIN_BLOCK_SIZE);
 
         /*
                 const byte* signature = (const byte *)indata + PLAIN_BLOCK_SIZE;
@@ -1151,7 +1151,7 @@ void cElGamalSig::ProcessBlock(const void* indata, void* outdata)
             */
 
         if (mpData->mpPublicKey->mpData->mpKey->Verify(
-                (const byte*)shaSig, SHA::DIGESTSIZE, (const byte*)indata + PLAIN_BLOCK_SIZE) == false)
+                (const ibyte*)shaSig, SHA::DIGESTSIZE, (const ibyte*)indata + PLAIN_BLOCK_SIZE) == false)
             throw eArchiveCrypto();
         memmove(outdata, indata, PLAIN_BLOCK_SIZE);
         break;
@@ -1194,7 +1194,7 @@ cHashedKey128::cHashedKey128(const TSTRING& data)
     SHA sha;
 
     ASSERT(SHA::DIGESTSIZE >= KEYLEN);
-    sha.CalculateDigest((byte*)mKey, (byte*)data.data(), data.length() * sizeof(TCHAR));
+    sha.CalculateDigest((ibyte*)mKey, (ibyte*)data.data(), data.length() * sizeof(TCHAR));
 }
 
 cHashedKey128::cHashedKey128(void* pData, int dataLen)
@@ -1203,7 +1203,7 @@ cHashedKey128::cHashedKey128(void* pData, int dataLen)
 
     ASSERT(SHA::DIGESTSIZE >= KEYLEN);
     ASSERT(SHA::DIGESTSIZE <= BUFSIZE);
-    sha.CalculateDigest((byte*)mKey, (byte*)pData, dataLen);
+    sha.CalculateDigest((ibyte*)mKey, (ibyte*)pData, dataLen);
 }
 
 cHashedKey128::~cHashedKey128()
@@ -1221,8 +1221,8 @@ cHashedKey192::cHashedKey192(const TSTRING& data)
     ASSERT(SHA::DIGESTSIZE == 20);
     ASSERT(40 >= KEYLEN);
 
-    byte localKey[40];
-    sha.CalculateDigest(localKey, (byte*)data.data(), data.length() * sizeof(TCHAR));
+    ibyte localKey[40];
+    sha.CalculateDigest(localKey, (ibyte*)data.data(), data.length() * sizeof(TCHAR));
     sha.CalculateDigest(localKey + 20, localKey, 20);
     memcpy(mKey, localKey, KEYLEN);
 }
@@ -1234,8 +1234,8 @@ cHashedKey192::cHashedKey192(void* pData, int dataLen)
     ASSERT(SHA::DIGESTSIZE == 20);
     ASSERT(40 >= KEYLEN);
 
-    byte localKey[40];
-    sha.CalculateDigest(localKey, (byte*)pData, dataLen);
+    ibyte localKey[40];
+    sha.CalculateDigest(localKey, (ibyte*)pData, dataLen);
     sha.CalculateDigest(localKey + 20, localKey, 20);
     memcpy(mKey, localKey, KEYLEN);
 }
@@ -1303,6 +1303,6 @@ void RandomizeBytes(int8* destbuf, int len)
 
     int i;
     for (i = 0; i < len; ++i)
-        destbuf[i] = (byte)((rand() * 256 / RAND_MAX) ^ 0xdc); // 0xdc came from random.org
+        destbuf[i] = (ibyte)((rand() * 256 / RAND_MAX) ^ 0xdc); // 0xdc came from random.org
 #endif
 }
diff --git a/src/twcrypto/cryptoarchive.cpp b/src/twcrypto/cryptoarchive.cpp
index 18a18f9..f562396 100644
--- a/src/twcrypto/cryptoarchive.cpp
+++ b/src/twcrypto/cryptoarchive.cpp
@@ -66,10 +66,10 @@ public:
     cCryptoSink(cArchive* pDestArchive, iCipher* pCipher);
     ~cCryptoSink();
 
-    virtual void Put(const byte* inString, unsigned int length);
+    virtual void Put(const ibyte* inString, unsigned int length);
     virtual void InputFinished();
 
-    virtual void Put(byte inByte)
+    virtual void Put(ibyte inByte)
     {
         Put(&inByte, 1);
     }
@@ -171,7 +171,7 @@ int cCryptoArchive::Write(const void* pSrc, int count)
         throw eArchiveInvalidOp();
     }
 
-    mpDeflator->Put((byte*)pSrc, count);
+    mpDeflator->Put((ibyte*)pSrc, count);
 
     return count;
 }
@@ -210,13 +210,13 @@ int cCryptoArchive::Read(void* pDest, int count)
             if ((int)mpInflatedBytes->CurrentSize() < count) // RAD: Cast to int
             {
                 len = mpInflatedBytes->CurrentSize();
-                mpInflatedBytes->Get((byte*)pDest, len);
+                mpInflatedBytes->Get((ibyte*)pDest, len);
                 return len;
             }
         }
     }
 
-    len = mpInflatedBytes->Get((byte*)pDest, count);
+    len = mpInflatedBytes->Get((ibyte*)pDest, count);
     ASSERT(len == count);
 
     return len;
@@ -278,7 +278,7 @@ cCryptoSink::~cCryptoSink()
     delete [] mpBuffer;
 }
 
-void cCryptoSink::Put(const byte* inString, unsigned int length)
+void cCryptoSink::Put(const ibyte* inString, unsigned int length)
 {
     if (mpBuffer == 0)
     {
@@ -400,7 +400,7 @@ unsigned int cCryptoSource::Pump(unsigned int size)
         if (bytesToCopy > nSize - i)
             bytesToCopy = nSize - i;
 
-        outQueue->Put((byte*)(mpBuffer + mBufferUsed), bytesToCopy);
+        outQueue->Put((ibyte*)(mpBuffer + mBufferUsed), bytesToCopy);
 
         mBufferUsed += bytesToCopy;
         i += bytesToCopy;
diff --git a/src/twparser/Makefile.in b/src/twparser/Makefile.in
index 102f0d9..92c9d9a 100644
--- a/src/twparser/Makefile.in
+++ b/src/twparser/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -130,7 +130,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -197,8 +197,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -213,10 +211,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -226,6 +224,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -302,6 +301,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -350,8 +350,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -455,8 +455,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/twprint/Makefile.in b/src/twprint/Makefile.in
index afaa7af..f77a587 100644
--- a/src/twprint/Makefile.in
+++ b/src/twprint/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -124,7 +124,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -190,8 +190,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -206,10 +204,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -219,6 +217,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -295,6 +294,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -341,8 +341,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -484,8 +484,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/twtest/Makefile.in b/src/twtest/Makefile.in
index 409d2bd..d2ca3d1 100644
--- a/src/twtest/Makefile.in
+++ b/src/twtest/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -152,7 +152,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -230,8 +230,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -246,10 +244,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -259,6 +257,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -335,6 +334,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -441,8 +441,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -584,8 +584,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/src/twtest/platform_t.cpp b/src/twtest/platform_t.cpp
index f3dfbef..d3ccf09 100644
--- a/src/twtest/platform_t.cpp
+++ b/src/twtest/platform_t.cpp
@@ -68,7 +68,7 @@ public:
     AlignMe();
 
 private:
-    byte a[sizeof(int64) + ALIGN_SIZE]; // we want to be able to access a int64 at address [ALIGN_SIZE]
+    ibyte a[sizeof(int64) + ALIGN_SIZE]; // we want to be able to access a int64 at address [ALIGN_SIZE]
 };
 
 /////////////////////////////////////////////////////////
@@ -152,7 +152,7 @@ void TestAlignment()
     // such accesses: it may have handled the
     // hardware interrupt that might have occured.
     // - - - - - - - - - - - - - - - - - - - - - -
-    byte a[sizeof(int32) + sizeof(byte)];
+    ibyte a[sizeof(int32) + sizeof(ibyte)];
 
     // this should be fine
     a[0] = 0xAB;
@@ -177,7 +177,7 @@ void TestAlignment()
     // if it works, then our BYTE_ALIGN value is large enough
     // - - - - - - - - - - - - - - - - - - - - - -
 
-    byte b[2 * sizeof(BYTE_ALIGN)];
+    ibyte b[2 * sizeof(BYTE_ALIGN)];
 
     // this should be fine
     b[0] = 0xAB;
diff --git a/src/twtest/serializerimpl_t.cpp b/src/twtest/serializerimpl_t.cpp
index f6deb84..43c7860 100644
--- a/src/twtest/serializerimpl_t.cpp
+++ b/src/twtest/serializerimpl_t.cpp
@@ -54,7 +54,7 @@ public:
 
 private:
     int     mNumber;
-    byte    mData[20];
+    ibyte    mData[20];
     TSTRING mString;
 };
 
diff --git a/src/twtest/signature_t.cpp b/src/twtest/signature_t.cpp
index f047cbf..04193ad 100644
--- a/src/twtest/signature_t.cpp
+++ b/src/twtest/signature_t.cpp
@@ -76,10 +76,10 @@ void TestSignatureBasic()
     cCRC32Signature crcSig;
     cDebug          d("TestSignature1");
 
-    byte abData[64];
+    ibyte abData[64];
     int  i;
     for (i = 0; i < 64; i++)
-        abData[i] = static_cast<byte>(rand());
+        abData[i] = static_cast<ibyte>(rand());
 
     crcSig.Init();
     crcSig.Update(&abData[0], 32);
@@ -111,7 +111,7 @@ void TestChecksum()
     // test begins here
 
     // general signature & archive variables
-    byte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
+    ibyte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
     const int cbToRead = iSignature::SUGGESTED_BLOCK_SIZE;
     int       cbRead;
 
@@ -165,7 +165,7 @@ void TestCRC32()
     cDebug       d("TestCRC32");
 
     // general signature & archive variables
-    byte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
+    ibyte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
     const int cbToRead = iSignature::SUGGESTED_BLOCK_SIZE;
     int       cbRead;
 
@@ -219,7 +219,7 @@ void TestMD5()
     cDebug       d("TestMD5");
 
     // general signature & archive variables
-    byte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
+    ibyte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
     const int cbToRead = iSignature::SUGGESTED_BLOCK_SIZE;
     int       cbRead;
 
@@ -273,7 +273,7 @@ void TestSHA1()
     cDebug       d("TestSHA1");
 
     // general signature & archive variables
-    byte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
+    ibyte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
     const int cbToRead = iSignature::SUGGESTED_BLOCK_SIZE;
     int       cbRead;
 
@@ -327,7 +327,7 @@ void TestHAVAL()
     cDebug       d("TestHAVAL");
 
     // general signature & archive variables
-    byte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
+    ibyte      abBuf[iSignature::SUGGESTED_BLOCK_SIZE];
     const int cbToRead = iSignature::SUGGESTED_BLOCK_SIZE;
     int       cbRead;
 
@@ -418,7 +418,7 @@ void assertMD5(const std::string& source, const std::string& expectedHex)
     cMD5Signature md5Sig;
 
     md5Sig.Init();
-    md5Sig.Update((const byte*)source.c_str(), source.length());
+    md5Sig.Update((const ibyte*)source.c_str(), source.length());
     md5Sig.Finit();
 
     TEST(md5Sig.AsStringHex() == expectedHex);
@@ -430,7 +430,7 @@ void assertSHA1(const std::string& source, const std::string& expectedHex)
     cSHASignature shaSig;
 
     shaSig.Init();
-    shaSig.Update((const byte*)source.c_str(), source.length());
+    shaSig.Update((const ibyte*)source.c_str(), source.length());
     shaSig.Finit();
 
     TEST(shaSig.AsStringHex() == expectedHex);
diff --git a/src/util/Makefile.in b/src/util/Makefile.in
index 96f23e3..26e9e86 100644
--- a/src/util/Makefile.in
+++ b/src/util/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -128,7 +128,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 AM_V_CXX = $(am__v_CXX_@AM_V@)
@@ -195,8 +195,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/mkinstalldirs
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
@@ -211,10 +209,10 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CORE_CRYPT_O = @CORE_CRYPT_O@
-CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
-CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -224,6 +222,7 @@ ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 GREP = @GREP@
 INSTALL = @INSTALL@
@@ -300,6 +299,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -345,8 +345,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -450,8 +450,10 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
-distdir: $(DISTFILES)
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
-- 
2.43.2

