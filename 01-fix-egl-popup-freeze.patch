diff --git a/src/implementations/cairo-dock-foreign-toplevel.c b/src/implementations/cairo-dock-foreign-toplevel.c
index f73f6368..9480a784 100644
--- a/src/implementations/cairo-dock-foreign-toplevel.c
+++ b/src/implementations/cairo-dock-foreign-toplevel.c
@@ -53,6 +53,11 @@ static void _show (GldiWindowActor *actor)
 	GdkSeat *seat = gdk_display_get_default_seat (dsp);
 	struct wl_seat* wl_seat = gdk_wayland_seat_get_wl_seat (seat);
 	zwlr_foreign_toplevel_handle_v1_activate (wactor->handle, wl_seat);
+	// note: we do a roundtrip here, since if the active window changes,
+	// the compositor might be closing our popups (i.e. subdocks) and
+	// we should get the popup_done() event as soon as possible to avoid
+	// race conditions with rendering
+	gldi_wayland_display_roundtrip ();
 }
 static void _close (GldiWindowActor *actor)
 {
diff --git a/src/implementations/cairo-dock-plasma-window-manager.c b/src/implementations/cairo-dock-plasma-window-manager.c
index 286f79a0..f58d0b47 100644
--- a/src/implementations/cairo-dock-plasma-window-manager.c
+++ b/src/implementations/cairo-dock-plasma-window-manager.c
@@ -58,6 +58,12 @@ static void _show (GldiWindowActor *actor)
 	org_kde_plasma_window_set_state (wactor->handle,
 		ORG_KDE_PLASMA_WINDOW_MANAGEMENT_STATE_ACTIVE,
 		ORG_KDE_PLASMA_WINDOW_MANAGEMENT_STATE_ACTIVE);
+	// note: we do a roundtrip here, since if the active window changes,
+	// the compositor might be closing our popups (i.e. subdocks) and
+	// we should get the popup_done() event as soon as possible to avoid
+	// race conditions with rendering
+	// (note: this actually does not happen on at least KWin 5.24)
+	gldi_wayland_display_roundtrip ();
 }
 static void _close (GldiWindowActor *actor)
 {
diff --git a/src/implementations/cairo-dock-wayland-manager.c b/src/implementations/cairo-dock-wayland-manager.c
index 1d35c361..4ba477b6 100644
--- a/src/implementations/cairo-dock-wayland-manager.c
+++ b/src/implementations/cairo-dock-wayland-manager.c
@@ -555,6 +555,10 @@ static void _adjust_aimed_point (const Icon* pIcon, int w, int h,
 
 static gboolean _is_wayland() { return TRUE; }
 
+void gldi_wayland_display_roundtrip (void) {
+	if (s_pDisplay) wl_display_roundtrip (s_pDisplay);
+}
+
 static void init (void)
 {
 	//\__________________ listen for Wayland events
diff --git a/src/implementations/cairo-dock-wayland-manager.h b/src/implementations/cairo-dock-wayland-manager.h
index a58411d4..910d4643 100644
--- a/src/implementations/cairo-dock-wayland-manager.h
+++ b/src/implementations/cairo-dock-wayland-manager.h
@@ -37,6 +37,8 @@ G_BEGIN_DECLS
 extern GldiManager myWaylandMgr;
 #endif
 
+#ifdef HAVE_WAYLAND
+
 typedef enum {
 	/// notification called when a new monitor was added, data : the GdkMonitor added
 	NOTIFICATION_WAYLAND_MONITOR_ADDED = NB_NOTIFICATIONS_OBJECT,
@@ -45,8 +47,6 @@ typedef enum {
 	NB_NOTIFICATIONS_WAYLAND_DESKTOP
 	} CairoWaylandDesktopNotifications;
 
-void gldi_register_wayland_manager (void);
-
 /// Get the screen edge this dock should be anchored to
 CairoDockPositionType gldi_wayland_get_edge_for_dock (const CairoDock *pDock);
 
@@ -56,5 +56,11 @@ GdkMonitor *gldi_dock_wayland_get_monitor (CairoDock *pDock);
 /// Get the list of monitors currently managed -- caller should not modify the GdkMonitor* pointers stored here
 GdkMonitor *const *gldi_wayland_get_monitors (int *iNumMonitors);
 
+void gldi_wayland_display_roundtrip (void);
+
+#endif // HAVE_WAYLAND
+
+void gldi_register_wayland_manager (void);
+
 G_END_DECLS
 #endif
diff --git a/src/implementations/cairo-dock-wayland-wm.c b/src/implementations/cairo-dock-wayland-wm.c
index f6044378..6846b304 100644
--- a/src/implementations/cairo-dock-wayland-wm.c
+++ b/src/implementations/cairo-dock-wayland-wm.c
@@ -156,6 +156,11 @@ void gldi_wayland_wm_closed (GldiWaylandWindowActor *wactor, gboolean notify)
 void gldi_wayland_wm_activated (GldiWaylandWindowActor *wactor, gboolean notify)
 {
 	s_pMaybeActiveWindow = (GldiWindowActor*)wactor;
+	// note: we do a roundtrip here, since if the active window changed,
+	// the compositor might be closing our popups (i.e. subdocks) and
+	// we should get the popup_done() event as soon as possible to avoid
+	// race conditions with rendering
+	gldi_wayland_display_roundtrip ();
 	if (notify) gldi_wayland_wm_done (wactor);
 }
 
@@ -341,7 +346,7 @@ void gldi_wayland_wm_done (GldiWaylandWindowActor *wactor)
 			if (_update_state (wactor, TRUE)) continue;
 			// update the needs-attention property
 			if (_update_attention(wactor, TRUE)) continue;
-				
+			
 			if (actor == s_pMaybeActiveWindow)
 			{
 				s_pActiveWindow = actor;
diff --git a/src/implementations/cairo-dock-wayland-wm.h b/src/implementations/cairo-dock-wayland-wm.h
index 4072ceef..da359184 100644
--- a/src/implementations/cairo-dock-wayland-wm.h
+++ b/src/implementations/cairo-dock-wayland-wm.h
@@ -25,6 +25,7 @@
 #include <wayland-client.h>
 #include <stdint.h>
 #include "cairo-dock-struct.h"
+#include "cairo-dock-wayland-manager.h"
 
 struct _GldiWaylandWindowActor {
 	GldiWindowActor actor;
