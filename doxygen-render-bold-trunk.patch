diff --git a/clang-tools-extra/clangd/Hover.cpp b/clang-tools-extra/clangd/Hover.cpp
index 64221d32db8c..022cf9068fdf 100644
--- a/clang-tools-extra/clangd/Hover.cpp
+++ b/clang-tools-extra/clangd/Hover.cpp
@@ -1629,9 +1629,10 @@ markup::Document HoverInfo::present() const {
 
 // If the backtick at `Offset` starts a probable quoted range, return the range
 // (including the quotes).
-std::optional<llvm::StringRef> getBacktickQuoteRange(llvm::StringRef Line,
-                                                     unsigned Offset) {
-  assert(Line[Offset] == '`');
+std::optional<llvm::StringRef>
+getBacktickQuoteRange(llvm::StringRef Line, unsigned Offset,
+                      llvm::StringRef Quote = "`") {
+  assert(Line.substr(Offset, Quote.size()) == Quote);
 
   // The open-quote is usually preceded by whitespace.
   llvm::StringRef Prefix = Line.substr(0, Offset);
@@ -1640,21 +1641,21 @@ std::optional<llvm::StringRef> getBacktickQuoteRange(llvm::StringRef Line,
     return std::nullopt;
 
   // The quoted string must be nonempty and usually has no leading/trailing ws.
-  auto Next = Line.find('`', Offset + 1);
+  auto Next = Line.find(Quote, Offset + Quote.size());
   if (Next == llvm::StringRef::npos)
     return std::nullopt;
-  llvm::StringRef Contents = Line.slice(Offset + 1, Next);
+  llvm::StringRef Contents = Line.slice(Offset + Quote.size(), Next);
   if (Contents.empty() || isWhitespace(Contents.front()) ||
       isWhitespace(Contents.back()))
     return std::nullopt;
 
   // The close-quote is usually followed by whitespace or punctuation.
-  llvm::StringRef Suffix = Line.substr(Next + 1);
+  llvm::StringRef Suffix = Line.substr(Next + Quote.size());
   constexpr llvm::StringLiteral AfterEndChars = " \t)=.,;:";
   if (!Suffix.empty() && !AfterEndChars.contains(Suffix.front()))
     return std::nullopt;
 
-  return Line.slice(Offset, Next + 1);
+  return Line.slice(Offset, Next + Quote.size());
 }
 
 void parseDocumentationLine(llvm::StringRef Line, markup::Paragraph &Out) {
@@ -1668,6 +1669,17 @@ void parseDocumentationLine(llvm::StringRef Line, markup::Paragraph &Out) {
         return parseDocumentationLine(Line.substr(I + Range->size()), Out);
       }
       break;
+    case '\\':
+      return parseDocumentationLine(Line.substr(I + 2), Out);
+    case '*':
+      if (Line[I + 1] == '*') {
+        if (auto Range = getBacktickQuoteRange(Line, I, "**")) {
+          Out.appendText(Line.substr(0, I));
+          Out.appendBoldText(Range->trim("**"));
+          return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+        }
+      }
+      break;
     }
   }
   Out.appendText(Line).appendSpace();
diff --git a/clang-tools-extra/clangd/support/Markup.cpp b/clang-tools-extra/clangd/support/Markup.cpp
index 4d17a2bf2b2b..14691790ee27 100644
--- a/clang-tools-extra/clangd/support/Markup.cpp
+++ b/clang-tools-extra/clangd/support/Markup.cpp
@@ -164,6 +164,10 @@ std::string renderText(llvm::StringRef Input, bool StartsLine) {
   return R;
 }
 
+std::string renderBoldText(llvm::StringRef Input, bool StartsLine) {
+  return "**" + renderText(Input, StartsLine) + "**";
+}
+
 /// Renders \p Input as an inline block of code in markdown. The returned value
 /// is surrounded by backticks and the inner contents are properly escaped.
 std::string renderInlineBlock(llvm::StringRef Input) {
@@ -354,6 +358,9 @@ void Paragraph::renderMarkdown(llvm::raw_ostream &OS) const {
     case Chunk::InlineCode:
       OS << renderInlineBlock(C.Contents);
       break;
+    case Chunk::BoldText:
+      OS << renderBoldText(C.Contents, !HasChunks);
+      break;
     }
     HasChunks = true;
     NeedsSpace = C.SpaceAfter;
@@ -449,6 +456,19 @@ Paragraph &Paragraph::appendCode(llvm::StringRef Code, bool Preserve) {
   return *this;
 }
 
+Paragraph &Paragraph::appendBoldText(llvm::StringRef Text) {
+  std::string Norm = canonicalizeSpaces(Text);
+  if (Norm.empty())
+    return *this;
+  Chunks.emplace_back();
+  Chunk &C = Chunks.back();
+  C.Contents = std::move(Norm);
+  C.Kind = Chunk::BoldText;
+  C.SpaceBefore = llvm::isSpace(Text.front());
+  C.SpaceAfter = llvm::isSpace(Text.back());
+  return *this;
+}
+
 std::unique_ptr<Block> BulletList::clone() const {
   return std::make_unique<BulletList>(*this);
 }
diff --git a/clang-tools-extra/clangd/support/Markup.h b/clang-tools-extra/clangd/support/Markup.h
index 3a869c49a2cb..1e522322b021 100644
--- a/clang-tools-extra/clangd/support/Markup.h
+++ b/clang-tools-extra/clangd/support/Markup.h
@@ -53,6 +53,9 @@ public:
   /// \p Preserve indicates the code span must be apparent even in plaintext.
   Paragraph &appendCode(llvm::StringRef Code, bool Preserve = false);
 
+  /// Append bold text to the end of the string.
+  Paragraph &appendBoldText(llvm::StringRef Text);
+
   /// Ensure there is space between the surrounding chunks.
   /// Has no effect at the beginning or end of a paragraph.
   Paragraph &appendSpace();
@@ -62,6 +65,7 @@ private:
     enum {
       PlainText,
       InlineCode,
+      BoldText,
     } Kind = PlainText;
     // Preserve chunk markers in plaintext.
     bool Preserve = false;
