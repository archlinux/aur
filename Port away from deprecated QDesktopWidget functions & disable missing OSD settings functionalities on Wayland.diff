diff --git a/src/configdialog/dialogs/NotificationsConfig.cpp b/src/configdialog/dialogs/NotificationsConfig.cpp
index 0c16fdcb1764566898e11f54937984123f2a68ac..1c3387206a15386db26a9ad39811dcfcb7d4bacb 100644
--- a/src/configdialog/dialogs/NotificationsConfig.cpp
+++ b/src/configdialog/dialogs/NotificationsConfig.cpp
@@ -51,7 +51,11 @@ NotificationsConfig::NotificationsConfig( Amarok2ConfigDialog* parent )
     #endif
 
     // Enable/disable the translucency option depending on availability of desktop compositing
-    kcfg_OsdUseTranslucency->setEnabled( KWindowSystem::compositingActive() );
+    // As opacity functionality is not available on Wayland at least with current implementation, don't enable option there
+    kcfg_OsdUseTranslucency->setEnabled( !KWindowSystem::isPlatformWayland() && KWindowSystem::compositingActive() );
+
+    // Also disable other functionalities not (yet?) available on Wayland
+    kcfg_OsdScreen->setEnabled( !KWindowSystem::isPlatformWayland() );
 
     connect( m_osdPreview, &OSDPreviewWidget::positionChanged, this, &NotificationsConfig::slotPositionChanged );
 
diff --git a/src/covermanager/CoverManager.cpp b/src/covermanager/CoverManager.cpp
index e67a89416a3c4c836a42904041b139ebce72f873..eb0d63f637a4fcce5374d4ab6ac2da6d83e87e88 100644
--- a/src/covermanager/CoverManager.cpp
+++ b/src/covermanager/CoverManager.cpp
@@ -39,11 +39,11 @@
 
 #include <QAction>
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QDialogButtonBox>
 #include <QMenu>    //showCoverMenu()
 #include <QProgressBar>
 #include <QPushButton>
+#include <QScreen>
 #include <QSplitter>
 #include <QStatusBar>
 #include <QStringList>
@@ -228,7 +228,7 @@ CoverManager::slotContinueConstruction() //SLOT
 
     connect( m_progress, &CompoundProgressBar::allDone, this, &CoverManager::progressAllDone );
 
-    QSize size = QApplication::desktop()->screenGeometry( this ).size() / 1.5;
+    QSize size = this->screen()->size() / 1.5;
     QSize sz = Amarok::config( "Cover Manager" ).readEntry( "Window Size", size );
     resize( sz.width(), sz.height() );
 
diff --git a/src/covermanager/CoverViewDialog.cpp b/src/covermanager/CoverViewDialog.cpp
index bb01e1f7fb19c03d02ef4e1b3f6ed1e5ce2510b8..d3a1b96f7ebfeee50a85873af7ed5bfdafec8f7a 100644
--- a/src/covermanager/CoverViewDialog.cpp
+++ b/src/covermanager/CoverViewDialog.cpp
@@ -25,7 +25,6 @@
 #include <KLocalizedString>
 #include <KWindowSystem>
 
-#include <QDesktopWidget>
 #include <QHBoxLayout>
 #include <KConfigGroup>
 
@@ -72,7 +71,7 @@ CoverViewDialog::zoomFactorChanged( qreal value )
 void
 CoverViewDialog::createViewer( const QImage &image, const QWidget *widget )
 {
-    int screenNumber = QApplication::desktop()->screenNumber( widget );
+    int screenNumber = QApplication::screens().indexOf( widget->screen() );
     PixmapViewer *pixmapViewer = new PixmapViewer( this, QPixmap::fromImage(image), screenNumber );
     QHBoxLayout *layout = new QHBoxLayout( this );
     layout->addWidget( pixmapViewer );
diff --git a/src/dialogs/OrganizeCollectionDialog.cpp b/src/dialogs/OrganizeCollectionDialog.cpp
index fb59c98224448de12a8b2317e765047c9e32f8ff..cfda1f109cb0aad06a7360774f8bf938a374a8bc 100644
--- a/src/dialogs/OrganizeCollectionDialog.cpp
+++ b/src/dialogs/OrganizeCollectionDialog.cpp
@@ -30,9 +30,9 @@
 #include "ui_OrganizeCollectionDialogBase.h"
 
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QDir>
 #include <QPushButton>
+#include <QScreen>
 #include <QTimer>
 
 #include <KColorScheme>
@@ -84,7 +84,7 @@ OrganizeCollectionWidget::OrganizeCollectionWidget( QWidget *parent )
 
     // show some non-editable tags before and after
     // but only if screen size is large enough (BR: 283361)
-    const QRect screenRect = QApplication::desktop()->screenGeometry();
+    const QRect screenRect = QApplication::primaryScreen()->geometry();
     if( screenRect.width() >= 1024 )
     {
         m_schemaLineLayout->insertWidget( 0,
diff --git a/src/widgets/Osd.cpp b/src/widgets/Osd.cpp
index dc1cf722e3c0217d3bac52d25abffeca2cee4a06..1eee135be479cdecb33c8e77b920ab8704917a47 100644
--- a/src/widgets/Osd.cpp
+++ b/src/widgets/Osd.cpp
@@ -45,6 +45,7 @@
 #include <QPainter>
 #include <QPixmap>
 #include <QRegExp>
+#include <QScreen>
 #include <QTimeLine>
 #include <QTimer>
 
@@ -86,10 +87,6 @@ OSDWidget::OSDWidget( QWidget *parent, const char *name )
     setObjectName( name );
     setFocusPolicy( Qt::NoFocus );
 
-    #ifdef Q_WS_X11
-    KWindowSystem::setType( winId(), NET::Notification );
-    #endif
-
     m_timer->setSingleShot( true );
     connect( m_timer, &QTimer::timeout, this, &OSDWidget::hide );
 
@@ -245,7 +242,7 @@ OSDWidget::determineMetrics( const int M )
     // determine a sensible maximum size, don't cover the whole desktop or cross the screen
     const QSize margin( ( M + MARGIN ) * 2, ( M + MARGIN ) * 2 ); //margins
     const QSize image = m_cover.isNull() ? QSize( 0, 0 ) : minImageSize;
-    const QSize max = QApplication::desktop()->screen( m_screen )->size() - margin;
+    const QSize max = QApplication::screens()[ screen() ]->size() - margin;
 
     // If we don't do that, the boundingRect() might not be suitable for drawText() (Qt issue N67674)
     m_text.replace( QRegExp( " +\n" ), "\n" );
@@ -311,7 +308,7 @@ OSDWidget::determineMetrics( const int M )
     rect.adjust( -M, -M, M, M );
 
     const QSize newSize = rect.size();
-    const QRect screen = QApplication::desktop()->screenGeometry( m_screen );
+    const QRect screenRect = QApplication::screens()[ screen() ]->geometry();
     QPoint newPos( MARGIN, m_yOffset );
 
     switch( m_alignment )
@@ -320,25 +317,25 @@ OSDWidget::determineMetrics( const int M )
             break;
 
         case Right:
-            newPos.rx() = screen.width() - MARGIN - newSize.width();
+            newPos.rx() = screenRect.width() - MARGIN - newSize.width();
             break;
 
         case Center:
-            newPos.ry() = ( screen.height() - newSize.height() ) / 2;
+            newPos.ry() = ( screenRect.height() - newSize.height() ) / 2;
 
             Q_FALLTHROUGH();
 
         case Middle:
-            newPos.rx() = ( screen.width() - newSize.width() ) / 2;
+            newPos.rx() = ( screenRect.width() - newSize.width() ) / 2;
             break;
     }
 
     //ensure we don't dip below the screen
-    if ( newPos.y() + newSize.height() > screen.height() - MARGIN )
-        newPos.ry() = screen.height() - MARGIN - newSize.height();
+    if ( newPos.y() + newSize.height() > screenRect.height() - MARGIN )
+        newPos.ry() = screenRect.height() - MARGIN - newSize.height();
 
     // correct for screen position
-    newPos += screen.topLeft();
+    newPos += screenRect.topLeft();
 
     return QRect( newPos, rect.size() );
 }
@@ -508,7 +505,9 @@ OSDPreviewWidget::OSDPreviewWidget( QWidget *parent )
     setDuration( 0 );
     setImage( Amarok::icon() );
     setTranslucent( AmarokConfig::osdUseTranslucency() );
-    setText( i18n( "On-Screen-Display preview\nDrag to reposition" ) );
+    // Drag-positioning not available on Wayland, so let's hide any untrue ideas about dragging
+    // TODO maybe one day Wayland will be first-class OSD citizen
+    setText( KWindowSystem::isPlatformWayland() ? i18n ( "Preview" ) : i18n( "On-Screen-Display preview\nDrag to reposition" ) );
 }
 
 void
@@ -516,7 +515,9 @@ OSDPreviewWidget::mousePressEvent( QMouseEvent *event )
 {
     m_dragYOffset = event->pos();
 
-    if( event->button() == Qt::LeftButton && !m_dragging )
+    // As we can't position OSD on Wayland at the moment, and grabbing mouse doesn't quite work
+    // either, let's disable this for now.
+    if( !KWindowSystem::isPlatformWayland() && event->button() == Qt::LeftButton && !m_dragging )
     {
         grabMouse( Qt::SizeAllCursor );
         m_dragging = true;
@@ -551,7 +552,7 @@ OSDPreviewWidget::mouseMoveEvent( QMouseEvent *e )
     {
         // Here we implement a "snap-to-grid" like positioning system for the preview widget
 
-        const QRect screenRect  = QApplication::desktop()->screenGeometry( screen() );
+        const QRect screenRect  = QApplication::screens()[ screen() ]->geometry();
         const uint  hcenter     = screenRect.width() / 2;
         const uint  eGlobalPosX = e->globalPos().x() - screenRect.left();
         const uint  snapZone    = screenRect.width() / 24;
@@ -592,8 +593,7 @@ OSDPreviewWidget::mouseMoveEvent( QMouseEvent *e )
         move( destination );
 
         // compute current Position && Y-offset
-        QDesktopWidget *desktop = QApplication::desktop();
-        const int currentScreen = desktop->screenNumber( pos() );
+        const int currentScreen = QGuiApplication::screens().indexOf( QGuiApplication::screenAt( pos() ) );
 
         // set new data
         OSDWidget::setScreen( currentScreen );
diff --git a/src/widgets/PixmapViewer.cpp b/src/widgets/PixmapViewer.cpp
index 158540f541ed7d96c44b85e9e24e9f4c987a3f2d..332dbc5d5e62c83c745913f47a942f13acc80f0e 100644
--- a/src/widgets/PixmapViewer.cpp
+++ b/src/widgets/PixmapViewer.cpp
@@ -21,11 +21,11 @@
 
 #include <QApplication>
 
-#include <QDesktopWidget>
 #include <QMouseEvent>
 #include <QLabel>
 #include <QPixmap>
 #include <QPainter>
+#include <QScreen>
 #include <QWheelEvent>
 
 
@@ -35,8 +35,8 @@ PixmapViewer::PixmapViewer( QWidget *parent, const QPixmap &pix, int screenNumbe
 {
     m_zoomFactor = 1.0; // initial zoom
 
-    int screenWidth = QApplication::desktop()->availableGeometry( screenNumber ).width();
-    int screenHeight = QApplication::desktop()->availableGeometry( screenNumber ).height();
+    int screenWidth = QApplication::screens()[ screenNumber ]->availableGeometry().width();
+    int screenHeight = QApplication::screens()[ screenNumber ]->availableGeometry().height();
     if( screenWidth < m_pixmap.width() || screenHeight < m_pixmap.height() )
     {
         qreal zoomFactorX = qreal(screenWidth) / m_pixmap.width();
